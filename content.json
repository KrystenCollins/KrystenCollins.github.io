{"meta":{"title":"Collins's Blog","subtitle":"碎梦拾荒者","description":"且行且珍惜","author":"Krysten· Collins","url":"https://krystencollins.github.io","root":"/"},"pages":[{"title":"","date":"2024-05-10T09:09:12.515Z","updated":"2024-05-10T09:09:12.499Z","comments":true,"path":"404.html","permalink":"https://krystencollins.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-10T09:06:51.337Z","updated":"2024-05-10T09:06:51.337Z","comments":true,"path":"about/index.html","permalink":"https://krystencollins.github.io/about/index.html","excerpt":"","text":"Hello, Welcome to Collins’s Blog!!"},{"title":"分类","date":"2024-05-10T09:05:56.537Z","updated":"2024-05-10T09:05:56.537Z","comments":true,"path":"categories/index.html","permalink":"https://krystencollins.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-05-10T09:08:15.534Z","updated":"2024-05-10T09:08:15.523Z","comments":true,"path":"friends/index.html","permalink":"https://krystencollins.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"标签","date":"2024-05-10T09:06:47.641Z","updated":"2024-05-10T09:06:47.641Z","comments":true,"path":"tags/index.html","permalink":"https://krystencollins.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Prim & Kruskal","slug":"p/leetcode/day117","date":"2024-08-26T16:00:00.000Z","updated":"2024-08-27T08:29:56.551Z","comments":true,"path":"p/leetcode/day117/","permalink":"https://krystencollins.github.io/p/leetcode/day117/","excerpt":"","text":"53. 寻宝题目描述：在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。 不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将 所有岛屿联通起来（注意：这是一个无向图）。 给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。 示例：输入描述 第一行包含两个整数V 和 E，V代表顶点数，E代表边数 。顶点编号是从1到V。例如：V&#x3D;2，一个有两个顶点，分别是1和2。 接下来共有 E 行，每行三个整数 v1，v2 和 val，v1 和 v2 为边的起点和终点，val代表边的权值。 输出描述 输出联通所有岛屿的最小路径总距离 输入示例 1234567891011127 111 2 11 3 11 5 22 6 12 4 22 3 23 4 14 5 15 6 25 7 16 7 1 输出示例 16 提示:数据范围：2 &lt;&#x3D; V &lt;&#x3D; 10000;1 &lt;&#x3D; E &lt;&#x3D; 100000;0 &lt;&#x3D; val &lt;&#x3D; 10000; 如下图，可见将所有的顶点都访问一遍，总距离最低是6. 题解：Prim算法详细思路 从 节点 的角度出发，采用贪心的策略，每次寻找距离最小生成树最近的节点加入到生成树中。 每次选择距离生成树最近的节点 最近节点加入生成树 更新 未加入节点 到达生成树的最小距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() &#123; int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; // 邻接矩阵 vector&lt;vector&lt;int&gt;&gt; grid(v + 1, vector&lt;int&gt;(v + 1, 10001)); while (e--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; grid[x][y] = k; grid[y][x] = k; &#125; vector&lt;int&gt; minDist(v + 1, 10001); // 所有节点到最小生成树的距离 vector&lt;bool&gt; isInTree(v + 1, false); // 节点是否在最小生成树中 // n - 1 条边，只需要遍历n-1次 for (int i = 1; i &lt; v; ++i) &#123; // 1. 选择距离生成树最近的节点 int cur = -1; int minVal = INT_MAX; for (int j = 1; j &lt;= v; ++j) &#123; // 顶点编号1~v if (!isInTree[j] &amp;&amp; minDist[j] &lt; minVal) &#123; // 不在生成树 并且 距离最近，严格小于 minVal = minDist[j]; cur = j; &#125; &#125; // 2. 最近节点cur加入生成树 isInTree[cur] = true; // 3. 更新非生成树节点到生成树的距离，即更新minDist数组 // cur节点加入后，最小生成树加入了新节点，那么 未加入最小生成树的节点的minDist数值需要更新 // 只需要关心 与cur相连的 且 未加入的 节点 for (int j = 1; j &lt;= v; ++j) &#123; if (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123; minDist[j] = grid[cur][j]; &#125; &#125; &#125; // 统计结果 int result = 0; for (int i = 2; i &lt;= v; ++i) &#123; // 不统计第一个节点，因为正是从第一个节点出发的 result += minDist[i]; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2) 打印最小生成树的每条边： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int main() &#123; int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; // 邻接矩阵 vector&lt;vector&lt;int&gt;&gt; grid(v + 1, vector&lt;int&gt;(v + 1, 10001)); while (e--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; grid[x][y] = k; grid[y][x] = k; &#125; vector&lt;int&gt; minDist(v + 1, 10001); // 所有节点到最小生成树的距离 vector&lt;bool&gt; isInTree(v + 1, false); // 节点是否在最小生成树中 vector&lt;int&gt; parent(v + 1, -1); // n - 1 条边，只需要遍历n-1次 for (int i = 1; i &lt; v; ++i) &#123; // 1. 选择距离生成树最近的节点 int cur = -1; int minVal = INT_MAX; for (int j = 1; j &lt;= v; ++j) &#123; // 顶点编号1~v if (!isInTree[j] &amp;&amp; minDist[j] &lt; minVal) &#123; // 不在生成树 并且 距离最近，严格小于 minVal = minDist[j]; cur = j; &#125; &#125; // 2. 最近节点cur加入生成树 isInTree[cur] = true; // 3. 更新非生成树节点到生成树的距离，即更新minDist数组 // cur节点加入后，最小生成树加入了新节点，那么 未加入最小生成树的节点的minDist数值需要更新 // 只需要关心 与cur相连的 且 未加入的 节点 for (int j = 1; j &lt;= v; ++j) &#123; if (!isInTree[j] &amp;&amp; grid[cur][j] &lt; minDist[j]) &#123; minDist[j] = grid[cur][j]; parent[j] = cur; // 记录边 &#125; &#125; &#125; // 统计结果 int result = 0; for (int i = 2; i &lt;= v; ++i) &#123; // 不统计第一个节点，因为正是从第一个节点出发的 result += minDist[i]; &#125; cout &lt;&lt; result &lt;&lt; endl; // 输出最小生成树的链接情况 for (int i = 1; i &lt;= v; ++i) &#123; cout &lt;&lt; i &lt;&lt; &quot; --&gt; &quot; &lt;&lt; parent[i] &lt;&lt; endl; &#125; return 0;&#125; Kruskal算法详细思路 从 边 的角度出发，贪心策略优先选择权值最小的边加入到最小生成树中。 边权值排序 若边首尾两个节点在同一个集合，说明连上这条边会出现环 若边首尾两个节点不在同一个集合，则加入到最小生成树中，并把两个节点加入同一个集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Edge &#123; int l, r, val;&#125;;int n = 10001;vector&lt;int&gt; father(n, -1);void init() &#123; for (int i = 0; i &lt; n; ++i) father[i] = i;&#125;int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]);&#125;void join(int u, int v) &#123; u = find(u); v = find(v); if (u != v) father[v] = u;&#125;int main() &#123; int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; vector&lt;Edge&gt; edges; int result_val = 0; while (e--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; edges.push_back(&#123;x, y, k&#125;); &#125; // 按边的权值从小到大排序 sort(edges.begin(), edges.end(), [](const Edge&amp; a, const Edge&amp; b) &#123; return a.val &lt; b.val; &#125;); init(); // 初始化并查集 for (Edge&amp; edge : edges) &#123; // 找两个节点的根节点 int x = find(edge.l); int y = find(edge.r); if (x != y) &#123; // 根节点不同，不在同一个集合中 result_val += edge.val; join(x, y); // 两个节点并入同一个集合中 &#125; &#125; cout &lt;&lt; result_val &lt;&lt; endl; return 0;&#125; 时间复杂度：O(elog e)，快排elog e + 并查集log e 空间复杂度：O(n + e) 打印每条边： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Edge &#123; int l, r, val;&#125;;int n = 10001;vector&lt;int&gt; father(n, -1);void init() &#123; for (int i = 0; i &lt; n; ++i) father[i] = i;&#125;int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]);&#125;void join(int u, int v) &#123; u = find(u); v = find(v); if (u != v) father[v] = u;&#125;int main() &#123; int v, e; int x, y, k; cin &gt;&gt; v &gt;&gt; e; vector&lt;Edge&gt; edges; int result_val = 0; vector&lt;Edge&gt; result; // 存储最小生成树的边 while (e--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; edges.push_back(&#123;x, y, k&#125;); &#125; // 按边的权值从小到大排序 sort(edges.begin(), edges.end(), [](const Edge&amp; a, const Edge&amp; b) &#123; return a.val &lt; b.val; &#125;); init(); // 初始化并查集 for (Edge&amp; edge : edges) &#123; // 找两个节点的根节点 int x = find(edge.l); int y = find(edge.r); if (x != y) &#123; // 根节点不同，不在同一个集合中 result.push_back(edge); result_val += edge.val; join(x, y); // 两个节点并入同一个集合中 &#125; &#125; cout &lt;&lt; result_val &lt;&lt; endl; // 打印最小生成树的边 for (Edge edge : result) &#123; cout &lt;&lt; edge.l &lt;&lt; &quot; -- &quot; &lt;&lt; edge.r &lt;&lt; &quot; : &quot; &lt;&lt; edge.val &lt;&lt; endl; &#125; return 0;&#125; 总结Prim算法维护节点的集合，时间复杂度O(n ^ 2)，运行效率与 边的数量无关，适用于稠密图（边多） Kruskal算法维护边的集合，时间复杂度O(elog e)，运行效率与 节点的数量无关，适用于稀疏图（顶点多边少）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"冗余连接II","slug":"p/leetcode/day116","date":"2024-08-25T16:00:00.000Z","updated":"2024-08-27T03:43:27.858Z","comments":true,"path":"p/leetcode/day116/","permalink":"https://krystencollins.github.io/p/leetcode/day116/","excerpt":"","text":"109. 冗余连接II题目描述：有向树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有根树拥有 n 个节点和 n - 1 条边。 输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。 示例：输入描述 第一行输入一个整数 N，表示有向图中节点和边的个数。 后续 N 行，每行输入两个整数 s 和 t，代表 s 节点有一条连接 t 节点的单向边 输出描述 输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。 输入示例 123431 21 32 3 输出示例 12 3 提示： 在删除 2 3 后有向图可以变为一棵合法的有向树，所以输出 2 3 数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 1000. 题解：并查集题干：有向图&#x3D;有向树+一条有向边 因此只需要找到并删除多余的那条 有向边 有向树：只有根节点的入度为0，其他节点入度都为1，因为除了根节点之外其他节点有且只有一个父节点 存在入度为2的节点：情况1，任意删除哪条边都可以构成有向树，删除输入中最后出现的边 删除1 3或者删除2 3 ​ 情况2：只能删除两条边中的特定一条 只能删除1 3 不存在入度为2的节点：即存在有向环，删除构成有向环的边 删除3 2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;vector&lt;int&gt; father(1001, 0);void init() &#123; for (int i = 1; i &lt;= n; ++i) father[i] = i;&#125;int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]);&#125;void join(int u, int v) &#123; u = find(u); v = find(v); if (u != v) father[v] = u;&#125;bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v;&#125;// 删一条边后判断是不是树。deleteEdge为待删除边 的下标bool isTreeAfterRemoveEdge(const vector&lt;vector&lt;int&gt;&gt;&amp; edges, int deleteEdge) &#123; init(); // 初始化并查集 for (int i = 0; i &lt; n; ++i) &#123; if (i == deleteEdge) continue; // 构成有向环，一定不是树 if (isSame(edges[i][0], edges[i][1])) return false; join(edges[i][0], edges[i][1]); &#125; return true;&#125;// 在有向图里找到删除的那条边，使其变成树void getRemoveEdge(const vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; init(); // 初始化并查集 for (int i = 0; i &lt; n; ++i) &#123; if (isSame(edges[i][0], edges[i][1])) &#123; // 构成有向环，找到要删除的边 cout &lt;&lt; edges[i][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[i][1]; return; &#125; else &#123; join(edges[i][0], edges[i][1]); &#125; &#125;&#125;int main() &#123; int s, t; vector&lt;vector&lt;int&gt;&gt; edges; cin &gt;&gt; n; vector&lt;int&gt; inDegree(n + 1, 0); // 记录节点入度 for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s &gt;&gt; t; ++inDegree[t]; edges.push_back(&#123;s, t&#125;); &#125; vector&lt;int&gt; vec; // 记录入度为2的边 的下标！！（如果有的话就两条边） // 找入度为2的节点对应的边，注意倒序查找，因为优先删除最后出现的一条边 for (int i = n - 1; i &gt;= 0; --i) &#123; if (inDegree[edges[i][1]] == 2) &#123; vec.push_back(i); &#125; &#125; // 情况1、情况2 if (vec.size() &gt; 0) &#123; // vec中的边 对应的下标 已经倒序 if (isTreeAfterRemoveEdge(edges, vec[0])) &#123; cout &lt;&lt; edges[vec[0]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[0]][1]; &#125; else &#123; cout &lt;&lt; edges[vec[1]][0] &lt;&lt; &quot; &quot; &lt;&lt; edges[vec[1]][1]; &#125; &#125; else &#123; getRemoveEdge(edges); // 情况3 &#125; return 0;&#125; leetcode题目：685. 冗余连接 II","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"冗余连接","slug":"p/leetcode/day115","date":"2024-08-16T16:00:00.000Z","updated":"2024-08-26T09:57:52.634Z","comments":true,"path":"p/leetcode/day115/","permalink":"https://krystencollins.github.io/p/leetcode/day115/","excerpt":"","text":"108. 冗余连接题目描述：树可以看成是一个图（拥有 n 个节点和 n - 1 条边的连通无环无向图）。 现给定一个拥有 n 个节点（节点标号是从 1 到 n）和 n 条边的连通无向图，请找出一条可以删除的边，删除后图可以变成一棵树。 示例：输入描述 第一行包含一个整数 N，表示图的节点个数和边的个数。 后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。 输出描述 输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。 输入示例 123431 22 31 3 输出示例 11 3 提示: 图中的 1 2，2 3，1 3 等三条边在删除后都能使原图变为一棵合法的树。但是 1 3 由于是标准输出里最后出现的那条边，所以输出结果为 1 3 数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 1000. 题解：并查集123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;vector&lt;int&gt; father = vector&lt;int&gt; (1001, 0);void init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; father[i] = i; &#125;&#125;int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]);&#125;bool join(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return false; else &#123; father[v] = u; return true; &#125;&#125;int main() &#123; cin &gt;&gt; n; int s, t; init(); while (n--) &#123; cin &gt;&gt; s &gt;&gt; t; if (!join(s, t)) &#123; cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl; break; &#125; &#125; return 0;&#125; leetcode题目： 684. 冗余连接","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"寻找存在的路径","slug":"p/leetcode/day114","date":"2024-08-15T16:00:00.000Z","updated":"2024-08-26T13:05:59.208Z","comments":true,"path":"p/leetcode/day114/","permalink":"https://krystencollins.github.io/p/leetcode/day114/","excerpt":"","text":"107. 寻找存在的路径题目描述：给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。 你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。 示例：输入描述 第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。 后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。 最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。 输出描述 输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。 输入示例 1234565 41 21 32 43 41 4 输出示例 11 提示: 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 100。 题解：深度优先搜索123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;bool&gt;&amp; visited, int source, int destination) &#123; for (int i = 0; i &lt; graph[source].size(); ++i) &#123; int x = graph[source][i]; if (!visited[x]) &#123; visited[x] = true; if (x == destination) return; dfs(graph, visited, x, destination); &#125; &#125;&#125;int main() &#123; int n, m, s, t, source, destination; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; graph(n+1, vector&lt;int&gt;(0)); while(m--) &#123; cin &gt;&gt; s &gt;&gt; t; graph[s].push_back(t); graph[t].push_back(s); &#125; cin &gt;&gt; source &gt;&gt; destination; vector&lt;bool&gt; visited(n+1, false); visited[source] = true; dfs(graph, visited, source, destination); if (visited[destination]) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return 0;&#125; 并查集12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n; // 节点数量vector&lt;int&gt; father = vector&lt;int&gt; (101, 0);// 并查集初始化void init() &#123; for (int i = 1; i &lt;= n; ++i) father[i] = i;&#125;// 并查集寻根过程int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]);&#125;// 判断 u 和 v 是否同一个根bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v;&#125;// 将节点u和v所在集合 合并void join(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return; father[v] = u;&#125;int main() &#123; int m, s, t, source, destination; cin &gt;&gt; n &gt;&gt; m; init(); while(m--) &#123; cin &gt;&gt; s &gt;&gt; t; join(s, t); &#125; cin &gt;&gt; source &gt;&gt; destination; if (isSame(source, destination)) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return 0;&#125; leetcode题目： 1971. 寻找图中是否存在路径","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"并查集理论","slug":"p/leetcode/day113","date":"2024-08-14T16:00:00.000Z","updated":"2024-08-26T08:37:36.234Z","comments":true,"path":"p/leetcode/day113/","permalink":"https://krystencollins.github.io/p/leetcode/day113/","excerpt":"","text":"并查集理论并查集两个主要功能： 将两个元素调价到一个集合中 判断两个元素在不在同一个集合 基本原理将三个元素A、B、C放在同个一集合中，其实就是将三个元素连通在一起，如何连通呢？ 只需要用一个一维数组表示：father[A] &#x3D; B, father[B] &#x3D; C 这样就表述A与B与C连通了（有向连通图） 1234567// 将v、u两个节点所在集合 两个集合void join(int u, int v) &#123; u = find(u); // 寻找u的根 v = find(v); // 寻找v的根 if (u == v) reurn; // 如果发现根相同，则说明在同一个集合，不需要两个节点相连直接返回 father[v] = u; // 节点v的根指向节点u的根节点&#125; 寻根思路：只要A，B，C在同一个根下就是同一个集合。 给出A元素，就可以通过father[A] &#x3D; B, father[B] &#x3D; C, 找到根为C。 给出B元素，可以通过father[B] &#x3D; C 找到根为C，说明A和B是在同一个集合中。 12345// 并查集寻根过程int find(int u) &#123; if (u == father[u]) return u; // 如果根就是自己，直接返回 else return find(father[u]); // 如果根不是自己，就根据父节点（数组下标）一层一层往上找&#125; 如何表示C也在同一个集合里呢？只需要father[C] &#x3D; C，即C的根也为C，这样就方便表示A，B，C都在同一个集合里。 所以father数组初始化时要默认自己指向自己，初始化自己就是一个集合。 123456// 并查集初始化void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125;&#125; 如何判断两个元素是否在同一个集合里？如果通过find函数 找到两个元素属于同一个根的话，那么这两个元素就是同一个集合 123456// 判断 u 和 v 是否同一个集合bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v;&#125; 路径压缩 将非根节点的所有节点直接指向根节点，只需要在递归过程中，让 father[u] 接住 递归函数find(father[u]) 的返回结果。 find函数向上寻找根节点，father[u]表示u的父节点，让father[u]直接获取find函数返回的根节点，这样就让节点u的父节点变成根节点。 原始代码： 12345// 并查集寻根过程int find(int u) &#123; if (u == father[u]) return u; // 如果根就是自己，直接返回 else return find(father[u]); // 如果根不是自己，根据数组下标一层一层往上找&#125; 路径压缩一行代码： 1234int find(int u) &#123; if (u == father[u]) return u; else return father[u] = find(father[u]); // 路径压缩&#125; 精简代码： 123int find(int u) &#123; return u == father[u] ? u :father[u] = find(father[u]);&#125; 代码模板 1234567891011121314151617181920212223242526272829int n = 1005; // 节点数量vector&lt;int&gt; father = vector&lt;int&gt;(n, 0);// 并查集初始化void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125;&#125;// 并查集寻根过程int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩&#125;// 判断 u 和 v 是否为同一个集合，即是否同一个根bool isSame(int u, int v) &#123; u = find(u); // 节点u的根节点 v = find(v); // 节点v的根节点 return u == v;&#125;// 将v、u两个节点所在集合 两个集合void join(int u, int v) &#123; u = find(u); // u的根节点 v = find(v); // v的根节点 if (u == v) return; // 根相同，在同一集合里，两节点已相连 father[v] = u; // 节点v的根指向节点u的根节点&#125; 误区：不可以抽象join函数。以下为错误代码！！！ 1234void join(int u, int v) &#123; if (isSame(u, v)) return; father[v] = u;&#125; 实际上相同片段代码正确写法： 123int uroot = find(u);int vroot = find(v);if (uroot == vroot) return; find函数并不是直接相连节点u和节点v，而是找到两个节点所在集合的根节点，将根节点相连 拓展另一种“路径压缩”方法：按秩（rank）合并 rank表示树的高度，即树中节点层次的最大值 树1 秩为2，树2 秩为3。合并两个集合，应该树1 并入 树2！！ 一定是rank 小的树并入rank大的树，这样可以保证合并后的树rank 最小，降低在树上查询的路径长度。 代码模板： 12345678910111213141516171819202122232425262728293031int n = 1005;vector&lt;int&gt; father = vector&lt;int&gt;(n, 0);vector&lt;int&gt; rank = vector&lt;int&gt;(n, 1); // 每棵树的高度都为1void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; rank[i] = 1; // 也可以不写 &#125;&#125;int find(int u) &#123; return u == father[u] ? u : find(father[u]); // 注意这里不做路径压缩！！&#125;bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v;&#125;void join(int u, int v) &#123; u = find(u); v = find(v); if (rank[u] &lt;= rank[v]) father[u] = v; // rank小的树并入rank大的树 else father[v] = u; // 如果两棵树高度相同，则v高度+1，因为上面是 &lt;= 符号 if (rank[u] == rank[v] &amp;&amp; u != v) ++rank[v];&#125; 上面的模板中，没有做路径压缩，因为一旦路径压缩，rank记录的高度就不准确了，根据rank来判断如何合并没有意义。 因此，直接使用路径压缩的并查集模板就好。 复杂度分析空间复杂度：O(n)，申请一个father数组。 时间复杂度：路径压缩后的并查集时间复杂度在O(log n) 和O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"图像渲染","slug":"p/leetcode/day112","date":"2024-08-13T16:00:00.000Z","updated":"2024-08-16T06:59:51.091Z","comments":true,"path":"p/leetcode/day112/","permalink":"https://krystencollins.github.io/p/leetcode/day112/","excerpt":"","text":"733. 图像渲染题目描述：有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。 你也被给予三个整数 sr , sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。 为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。 最后返回 经过上色渲染后的图像 。 示例：示例 1: 1234输入: image = [[1,1,1],[1,1,0],[1,0,1]]，sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。 示例 2: 12输入: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2输出: [[2,2,2],[2,2,2]] 提示: m == image.length n == image[i].length 1 &lt;= m, n &lt;= 50 0 &lt;= image[i][j], newColor &lt; 216 题解：深度优先搜索123456789101112131415161718192021222324class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int oldColor) &#123; if (image[x][y] == oldColor) &#123; image[x][y] = color; for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dir[i][0]; int ny = y + dir[i][1]; if (nx &lt; 0 || nx &gt;= image.size() || ny &lt; 0 || ny &gt;= image[0].size()) continue; dfs(image, nx, ny, color, oldColor); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) &#123; int oldColor = image[sr][sc]; if (oldColor != color) &#123; dfs(image, sr, sc, color, oldColor); &#125; return image; &#125;&#125;; 广度优先搜索1234567891011121314151617181920212223242526class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) &#123; int oldColor = image[sr][sc]; if (oldColor == color) return image; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;sr, sc&#125;); image[sr][sc] = color; while (!que.empty()) &#123; auto [x, y] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dir[i][0]; int ny = y + dir[i][1]; if (nx &lt; 0 || nx &gt;= image.size() || ny &lt; 0 || ny &gt;= image[0].size()) continue; if (image[nx][ny] == oldColor) &#123; que.push(&#123;nx, ny&#125;); image[nx][ny] = color; &#125; &#125; &#125; return image; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"有向图的完全可达性","slug":"p/leetcode/day111","date":"2024-08-12T16:00:00.000Z","updated":"2024-08-16T05:51:34.717Z","comments":true,"path":"p/leetcode/day111/","permalink":"https://krystencollins.github.io/p/leetcode/day111/","excerpt":"","text":"105. 有向图的完全可达性题目描述：给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。 示例：输入描述 第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。 输出描述 如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。 输入示例 123454 41 22 11 32 4 输出示例 11 提示： 从 1 号节点可以到达任意节点，输出 1。 数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 100；1 &lt;&#x3D; K &lt;&#x3D; 2000。 题解：深度优先搜索123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;using namespace std;unordered_set&lt;int&gt; uset;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x) &#123; if (graph[x].size() == 0) return; for (int i = 0; i &lt; graph[x].size(); ++i) &#123; if (uset.find(graph[x][i]) == uset.end()) &#123; uset.insert(graph[x][i]); dfs(graph, graph[x][i]); &#125; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(0)); int s, t; for (int i = 0; i &lt; k; ++i) &#123; cin &gt;&gt; s &gt;&gt; t; graph[s].push_back(t); &#125; uset.insert(1); dfs(graph, 1); if (uset.size() == n) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; 广度优先搜索123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;#include &lt;queue&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(0)); int s, t; for (int i = 0; i &lt; k; ++i) &#123; cin &gt;&gt; s &gt;&gt; t; graph[s].push_back(t); &#125; unordered_set&lt;int&gt; uset; uset.insert(1); queue&lt;int&gt; que; que.push(1); while (!que.empty()) &#123; int x = que.front(); que.pop(); for (int i = 0; i &lt; graph[x].size(); ++i) &#123; if (uset.find(graph[x][i]) == uset.end()) &#123; uset.insert(graph[x][i]); que.push(graph[x][i]); &#125; &#125; &#125; if (uset.size() == n) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"岛屿的周长","slug":"p/leetcode/day110","date":"2024-08-11T16:00:00.000Z","updated":"2024-08-13T14:46:11.556Z","comments":true,"path":"p/leetcode/day110/","permalink":"https://krystencollins.github.io/p/leetcode/day110/","excerpt":"","text":"106. 岛屿的周长题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出一个整数，表示岛屿的周长。 输入示例 1234565 50 0 0 0 0 0 1 0 1 00 1 1 1 00 1 1 1 00 0 0 0 0 输出示例 114 提示 岛屿的周长为 14。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 50。 题解：迭代法方法一： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (grid[i][j] == 1) &#123; for (int k = 0; k &lt; 4; ++k) &#123; int x = i + dir[k][0]; int y = j + dir[k][1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] == 0) &#123; ++result; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 方法二： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; int land = 0; // 陆地数量 int cover = 0; // 相邻数量 for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (grid[i][j] == 1) &#123; ++land; // 统计上边相邻陆地 if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) ++cover; // 统计左边相邻陆地 if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1) ++cover; // 避免重复计算，不统计下边和左边！！ &#125; &#125; &#125; cout &lt;&lt; land * 4 - cover * 2 &lt;&lt; endl; return 0;&#125; 深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if (x &lt; 0 || x &gt;= grid.size() || y &lt; 0 || y &gt;= grid[0].size() || grid[x][y] == 0) &#123; return 1; &#125; if (grid[x][y] == 2) return 0; // 已访问 grid[x][y] = 2; int res = 0; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; res += dfs(grid, nextx, nexty); &#125; return res;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (grid[i][j] == 1) &#123; result += dfs(grid, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; leetcode题目： 463. 岛屿的周长","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"字符串接龙","slug":"p/leetcode/day109","date":"2024-08-10T16:00:00.000Z","updated":"2024-08-13T13:43:40.251Z","comments":true,"path":"p/leetcode/day109/","permalink":"https://krystencollins.github.io/p/leetcode/day109/","excerpt":"","text":"110. 字符串接龙题目描述：字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列： \\1. 序列中第一个字符串是 beginStr。 \\2. 序列中最后一个字符串是 endStr。 \\3. 每次转换只能改变一个字符。 \\4. 转换过程中的中间字符串必须是字典 strList 中的字符串，且strList里的每个字符串只用使用一次。 给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。 示例：输入描述 第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。 输出描述 输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。 输入示例 123456786abc defefcdbcebcdecdfcyhn 输出示例 14 提示从 startStr 到 endStr，在 strList 中最短的路径为 abc -&gt; dbc -&gt; dec -&gt; def，所以输出结果为 4，如图： 数据范围： 2 &lt;&#x3D; N &lt;&#x3D; 500 题解：广度优先搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;#include &lt;queue&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string beginStr, endStr, str; unordered_set&lt;string&gt; strSet; cin &gt;&gt; beginStr &gt;&gt; endStr; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; str; strSet.insert(str); &#125; // 记录strSet里的字符串是否被访问过，同时记录路径长度 unordered_map&lt;string, int&gt; visitMap; // &lt;记录的字符串，路径长度&gt; queue&lt;string&gt; que; // 初始化队列 que.push(beginStr); visitMap.insert(pair&lt;string, int&gt;(beginStr, 1)); // 初始化visitMap while (!que.empty()) &#123; string word = que.front(); que.pop(); int path = visitMap[word]; // 当前字符串在路径中的长度 // 开始在当前字符串中，逐个字符去替换 for (int i = 0; i &lt; word.size(); ++i) &#123; string newWord = word; // 遍历26个字母 for (int j = 0; j &lt; 26; ++j) &#123; newWord[i] = j + &#x27;a&#x27;; if (newWord == endStr) &#123; // 发现替换字母后，字符串与终点字符串相同 cout &lt;&lt; path + 1 &lt;&lt; endl; // 找到了最短路径 return 0; &#125; // 字符串集合里出现了newWord，并且newWord没有被访问过 if (strSet.find(newWord) != strSet.end() &amp;&amp; visitMap.find(newWord) == visitMap.end()) &#123; // 添加访问信息，并将新字符串放到队列中 visitMap.insert(pair&lt;string, int&gt;(newWord, path + 1)); que.push(newWord); &#125; &#125; &#125; &#125; cout &lt;&lt; 0 &lt;&lt; endl; // 没找到输出0 return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"统计无向图中无法互相到达点对数","slug":"p/leetcode/day108","date":"2024-08-09T16:00:00.000Z","updated":"2024-08-13T13:41:41.459Z","comments":true,"path":"p/leetcode/day108/","permalink":"https://krystencollins.github.io/p/leetcode/day108/","excerpt":"","text":"2316. 统计无向图中无法互相到达点对数题目描述：给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。 请你返回 无法互相到达 的不同 点对数目 。 示例：示例 1： 123输入：n = 3, edges = [[0,1],[0,2],[1,2]]输出：0解释：所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。 示例 2： 12345输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]输出：14解释：总共有 14 个点对互相无法到达：[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]所以我们返回 14 。 提示： 1 &lt;= n &lt;= 105 0 &lt;= edges.length &lt;= 2 * 105 edges[i].length == 2 0 &lt;= ai, bi &lt; n ai != bi 不会有重复边。 题解：深度优先搜索1234567891011121314151617181920212223242526272829303132class Solution &#123;public: long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;vector&lt;int&gt;&gt; graph(n); for (const auto&amp; edge : edges) &#123; graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); &#125; vector&lt;bool&gt; visited(n, false); function&lt;int(int)&gt; dfs = [&amp;](int x) -&gt; int &#123; visited[x] = true; int count = 1; for (auto y : graph[x]) &#123; if (!visited[y]) &#123; count += dfs(y); &#125; &#125; return count; &#125;; long long result = 0; for (int i = 0; i &lt; n; ++i) &#123; if (!visited[i]) &#123; long long count = dfs(i); result += count * (n - count); &#125; &#125; return result / 2; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"网格图中鱼的最大数目","slug":"p/leetcode/day107","date":"2024-08-08T16:00:00.000Z","updated":"2024-08-13T07:10:21.565Z","comments":true,"path":"p/leetcode/day107/","permalink":"https://krystencollins.github.io/p/leetcode/day107/","excerpt":"","text":"2658. 网格图中鱼的最大数目题目描述：给你一个下标从 0 开始大小为 m x n 的二维整数数组 grid ，其中下标在 (r, c) 处的整数表示： 如果 grid[r][c] = 0 ，那么它是一块 陆地 。 如果 grid[r][c] &gt; 0 ，那么它是一块 水域 ，且包含 grid[r][c] 条鱼。 一位渔夫可以从任意 水域 格子 (r, c) 出发，然后执行以下操作任意次： 捕捞格子 (r, c) 处所有的鱼，或者 移动到相邻的 水域 格子。 请你返回渔夫最优策略下， 最多 可以捕捞多少条鱼。如果没有水域格子，请你返回 0 。 格子 (r, c) 相邻 的格子为 (r, c + 1) ，(r, c - 1) ，(r + 1, c) 和 (r - 1, c) ，前提是相邻格子在网格图内。 示例：示例 1： 123输入：grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]输出：7解释：渔夫可以从格子 (1,3) 出发，捕捞 3 条鱼，然后移动到格子 (2,3) ，捕捞 4 条鱼。 示例 2： 123输入：grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]输出：1解释：渔夫可以从格子 (0,0) 或者 (3,3) ，捕捞 1 条鱼。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 10 0 &lt;= grid[i][j] &lt;= 10 题解：深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int fish; void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &gt; 0) &#123; fish += grid[nextx][nexty]; visited[nextx][nexty] = true; dfs(grid, visited, nextx, nexty); &#125; &#125; &#125; int findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] &gt; 0) &#123; fish = grid[i][j]; visited[i][j] = true; dfs(grid, visited, i, j); result = max(result, fish); &#125; &#125; &#125; return result; &#125;&#125;; 广度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int fish; void bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; fish = grid[x][y]; while (!que.empty()) &#123; auto [curx, cury] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] &gt; 0) &#123; fish += grid[nextx][nexty]; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; &#125; &#125; &#125; &#125; int findMaxFish(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] &gt; 0) &#123; fish = grid[i][j]; bfs(grid, visited, i, j); result = max(result, fish); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"建造最大岛屿","slug":"p/leetcode/day106","date":"2024-08-07T16:00:00.000Z","updated":"2024-08-13T07:07:47.106Z","comments":true,"path":"p/leetcode/day106/","permalink":"https://krystencollins.github.io/p/leetcode/day106/","excerpt":"","text":"104. 建造最大岛屿题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。 岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出一个整数，表示最大的岛屿面积。如果矩阵中不存在岛屿，则输出 0。 输入示例 123454 51 1 0 0 01 1 0 0 00 0 1 0 00 0 0 1 1 输出示例 16 提示 对于上面的案例，有两个位置可将 0 变成 1，使得岛屿的面积最大，即 6。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 50。 题解：深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;int area;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; ++area; visited[nextx][nexty] = true; dfs(grid, visited, nextx, nexty); &#125; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; int result = 0; int land = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (grid[i][j] == 0) &#123; grid[i][j] = 1; area = 1; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); visited[i][j] = true; dfs(grid, visited, i, j); result = max(result, area); grid[i][j] = 0; &#125; else &#123; ++land; &#125; &#125; &#125; if (land == n * m) cout &lt;&lt; land &lt;&lt; endl; else cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"找到所有的农场组","slug":"p/leetcode/day105","date":"2024-08-06T16:00:00.000Z","updated":"2024-08-13T09:09:43.235Z","comments":true,"path":"p/leetcode/day105/","permalink":"https://krystencollins.github.io/p/leetcode/day105/","excerpt":"","text":"1992. 找到所有的农场组题目描述：给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地，1 表示一单位的农场土地。 为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 与另一个农场组的任何一块土地在四个方向上相邻。 land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 (r1, c1) 且右下角坐标为 (r2, c2) 的 农场组 用长度为 4 的数组 [r1, c1, r2, c2] 表示。 请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 land 中的一个 农场组 。如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。 示例：示例 1： 12345输入：land = [[1,0,0],[0,1,1],[0,1,1]]输出：[[0,0,0,0],[1,1,2,2]]解释：第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。 示例 2： 1234输入：land = [[1,1],[1,1]]输出：[[0,0,1,1]]解释：第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。 示例 3： 1234输入：land = [[0]]输出：[]解释：没有任何农场组。 提示： m == land.length n == land[i].length 1 &lt;= m, n &lt;= 300 land 只包含 0 和 1 。 农场组都是 矩形 的形状。 题解：深度优先搜索123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; vector&lt;int&gt; vec; void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; land, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= land.size() || nexty &lt; 0 || nexty &gt;= land[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; land[nextx][nexty] == 1) &#123; visited[nextx][nexty] = true; if (nextx &lt; vec[0] || nexty &lt; vec[1]) &#123;vec[0] = nextx; vec[1] = nexty;&#125; if (nextx &gt; vec[2] || nexty &gt; vec[3]) &#123;vec[2] = nextx; vec[3] = nexty;&#125; dfs(land, visited, nextx, nexty); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findFarmland(vector&lt;vector&lt;int&gt;&gt;&amp; land) &#123; int n = land.size(); int m = land[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; land[i][j] == 1) &#123; visited[i][j] = true; vec.clear(); vec = &#123;i, j, i, j&#125;; dfs(land, visited, i, j); result.push_back(vec); &#125; &#125; &#125; if (result.size()) return result; return &#123;&#125;; &#125;&#125;; 广度优先搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; vector&lt;int&gt; bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; land, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; vector&lt;int&gt; vec = &#123;x, y, x, y&#125;; while (!que.empty()) &#123; auto [curx, cury] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= land.size() || nexty &lt; 0 || nexty &gt;= land[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; land[nextx][nexty] == 1) &#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; if (nextx &lt; vec[0] || nexty &lt; vec[1]) &#123;vec[0] = nextx; vec[1] = nexty;&#125; if (nextx &gt; vec[2] || nexty &gt; vec[3]) &#123;vec[2] = nextx; vec[3] = nexty;&#125; &#125; &#125; &#125; return vec; &#125; vector&lt;vector&lt;int&gt;&gt; findFarmland(vector&lt;vector&lt;int&gt;&gt;&amp; land) &#123; int n = land.size(); int m = land[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; land[i][j] == 1) &#123; result.push_back(bfs(land, visited, i, j)); &#125; &#125; &#125; if (result.size()) return result; return &#123;&#125;; &#125;&#125;; 130. 被围绕的区域题目描述：给你一个 m x n 的矩阵 board ，由若干字符 &#39;X&#39; 和 &#39;O&#39; 组成，捕获 所有 被围绕的区域： 连接：一个单元格与水平或垂直方向上相邻的单元格连接。 区域：连接所有 &#39;O&#39; 的单元格来形成一个区域。 围绕：如果您可以用 &#39;X&#39; 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 &#39;X&#39; 单元格围绕。 通过将输入矩阵 board 中的所有 &#39;O&#39; 替换为 &#39;X&#39; 来 捕获被围绕的区域。 示例：示例 1： 输入：board &#x3D; [[“X”,”X”,”X”,”X”],[“X”,”O”,”O”,”X”],[“X”,”X”,”O”,”X”],[“X”,”O”,”X”,”X”]] 输出：[[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”X”,”X”,”X”],[“X”,”O”,”X”,”X”]] 解释： 在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。 示例 2： 输入：board &#x3D; [[“X”]] 输出：[[“X”]] 提示： m == board.length n == board[i].length 1 &lt;= m, n &lt;= 200 board[i][j] 为 &#39;X&#39; 或 &#39;O&#39; 题解：与 沉没孤岛 类似 深度优先搜索1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123; board[x][y] = &#x27;Y&#x27;; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= board.size() || nexty &lt; 0 || nexty &gt;= board[0].size()) continue; if (board[nextx][nexty] == &#x27;O&#x27;) dfs(board, nextx, nexty); &#125; &#125; void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int n = board.size(); int m = board[0].size(); for (int i = 0; i &lt; n; ++i) &#123; if (board[i][0] == &#x27;O&#x27;) dfs(board, i, 0); if (board[i][m - 1] == &#x27;O&#x27;) dfs(board, i, m - 1); &#125; for (int j = 0; j &lt; m; ++j) &#123; if (board[0][j] == &#x27;O&#x27;) dfs(board, 0, j); if (board[n - 1][j] == &#x27;O&#x27;) dfs(board, n - 1, j); &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; if (board[i][j] == &#x27;Y&#x27;) board[i][j] = &#x27;O&#x27;; &#125; &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"水流问题","slug":"p/leetcode/day104","date":"2024-08-05T16:00:00.000Z","updated":"2024-08-09T12:26:20.745Z","comments":true,"path":"p/leetcode/day104/","permalink":"https://krystencollins.github.io/p/leetcode/day104/","excerpt":"","text":"103. 水流问题题目描述：现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。 矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。 示例：输入描述 第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。 后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。 输出描述 输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。 输入示例 1234565 51 3 1 2 41 2 1 3 22 4 7 2 14 5 6 1 11 4 1 2 1 输出示例 123456780 41 32 23 03 13 24 04 1 提示 图中的蓝色方块上的雨水既能流向第一组边界，也能流向第二组边界。所以最终答案为所有蓝色方块的坐标。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 100。 题解：深度优先搜索从第一组边界上的节点 逆流而上，将遍历过的节点都标记上；同理从第二组边界上的节点逆流而上，将遍历过的节点都标记上。两次都被标记的节点则为答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; if (visited[x][y]) return; visited[x][y] = true; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= n || nexty &lt; 0 || nexty &gt;= m) continue; if (grid[nextx][nexty] &gt;= grid[x][y]) &#123; // 逆流而上 dfs(grid, visited, nextx, nexty); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; // 标记从第一组边界上的节点出发，可以遍历的节点 vector&lt;vector&lt;bool&gt;&gt; firstBorder(n, vector&lt;bool&gt;(m, false)); // 标记从第二组边界上结点出发，可以遍历的节点 vector&lt;vector&lt;bool&gt;&gt; secondeBorder(n, vector&lt;bool&gt;(m, false)); // 从最左和最右列的节点出发，向高处遍历 for (int i = 0; i &lt; n; ++i) &#123; dfs(grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界 dfs(grid, secondeBorder, i, m - 1); // 遍历最右列，接触第二组边界 &#125; // 从最上和最下行节点出发，向高处遍历 for (int j = 0; j &lt; m; ++j) &#123; dfs(grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界 dfs(grid, secondeBorder, n - 1, j); // 遍历最下行，接触第二组边界 &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (firstBorder[i][j] &amp;&amp; secondeBorder[i][j]) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"沉没孤岛","slug":"p/leetcode/day103","date":"2024-08-04T16:00:00.000Z","updated":"2024-08-09T11:52:04.792Z","comments":true,"path":"p/leetcode/day103/","permalink":"https://krystencollins.github.io/p/leetcode/day103/","excerpt":"","text":"102. 沉没孤岛题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。 现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。 之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出将孤岛“沉没”之后的岛屿矩阵。 注意：每个元素后面都有一个空格 输入示例 123454 51 1 0 0 01 1 0 0 00 0 1 0 00 0 0 1 1 输出示例 12341 1 0 0 01 1 0 0 00 0 0 0 00 0 0 1 1 提示： 将孤岛沉没。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 50。 题解：从四周遍历所有连接的陆地块，并标记为2，剩下中间的陆地块为孤岛，编号为1； 输出时，遇到2输出1，遇到1输出0即可沉没孤岛。。 深度优先搜索12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; grid[x][y] = 2; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (grid[nextx][nexty] == 1) &#123; dfs(grid, nextx, nexty); &#125; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; // 从左侧、右侧 向中间遍历 for (int i = 0; i &lt; n; ++i) &#123; if (grid[i][0] == 1) dfs(grid, i, 0); if (grid[i][m - 1] == 1) dfs(grid, i, m - 1); &#125; // 从上边、下边 向中间遍历 for (int j = 0; j &lt; m; ++j) &#123; if (grid[0][j] == 1) dfs(grid, 0, j); if (grid[n - 1][j] == 1) dfs(grid, n - 1, j); &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (grid[i][j] == 2) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; else cout &lt;&lt; 0 &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"孤岛的总面积","slug":"p/leetcode/day102","date":"2024-08-03T16:00:00.000Z","updated":"2024-08-07T05:58:25.224Z","comments":true,"path":"p/leetcode/day102/","permalink":"https://krystencollins.github.io/p/leetcode/day102/","excerpt":"","text":"101. 孤岛的总面积题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。 现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。 输出描述 输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。 输入示例 123454 51 1 0 0 01 1 0 0 00 0 1 0 00 0 0 1 1 输出示例 11 提示： 在矩阵中心部分的岛屿，因为没有任何一个单元格接触到矩阵边缘，所以该岛屿属于孤岛，总面积为 1。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 50。 题解：遇到边缘的陆地，不可能是孤岛；只统计是孤岛的面积 广度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std; int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; int area = 1; bool isIsolated = true; // 陆地在边缘 if (x == 0 || x == grid.size() - 1 || y == 0 || y == grid[0].size() - 1) isIsolated = false; while(!que.empty()) &#123; auto [curx, cury] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; ++area; if (nextx == 0 || nextx == grid.size() - 1 || nexty == 0 || nexty == grid[0].size() - 1) isIsolated = false; &#125; &#125; &#125; return isIsolated ? area : 0;&#125; int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; result += bfs(grid, visited, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;int area;bool isIsolated;void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0;i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; ++area; if (nextx == 0 || nextx == grid.size() - 1 || nexty == 0 || nexty == grid[0].size() - 1) isIsolated = false; visited[nextx][nexty] = true; dfs(grid, visited, nextx, nexty); &#125; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; visited[i][j] = true; area = 1; isIsolated = true; if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1) isIsolated = false; dfs(grid, visited, i, j); result += isIsolated ? area : 0; &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 1905. 统计子岛屿题目描述：给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。 请你返回 grid2 中 子岛屿 的 数目 。 示例：示例 1： 1234输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]输出：3解释：如上图所示，左边为 grid1 ，右边为 grid2 。grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。 示例 2： 1234输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]输出：2 解释：如上图所示，左边为 grid1 ，右边为 grid2 。grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。 提示： m == grid1.length == grid2.length n == grid1[i].length == grid2[i].length 1 &lt;= m, n &lt;= 500 grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。 题解：在grid2遇到陆地时，查看相同位置grid1是否为陆地 深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; bool isSubIsland; void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid1, const vector&lt;vector&lt;int&gt;&gt;&amp; grid2, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid2.size() || nexty &lt; 0 || nexty &gt;= grid2[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid2[nextx][nexty] == 1) &#123; visited[nextx][nexty] = true; if (grid1[nextx][nexty] == 0) isSubIsland = false; dfs(grid1, grid2, visited, nextx, nexty); &#125; &#125; &#125; int countSubIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2) &#123; int n = grid1.size(); int m = grid1[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid2[i][j] == 1) &#123; visited[i][j] = true; isSubIsland = true; if (grid1[i][j] == 0) isSubIsland = false; dfs(grid1, grid2, visited, i, j); result += isSubIsland; &#125; &#125; &#125; return result; &#125;&#125;; 广度优先搜索12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid1, const vector&lt;vector&lt;int&gt;&gt;&amp; grid2, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; int isSubIsland = true; if (grid1[x][y] == 0) isSubIsland = false; while (!que.empty()) &#123; auto [curx, cury] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid2.size() || nexty &lt; 0 || nexty &gt;= grid2[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid2[nextx][nexty] == 1) &#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; if (grid1[nextx][nexty] == 0) isSubIsland = false; &#125; &#125; &#125; return isSubIsland; &#125; int countSubIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2) &#123; int n = grid1.size(); int m = grid1[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid2[i][j] == 1) &#123; result += bfs(grid1, grid2, visited, i, j); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"岛屿的最大面积","slug":"p/leetcode/day101","date":"2024-08-02T16:00:00.000Z","updated":"2024-08-04T14:06:04.195Z","comments":true,"path":"p/leetcode/day101/","permalink":"https://krystencollins.github.io/p/leetcode/day101/","excerpt":"","text":"100. 岛屿的最大面积题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。 输入示例 123454 51 1 0 0 01 1 0 0 00 0 1 0 00 0 0 1 1 输出示例 14 提示： 样例输入中，岛屿的最大面积为 4。 数据范围： 1 &lt;&#x3D; M, N &lt;&#x3D; 50。 题解：广度优先搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;int bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; int area = 1; while (!que.empty()) &#123; auto [curx, cury] = que.front(); que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; ++area; &#125; &#125; &#125; return area;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; int tmp = bfs(grid, visited, i, j); result = max(result, tmp); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; leetcode题目： 695. 岛屿的最大面积 深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; int count = 0; void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; ++count; visited[nextx][nexty] = true; dfs(grid, visited, nextx, nexty); &#125; &#125; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; count = 1; visited[i][j] = true; dfs(grid, visited, i, j); result = max(result, count); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"岛屿数量","slug":"p/leetcode/day100","date":"2024-08-01T16:00:00.000Z","updated":"2024-08-03T09:31:02.271Z","comments":true,"path":"p/leetcode/day100/","permalink":"https://krystencollins.github.io/p/leetcode/day100/","excerpt":"","text":"99. 岛屿数量题目描述：给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。 示例：输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。 后续 N 行，每行包含 M 个数字，数字为 1 或者 0。 输出描述 输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。 输入示例 123454 51 1 0 0 01 1 0 0 00 0 1 0 00 0 0 1 1 输出示例 13 提示 根据测试案例中所展示，岛屿数量共有 3 个，所以输出 3。 数据范围： 1 &lt;&#x3D; N, M &lt;&#x3D; 50 题解：遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的所有陆地都标记上 再遇到标记过的陆地节点就直接跳过。这样计数器就是最终岛屿的数量 如何把节点陆地所能遍历到的陆地都标记上？使用DFS、BFS、并查集！ 广度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; // 四个方向void bfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; que.push(&#123;x, y&#125;); visited[x][y] = true; // 只要加入队列，立刻标记 while (!que.empty()) &#123; pair&lt;int, int&gt; cur = que.front(); que.pop(); int curx = cur.first; int cury = cur.second; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue; // 坐标越界，直接跳过 if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; // 只要加入队列，立刻标记 &#125; &#125; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; ++result; // 遇到没访问过的陆地 bfs(grid, visited, i, j); // 将与其连接的陆地都标记上true &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 深度优先搜索1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; // 四个方向void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty&gt;= grid[0].size()) continue; if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == 1) &#123; // 没有访问过 并且是陆地 visited[nextx][nexty] = true; dfs(grid, visited, nextx, nexty); &#125; &#125;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; grid(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(n, vector&lt;bool&gt;(m, false)); int result = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; ++result; // 遇到没访问过的陆地 visited[i] dfs(grid, visited, i, j); // 将与其连接的陆地都标记上true &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; leetcode题目： 200. 岛屿数量","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"广度优先搜索理论","slug":"p/leetcode/day100_1","date":"2024-08-01T16:00:00.000Z","updated":"2024-08-03T08:21:26.722Z","comments":true,"path":"p/leetcode/day100_1/","permalink":"https://krystencollins.github.io/p/leetcode/day100_1/","excerpt":"","text":"广度优先搜索一圈一圈地进行搜索： 代码框架保存遍历过的元素：队列、栈、数组都可以 队列：先进先出，需要保证每一圈都是一个方向去转 栈：先进后出：第一圈顺时针、第二圈逆时针、第三圈顺时针…… 广度优先搜索不需要注意 转圈搜索顺序！！ 1234567891011121314151617181920212223int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; // 表示四个方向：右下上左// grid地图，二维数组// visite标记访问过的节点，不再重复访问// x，y表示开始搜索节点的下标void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列 que.push(&#123;x, y&#125;); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记已经访问过该节点 while (!que.empty()) &#123; // 开始遍历队列中的元素 pair&lt;int, int&gt; cur = que.front(); que.pop(); // 从队列取元素 int curx = cur.first; int cury = cur.second; // 当前节点坐标 for (int i = 0; i &lt; 4; ++i) &#123; // 开始向当前节点四个方向去遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向坐标 if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexy &gt;= grid[0].size()) continue; // 坐标越界，直接跳过 if (!visited[nextx][nexty]) &#123; // 如果节点没被访问过 que.push(&#123;nextx, nexty&#125;); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列，立刻标记为已经访问过，避免重复访问 &#125; &#125; &#125;&#125; 重要细节：只要加入队列就代表已访问，需要立刻标记，而不是从队列拿出来的时候再去标记访问 取出再标记，会导致很多节点重复加入队列：","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"所有可达路径","slug":"p/leetcode/day99","date":"2024-07-31T16:00:00.000Z","updated":"2024-08-04T14:00:28.170Z","comments":true,"path":"p/leetcode/day99/","permalink":"https://krystencollins.github.io/p/leetcode/day99/","excerpt":"","text":"98. 所有可达路径题目描述：给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。 示例：输入描述 第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边 后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径 输出描述 输出所有的可达路径，路径中所有节点之间空格隔开，每条路径独占一行，存在多条路径，路径输出的顺序可任意。如果不存在任何一条路径，则输出 -1。 注意输出的序列中，最后一个节点后面没有空格！ 例如正确的答案是 1 3 5,而不是 1 3 5 ， 5后面没有空格！ 输入示例 1234565 51 33 51 22 44 5 输出示例 121 3 51 2 4 5 提示： 用例解释： 有五个节点，其中的从 1 到达 5 的路径有两个，分别是 1 -&gt; 3 -&gt; 5 和 1 -&gt; 2 -&gt; 4 -&gt; 5。 因为拥有多条路径，所以输出结果为： 1 3 51 2 4 5 或 1 2 4 51 3 5都算正确。 数据范围： 图中不存在自环 图中不存在平行边 1 &lt;&#x3D; N &lt;&#x3D; 100 1 &lt;&#x3D; M &lt;&#x3D; 500 题解：深度优先搜索邻接矩阵： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; vector&lt;vector&lt;int&gt;&gt; result; // 收集符合条件的路径vector&lt;int&gt; path; // 1节点到终点的路径 void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; graph, int x, int n) &#123; // 当前遍历的节点x到达节点n if (x == n) &#123; // 找到符合条件的一条路径 result.push_back(path); return; &#125; for (int i = 1; i &lt;= n; ++i) &#123; // 遍历节点x连接的所有节点 if (graph[x][i] == 1) &#123; // 找到x连接的节点 path.push_back(i); // 处理节点 dfs(graph, i, n); // 进入下一层递归 path.pop_back(); // 回溯，撤销本节点 &#125; &#125;&#125; int main() &#123; int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; // 节点编号从1到n vector&lt;vector&lt;int&gt;&gt; graph(n + 1, vector&lt;int&gt;(n + 1, 0)); while (m--) &#123; cin &gt;&gt; s &gt;&gt; t; // 邻接矩阵表示无向图，1表示节点s与节点t有边相连 graph[s][t] = 1; &#125; path.push_back(1); // 从节点1开始 dfs(graph, 1, n); // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt;&amp; pa : result) &#123; for (int i = 0; i &lt; pa.size() - 1; ++i) &#123; // 输出到倒数第二个节点 cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; // 输出最后一个节点，无空格 &#125; return 0;&#125; 邻接表12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; result;vector&lt;int&gt; path;void dfs(const vector&lt;list&lt;int&gt;&gt;&amp; graph, int x, int n) &#123; if (x == n) &#123; result.push_back(path); return; &#125; for (int i : graph[x]) &#123; path.push_back(i); dfs(graph, i, n); path.pop_back(); &#125;&#125;int main() &#123; int n, m, s, t; cin &gt;&gt; n &gt;&gt; m; vector&lt;list&lt;int&gt;&gt; graph(n + 1); // 邻接表 while (m--) &#123; cin &gt;&gt; s &gt;&gt; t; graph[s].push_back(t); // 邻接表：表示s -&gt; t 是连接的 &#125; path.push_back(1); dfs(graph, 1, n); // 输出结果 if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int&gt;&amp; pa : result) &#123; for (int i = 0; i &lt; pa.size() - 1; ++i) &#123; cout &lt;&lt; pa[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; &#125; return 0;&#125; leetcode题目： 797. 所有可能的路径 LCR 110. 所有可能的路径","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"深度优先搜索","slug":"p/leetcode/day99_1","date":"2024-07-31T16:00:00.000Z","updated":"2024-08-01T07:20:03.090Z","comments":true,"path":"p/leetcode/day99_1/","permalink":"https://krystencollins.github.io/p/leetcode/day99_1/","excerpt":"","text":"图论基础 图的种类：无向图、有向图 度：无向图中节点有多少条边连接就有几度；有向图：出度、入度 连通性： 无向图：连通图、连通分量 有向图：强连通图、强连通分量 图的构造：邻接矩阵、邻接表 图的遍历方式：深度优先搜索（DFS）、广度优先搜索（BFS） 深度优先搜索理论 搜索方向：认准一个方向搜，直到碰壁之后再换方向 回溯过程：换方向即撤销源路径，改为节点连接的下一个路径 回溯法代码框架： 1234567891011void backtracking (参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量即集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果; &#125;&#125; DFS代码框架： 1234567891011121314vector&lt;vector&lt;int&gt;&gt; result; // 保存符合条件的所有路径vector&lt;int&gt; path; // 起点到终点的路径void dfs(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本节点所连接的其他节点) &#123; 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"动态规划总结","slug":"p/leetcode/day98","date":"2024-07-30T16:00:00.000Z","updated":"2024-07-31T03:49:48.125Z","comments":true,"path":"p/leetcode/day98/","permalink":"https://krystencollins.github.io/p/leetcode/day98/","excerpt":"","text":"基础系列动规五部曲分别为： 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 背包问题系列 打家劫舍系列 股票系列 子序列系列","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最长回文子序列","slug":"p/leetcode/day97","date":"2024-07-29T16:00:00.000Z","updated":"2024-07-31T03:38:12.263Z","comments":true,"path":"p/leetcode/day97/","permalink":"https://krystencollins.github.io/p/leetcode/day97/","excerpt":"","text":"516. 最长回文子序列题目描述：给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例：示例 1： 123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 示例 2： 123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 提示： 1 &lt;= s.length &lt;= 1000 s 仅由小写英文字母组成 题解：动态规划1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示在[i,j]范围内的s子串（左闭右闭）的最长回文子串的长度 2. 递推公式：dp[i][j] = dp[i + 1][j - 1] + 2, 当s[i] == s[j]时，删掉头尾后的dp+2 否则：dp[i][j] = max(dp[i+1][j], dp[i][j-1])，删掉s[i]或者删掉s[j] 3. 初始化：dp[i][i] = 1，其他dp[i][j] = 0 4. 遍历顺序：行：从大到小，列：从小到大 5. 举例推导dp数组： */ int longestPalindromeSubseq(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = n - 1; i &gt;= 0; --i) &#123; dp[i][i] = 1; for (int j = i + 1; j &lt; n; ++j) &#123; if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j -1]); &#125; &#125; return dp[0][n - 1]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最长回文子串","slug":"p/leetcode/day96","date":"2024-07-28T16:00:00.000Z","updated":"2024-07-31T03:02:52.755Z","comments":true,"path":"p/leetcode/day96/","permalink":"https://krystencollins.github.io/p/leetcode/day96/","excerpt":"","text":"5. 最长回文子串题目描述：给你一个字符串 s，找到 s 中最长的 回文子串。 示例：示例 1： 123输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。 示例 2： 12输入：s = &quot;cbbd&quot;输出：&quot;bb&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 仅由数字和英文字母组成 题解：双指针1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; vector&lt;int&gt; pos(3, 0); pos[0] = INT_MIN; for (int i = 0; i &lt; s.size(); ++i) &#123; vector&lt;int&gt; tmp = extend(s, i, i); if (tmp[0] &gt; pos[0]) pos = tmp; tmp = extend(s, i, i + 1); if (tmp[0] &gt; pos[0]) pos = tmp; &#125; return s.substr(pos[1], pos[2] - pos[1] + 1); &#125; vector&lt;int&gt; extend(const string&amp; s, int i, int j) &#123; vector&lt;int&gt; tmp(3, 0); tmp[0] = INT_MIN; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) &#123; if (j - i + 1 &gt; tmp[0]) &#123; tmp[0] = j - i + 1; tmp[1] = i; tmp[2] = j; &#125; --i; ++j; &#125; return tmp; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(1) 1234567891011121314151617181920212223class Solution &#123;public: string longestPalindrome(string s) &#123; string result = &quot;&quot;; for (int i = 0; i &lt; s.size(); ++i) &#123; string str = extend(s, i, i); if (str.size() &gt; result.size()) result = str; str = extend(s, i, i + 1); if (str.size() &gt; result.size()) result = str; &#125; return result; &#125; string extend(const string&amp; s, int i, int j) &#123; string res = &quot;&quot;; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) &#123; res = s.substr(i, j - i + 1); --i; ++j; &#125; return res; &#125;&#125;; 动态规划1234567891011121314151617class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); string result = &quot;&quot;; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (s[i] == s[j] &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; if (j - i + 1 &gt; result.size()) result = s.substr(i, j - i + 1); dp[i][j] = true; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"回文子串","slug":"p/leetcode/day95","date":"2024-07-27T16:00:00.000Z","updated":"2024-07-31T02:58:20.420Z","comments":true,"path":"p/leetcode/day95/","permalink":"https://krystencollins.github.io/p/leetcode/day95/","excerpt":"","text":"647. 回文子串题目描述：给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 示例：示例 1： 123输入：s = &quot;abc&quot;输出：3解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2： 123输入：s = &quot;aaa&quot;输出：6解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 提示： 1 &lt;= s.length &lt;= 1000 s 由小写英文字母组成 题解：动态规划1234567891011121314151617181920212223242526272829303132class Solution &#123;public: /* 1. 确定dp数组以及下标含义：dp[i][j]表示[i ,j]区间范围内(左闭右闭)，的子串是否是回文子串 2. 递推公式：dp[i][j] = false, 当s[i] != s[j] 否则：若i与j相等或相差1，dp[i][j] = true i与j相差大于1，dp[i][j] = dp[i+1][j-1] 3. 初始化：dp[i][j] = false 4. 遍历顺序：行：从大到小，列：从小到大 5. 举例推导dp数组： */ int countSubstrings(string s) &#123; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); int result = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (s[i] == s[j]) &#123; if (j - i &lt;= 1) &#123; ++result; dp[i][j] = true; &#125; else if (dp[i + 1][j - 1])&#123; ++result; dp[i][j] = true; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2) 代码优化： 1234567891011121314151617class Solution &#123;public: int countSubstrings(string s) &#123; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); int result = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i; j &lt; n; ++j) &#123; if (s[i] == s[j] &amp;&amp; (j - i &lt;= 1 || dp[i + 1][j - 1])) &#123; ++result; dp[i][j] = true; &#125; &#125; &#125; return result; &#125;&#125;; 双指针123456789101112131415161718192021222324class Solution &#123;public: /* 双指针：找每个中心向两边扩散看是否为对称 */ int countSubstrings(string s) &#123; int result = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; result += extend(s, i, i); // 以i为中心 result += extend(s, i, i + 1); // 以i和i+1为中心 &#125; return result; &#125; int extend(const string&amp; s, int i, int j) &#123; int res = 0; while (i &gt;= 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] == s[j]) &#123; --i; ++j; ++res; &#125; return res; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"编辑距离","slug":"p/leetcode/day93","date":"2024-07-25T16:00:00.000Z","updated":"2024-07-29T08:27:49.303Z","comments":true,"path":"p/leetcode/day93/","permalink":"https://krystencollins.github.io/p/leetcode/day93/","excerpt":"","text":"72. 编辑距离题目描述：给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例：示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;) 题解：动态规划123456789101112131415161718192021222324252627class Solution &#123;public: /* 1. 确定dp数组以及下标含义： dp[i][j]表示以下标i-1结尾的word1和以下标j-1结尾的word2，最近编辑距离是多少 2. 递推公式：当word1[i-1] == word2[j-1], 不操作：dp[i][j] = dp[i-1][j-1] 当word1[i-1] != word2[j-1]， （1）删除word1[i-1] ：dp[i][j] = dp[i-1][j] + 1 ; (2)删除word2[j-1]: dp[i][j] = dp[i][j-1] + 1 word2添加一个元素相当于word1删除一个元素，反过来也一样 （3）word1[i-1]替换为word2[j-1],或者相反：dp[i][j] = dp[i-1][j-1] + 1 3. 初始化：dp[i][0] = i, dp[0][j] = j, dp[0][0] = 0; 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; ++i) dp[i][0] = i; for (int j = 1; j &lt;= m; ++j) dp[0][j] = j; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)); &#125; &#125; return dp[n][m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"两个字符串的删除操作","slug":"p/leetcode/day92","date":"2024-07-24T16:00:00.000Z","updated":"2024-07-29T08:06:17.980Z","comments":true,"path":"p/leetcode/day92/","permalink":"https://krystencollins.github.io/p/leetcode/day92/","excerpt":"","text":"583. 两个字符串的删除操作题目描述：给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例：示例 1： 123输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;输出: 2解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot; 示例 2: 12输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;输出：4 提示： 1 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 只包含小写英文字母 题解：动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示以下标i-1结尾的word1和以下标j-1结尾的word2结尾的word2删除后相同所需最小步数 2. 递推公式：dp[i][j] = dp[i-1][j-1],当word1[i-1] == word[j-1] 否则dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1) 3. 初始化：dp[i][0] = i, dp[0][j] = j, dp[0][0] = 0 4. 遍历顺序： 内外循环都是从前往后 5. 举例推导dp数组： */ int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; ++i) dp[i][0] = i; for (int j = 1; j &lt;= m; ++j) dp[0][j] = j; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); &#125; &#125; return dp[n][m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 另一种思路：求出两个字符串的最长公共子序列长度，除了最长公共子序列其他字符都是需要删除的！ 123456789101112131415class Solution &#123;public: int minDistance(string word1, string word2) &#123; int n = word1.size(); int m = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return n + m - dp[n][m] * 2; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"不同的子序列","slug":"p/leetcode/day91","date":"2024-07-23T16:00:00.000Z","updated":"2024-07-27T08:23:05.562Z","comments":true,"path":"p/leetcode/day91/","permalink":"https://krystencollins.github.io/p/leetcode/day91/","excerpt":"","text":"115. 不同的子序列题目描述：给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数，结果需要对 109 + 7 取模。 示例：示例 1： 1234567输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;输出：3解释：如下所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。rabbbitrabbbitrabbbit 示例 2： 123456789输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;输出：5解释：如下所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 babgbagbabgbagbabgbagbabgbagbabgbag 提示： 1 &lt;= s.length, t.length &lt;= 1000 s 和 t 由英文字母组成 题解：动态规划123456789101112131415161718192021222324252627class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示以下标为i-1结尾的t 在以下标j-1结尾的s的子序列中出现多少次 2. 递推公式：dp[i][j] = dp[i-1][j-1] + dp[i][j-1], 当t[i-1] == s[j-1] (对于t: ba, s: babgba, 前部分相当于最后一个字母已确定；后半部分为ba在babgb的子序列出现次数) 否则dp[i][j] = dp[i][j-1] 3. 初始化：dp[0][j] = 1(空串在s出现次数都为1)，dp[i][0] = 0(任何子串在空串中出现0次)，dp[0][0] = 1 4. 遍历顺序：内外循环都是从前往后 5. 举例推导dp数组： */ int numDistinct(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int j = 0; j &lt;= n; ++j) dp[0][j] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (t[i - 1] == s[j - 1]) dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % (int)(1e9+7); else dp[i][j] = dp[i][j - 1]; cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return dp[m][n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 转换维度： 12345678910111213141516class Solution &#123;public: int numDistinct(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, 0)); for (int i = 0; i &lt;= n; ++i) dp[i][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (s[i - 1] == t[j - 1]) dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % (int)(1e9+7); else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[n][m]; &#125;&#125;; 空间优化： 123456789101112131415class Solution &#123;public: int numDistinct(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;int&gt; dp(m+1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j &gt; 0; --j) &#123; // 倒序，以免覆盖dp[j-1] if (s[i - 1] == t[j - 1]) dp[j] = (dp[j - 1] + dp[j]) % (int)(1e9+7); &#125; &#125; return dp[m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"判断子序列","slug":"p/leetcode/day90","date":"2024-07-22T16:00:00.000Z","updated":"2024-07-27T08:17:44.141Z","comments":true,"path":"p/leetcode/day90/","permalink":"https://krystencollins.github.io/p/leetcode/day90/","excerpt":"","text":"392. 判断子序列题目描述：给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 示例：示例 1： 12输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;输出：true 示例 2： 12输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;输出：false 提示： 0 &lt;= s.length &lt;= 100 0 &lt;= t.length &lt;= 10^4 两个字符串都只由小写字符组成。 题解：双指针1234567891011121314151617class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int i = 0; int j = 0; while (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123; if (s[i] == t[j]) &#123; ++i; ++j; &#125; else &#123; ++j; &#125; &#125; return i == s.size(); &#125;&#125;; 时间复杂度：O(m) 空间复杂度：O(1) 动态规划123456789101112131415161718192021222324class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示以i-1下标结尾的s 是否是 以j-1下标结尾的t 的子序列 2. 递推公式：dp[i][j] = dp[i-1][j-1] 当s[i-1]==t[j-1]时,相当于看将两个字符串当前匹配字符都删除后是否匹配 否则dp[i][j] = dp[i][j-1]，看当前s是否为t删除当前字符后的子序列 3. 初始化：dp[0][j] = true（空串都是t的子序列）, dp[i][0] = false（s一定不是空串的子序列）, dp[0][0] = true 4. 遍历顺序：内外循环都是 从前往后 5. 举例推导dp数组： */ bool isSubsequence(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n+1, vector&lt;bool&gt;(m+1, true)); for (int i = 1; i &lt;= n; ++i) dp[i][0] = false; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = dp[i][j - 1]; &#125; &#125; return dp[n][m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 另一种写法，有利于空间优化 12345678910111213141516class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, true)); for (int j = 1; j &lt;= n; ++j) dp[0][j] = false; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (t[i - 1] == s[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125;; 空间优化： 123456789101112131415class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int n = s.size(); int m = t.size(); vector&lt;bool&gt; dp(n+1, false); dp[0] = true; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = n; j &gt; 0; --j) &#123; if (t[i - 1] == s[j - 1]) dp[j] = dp[j - 1]; &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n) 792. 匹配子序列的单词数题目描述：给定字符串 s 和字符串数组 words, 返回 words[i] 中是s的子序列的单词个数 。 字符串的 子序列 是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是none)，而不改变其余字符的相对顺序。 例如， “ace” 是 “abcde” 的子序列。 示例：示例 1: 123输入: s = &quot;abcde&quot;, words = [&quot;a&quot;,&quot;bb&quot;,&quot;acd&quot;,&quot;ace&quot;]输出: 3解释: 有三个是 s 的子序列的单词: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;。 Example 2: 12输入: s = &quot;dsahjpjauf&quot;, words = [&quot;ahjpjau&quot;,&quot;ja&quot;,&quot;ahbwzgqnuk&quot;,&quot;tnmlanowax&quot;]输出: 2 提示: 1 &lt;= s.length &lt;= 5 * 104 1 &lt;= words.length &lt;= 5000 1 &lt;= words[i].length &lt;= 50 words[i]和 s 都只由小写字母组成。 题解：双指针&#x3D;&#x3D;超出时间限制&#x3D;&#x3D; 12345678910111213141516class Solution &#123;public: int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123; int result = 0; for (int i = 0; i &lt; words.size(); ++i) &#123; int j = 0, k = 0; string w = words[i]; while (j &lt; s.size() &amp;&amp; k &lt; w.size()) &#123; if (s[j] == w[k]) ++k; ++j; &#125; if (k == w.size()) ++result; &#125; return result; &#125;&#125;; 时间复杂度：O(n * m + sum(size_i))，其中 n 为字符串 s 的长度，m 是字符串数组 words 的大小，size**i 为字符串数组 words 中索引为 i 的字符串长度。 空间复杂度：O(1) 分桶 12345678910111213141516171819202122class Solution &#123;public: int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;queue&lt;string&gt;&gt; bucket(26); // 分桶 for (int i = 0; i &lt; words.size(); ++i) &#123; bucket[words[i][0] - &#x27;a&#x27;].emplace(words[i]); // 这里emplace相当于push &#125; int result = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; // 取当前字符对应的 桶 queue&lt;string&gt;&amp; q = bucket[s[i] - &#x27;a&#x27;]; // 必须声明为引用！！后续q会发生改变 for (int k = q.size(); k &gt; 0; --k) &#123; // 数量从大到小！！因为循环过程中q长度发生变化 string t = q.front(); q.pop(); if (t.size() == 1) ++result; else bucket[t[1] - &#x27;a&#x27;].emplace(t.substr(1)); &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n + sum(words[i].size())) 空间复杂度：O(m) 空间优化：每个桶可以只存储单词的下标 i 以及该单词当前匹配到的位置 j，这样可以节省空间。 123456789101112131415161718192021class Solution &#123;public: int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;queue&lt;pair&lt;int, int&gt;&gt;&gt; bucket(26); // 分桶 for (int i = 0; i&lt; words.size(); ++i) &#123; bucket[words[i][0] - &#x27;a&#x27;].emplace(i , 0); &#125; int result = 0; for (int c = 0; c &lt; s.size(); ++c) &#123; queue&lt;pair&lt;int, int&gt;&gt;&amp; q = bucket[s[c] - &#x27;a&#x27;]; for (int k = q.size(); k &gt; 0; --k) &#123; auto [i, j] = q.front(); // pair的分解类型 q.pop(); if (++j == words[i].size()) ++result; else bucket[words[i][j] - &#x27;a&#x27;].emplace(i, j); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最长公共子序列","slug":"p/leetcode/day89","date":"2024-07-21T16:00:00.000Z","updated":"2024-07-25T04:34:13.096Z","comments":true,"path":"p/leetcode/day89/","permalink":"https://krystencollins.github.io/p/leetcode/day89/","excerpt":"","text":"1143. 最长公共子序列题目描述：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例：示例 1： 123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。 示例 2： 123输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。 示例 3： 123输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0 。 提示： 1 &lt;= text1.length, text2.length &lt;= 1000 text1 和 text2 仅由小写英文字符组成。 题解：动态规划1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示以i-1下标结尾的text1和j-1结尾的text2最长公共子序列 2. 递推公式：dp[i][j] = dp[i-1][j-1] + 1, 当text1[i-1] == text2[j-1] 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1]) 3. 初始化：dp[i][0] = 0, dp[0][j] = 0 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int longestCommonSubsequence(string text1, string text2) &#123; int n = text1.size(); int m = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (text1[i - 1] == text2[j -1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[n][m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 无法空间优化！！！ 1035. 不相交的线题目描述：在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例：示例 1： 1234输入：nums1 = [1,4,2], nums2 = [1,2,4]输出：2解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 12输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]输出：3 示例 3： 12输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]输出：2 提示： 1 &lt;= nums1.length, nums2.length &lt;= 500 1 &lt;= nums1[i], nums2[j] &lt;= 2000 题解：动态规划与最长公共子序列类似！！ 12345678910111213141516class Solution &#123;public: int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n = nums1.size(); int m = nums2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (nums1[i - 1] == nums2[j -1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return dp[n][m]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最长重复子数组","slug":"p/leetcode/day88","date":"2024-07-20T16:00:00.000Z","updated":"2024-07-25T04:29:52.784Z","comments":true,"path":"p/leetcode/day88/","permalink":"https://krystencollins.github.io/p/leetcode/day88/","excerpt":"","text":"718. 最长重复子数组题目描述：给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例：示例 1： 123输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]输出：3解释：长度最长的公共子数组是 [3,2,1] 。 示例 2： 12输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]输出：5 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 100 题解：动态规划1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示以i-1下标结尾的nums1和j-1下标结尾的nums2最长重复子数组长度 2. 递推公式：dp[i][j] = dp[i-1][j-1] + 1, 当nums1[i-1] == nums2[j-1] 3. 初始化：dp[i][0] = 0, dp[0][j] = 0 4. 遍历顺序：内外循环都 从前往后， 5. 举例推导dp数组： */ int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0)); int result = 0; for (int i = 1; i &lt;= nums1.size(); ++i) &#123; for (int j = 1; j &lt;= nums2.size(); ++j) &#123; if (nums1[i - 1] == nums2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; if (dp[i][j] &gt; result) result = dp[i][j]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 空间优化：观察递推公式，下一个值只与对角线上的值有关，可优化：内层循环倒序！！ 123456789101112131415class Solution &#123;public: int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; dp(nums2.size()+1, 0); int result = 0; for (int i = 1; i &lt;= nums1.size(); ++i) &#123; for (int j = nums2.size(); j &gt;= 1; --j) &#123; if (nums1[i - 1] == nums2[j - 1]) dp[j] = dp[j - 1] + 1; else dp[j] = 0; if (dp[j] &gt; result) result = dp[j]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最长递增子序列","slug":"p/leetcode/day87","date":"2024-07-19T16:00:00.000Z","updated":"2024-07-22T11:29:57.403Z","comments":true,"path":"p/leetcode/day87/","permalink":"https://krystencollins.github.io/p/leetcode/day87/","excerpt":"","text":"300. 最长递增子序列题目描述：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例：示例 1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例 3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 -104 &lt;= nums[i] &lt;= 104 进阶： 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 题解：动态规划123456789101112131415161718192021222324class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示以nums[i]结尾的最长递增子序列长度 2. 递推公式：若nums[i] &gt; nums[j], 则dp[i] = max(dp[i], dp[j] + 1)，j: 0~i-1 3. dp数组初始化：dp[i] = 1 4. 遍历顺序：从前往后 5. dp数组举例推导： */ int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n, 1); int result = 1; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; result = max(result, dp[i]); &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 二分法??? 674. 最长连续递增序列题目描述：给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例：示例 1： 1234输入：nums = [1,3,5,4,7]输出：3解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123输入：nums = [2,2,2,2,2]输出：1解释：最长连续递增序列是 [2], 长度为1。 提示： 1 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 题解：动态规划12345678910111213141516171819class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示以nums[i]结尾的最长连续递增序列长度 2. 递推公式：若nums[i] &gt; nums[i-1], 则dp[i] = dp[i - 1] + 1 否则为 1 3. dp数组初始化：dp[i] = 1 4. 遍历顺序：从前往后 5.举例推导dp数组： */ int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int result = 1; vector&lt;int&gt; dp(nums.size(), 1); for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] &gt; nums[i - 1]) dp[i] = dp[i - 1] + 1; result = max(result, dp[i]); &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 贪心12345678910111213class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int result = 1; int count = 1; for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] &gt; nums[i - 1]) ++count; else count = 1; result = max(result, count); &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"买卖股票的最佳时机含冷冻期","slug":"p/leetcode/day86","date":"2024-07-18T16:00:00.000Z","updated":"2024-07-23T03:16:22.351Z","comments":true,"path":"p/leetcode/day86/","permalink":"https://krystencollins.github.io/p/leetcode/day86/","excerpt":"","text":"309. 买卖股票的最佳时机含冷冻期题目描述：给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例：示例 1: 123输入: prices = [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2: 12输入: prices = [1]输出: 0 提示： 1 &lt;= prices.length &lt;= 5000 0 &lt;= prices[i] &lt;= 1000 题解：动态规划 状态一：持有股票（今天买入 或 之前买入但是一直没操作） 不持有股票 状态二：保持卖出股票（前两天就卖出，度过了一天冷冻期（今天为第三天） 或 前一天卖出，一直没操作） 状态三：今天卖出 状态四：今天为冷冻期，只有一天 冷冻期前一天只能是“今天卖出”状态 递推公式： 状态一：dp[i][0] = max(dp[i-1][3] - prices[i], dp[i-1][1] - prices[i], dp[i-1][0]) 今天买入：前一天为冷冻期 或 前一天保持卖出状态； 之前买入 即前一天持有 状态二：dp[i][1] = max(dp[i-1][3], dp[i-1][1]) 保持卖出： 前一天为冷冻期 后者 前一天就是状态二 状态三：dp[i][2] = dp[i-1][0] + prices[i]，前一天持有股票才能卖出 状态四：dp[i][3] = dp[i-1][2] dp数组初始化： 12345dp[0][0] = -prices[0]; // 第0天买入dp[0][1] = 0;dp[0][2] = 0; // 第0天买入卖出dp[0][3] = 0; 整体代码： 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(4, 0)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; ++i) &#123; dp[i][0] = max(dp[i-1][0], max(dp[i-1][3] - prices[3], dp[i-1][1] - prices[i])); dp[i][1] = max(dp[i-1][1], dp[i-1][3]); dp[i][2] = dp[i-1][0] + prices[i]; dp[i][3] = dp[i-1][2]; &#125; return max(dp[n-1][3], max(dp[n-1][2], dp[n-1][1])); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(4, 0)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; ++i) &#123; dp[i % 2][0] = max(dp[(i-1) % 2][0], max(dp[(i-1) % 2][3] - prices[i], dp[(i-1) % 2][1] - prices[i])); dp[i % 2][1] = max(dp[(i-1) % 2][1], dp[(i-1) % 2][3]); dp[i % 2][2] = dp[(i - 1) % 2][0] + prices[i]; dp[i % 2][3] = dp[(i - 1) % 2][2]; &#125; return max(dp[(n-1) % 2][1], max(dp[(n-1) % 2][2], dp[(n-1) % 2][3])); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 714. 买卖股票的最佳时机含手续费题目描述：给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例：示例 1： 12345678输入：prices = [1, 3, 2, 8, 4, 9], fee = 2输出：8解释：能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 12输入：prices = [1,3,7,5,10,3], fee = 3输出：6 提示： 1 &lt;= prices.length &lt;= 5 * 104 1 &lt;= prices[i] &lt; 5 * 104 0 &lt;= fee &lt; 5 * 104 题解：动态规划123456789101112131415161718192021class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][0]第i天持有股票所得最大现金，dp[i][1]第i天不持有股票所得最大现金 2. 递推公式：dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]) 第i-1天就持有 或者 第i天买入 dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee) 前一天就不持有 或者 今天卖出，需要手续费 3. dp数组初始化：dp[0][0] = -prices[0]; dp[0][1] = 0; 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; // 持股票 for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee); &#125; return max(dp[n - 1][0], dp[n - 1][1]); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int first = -prices[0]; int second = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; first = max(first, second - prices[i]); second = max(second, first + prices[i] - fee); &#125; return second; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"乘积最大子数组","slug":"p/leetcode/day85","date":"2024-07-11T16:00:00.000Z","updated":"2024-07-19T05:06:44.779Z","comments":true,"path":"p/leetcode/day85/","permalink":"https://krystencollins.github.io/p/leetcode/day85/","excerpt":"","text":"152. 乘积最大子数组题目描述：给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 示例：示例 1: 123输入: nums = [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: nums = [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示: 1 &lt;= nums.length &lt;= 2 * 104 -10 &lt;= nums[i] &lt;= 10 nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数 题解：动态规划","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"打家劫舍","slug":"p/leetcode/day84","date":"2024-07-10T16:00:00.000Z","updated":"2024-07-18T03:18:19.752Z","comments":true,"path":"p/leetcode/day84/","permalink":"https://krystencollins.github.io/p/leetcode/day84/","excerpt":"","text":"198. 打家劫舍题目描述：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例：示例 1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 题解：动态规划1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示 考虑 0~i号房间可以偷窃的最高金额 2. 递推公式：dp[i] = max(dp[i-1], dp[i-2] + nums[i])，当前房间偷窃或不偷窃 偷窃第i房间：dp[i-2]+nums[i]，第i-1房间一定不考虑 不偷第i房间：dp[i-1]，考虑i-1房间，只是考虑，并不是一定要偷i-1房间 3. dp数组初始化：dp[0] = nums[0], dp[1] = max(dp[0], nums[1]), 其余为0 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 1) return nums[0]; vector&lt;int&gt; dp(n, 0); dp[0] = nums[0]; dp[1] = max(dp[0], nums[1]); for (int i = 2; i &lt; n; ++i) &#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[n - 1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化：到当前房间为止可偷窃最高金额只与前两个状态有关 1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示 考虑 0~i号房间可以偷窃的最高金额 2. 递推公式：dp[i] = max(dp[i-1], dp[i-2] + nums[i])，当前房间偷窃或不偷窃 偷窃第i房间：dp[i-2]+nums[i]，第i-1房间一定不考虑 不偷第i房间：dp[i-1]，考虑i-1房间，只是考虑，并不是一定要偷i-1房间 3. dp数组初始化：dp[0] = nums[0], dp[1] = max(dp[0], nums[1]), 其余为0 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 1) return nums[0]; int first = nums[0]; int second = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size(); ++i) &#123; int temp = max(second, first + nums[i]); first = second; second = temp; &#125; return second; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 213. 打家劫舍 II题目描述：你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例：示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 1234输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 12输入：nums = [1,2,3]输出：3 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 1000 题解：动态规划由于 House[1] 和 House[n] 相邻，因此不能一起抢劫。因此，问题变成抢劫 House[1]-House[n-1] 或 House[2]-House[n]，具体取决于哪个选择提供更多的钱。 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 1) return nums[0]; int result1 = robRange(nums, 0, n - 2); int result2 = robRange(nums, 1, n - 1); return max(result1, result2); &#125; int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123; if (start == end) return nums[start]; int n = end - start + 1; vector&lt;int&gt; dp(n, 0); dp[0] = nums[start]; dp[1] = max(nums[start], nums[start + 1]); for (int i = 2; i &lt; n; ++i) &#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[start + i]); &#125; return dp[n - 1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 1) return nums[0]; int result1 = robRange(nums, 0, n - 2); int result2 = robRange(nums, 1, n - 1); return max(result1, result2); &#125; int robRange(vector&lt;int&gt;&amp; nums, int start, int end) &#123; if (start == end) return nums[start]; int first = nums[start]; int second = max(nums[start], nums[start + 1]); for (int i = 2; i &lt; end - start + 1; ++i) &#123; int temp = max(second, first + nums[start + i]); first = second; second = temp; &#125; return second; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 337. 打家劫舍 III题目描述：小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例：示例 1: 123输入: root = [3,2,3,null,3,null,1]输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2: 123输入: root = [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 提示： 树的节点数在 [1, 104] 范围内 0 &lt;= Node.val &lt;= 104 题解：后序遍历深度优先：后序遍历可以通过递归函数返回值来做下一步打算 当前节点：1）抢，则两个孩子节点不能动 ​ 2）不抢，则 考虑抢左右孩子 1234567891011121314class Solution &#123;public: int rob(TreeNode* root) &#123; if (root == nullptr) return 0; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return root-&gt;val; // 偷父节点 int val1 = root-&gt;val; if (root-&gt;left) val1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); // 跳过左孩子不偷，考虑左孩子的孩子 if (root-&gt;right) val1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 跳过右孩子不偷，考虑右孩子的孩子 // 不偷父节点 int val2 = rob(root-&gt;left) + rob(root-&gt;right); // 考虑偷左右孩子 return max(val1, val2); &#125;&#125;; 超出时间限制。很多重复计算，计算当前节点的四个孙子（左右孩子的孩子）为头节点的子树的情况，又计算当前节点左右孩子为头节点的子树情况，计算左右孩子的时候其实又把孙子计算了一遍！ 后序遍历+记忆化搜索用map把计算计算的结果保存下来，若计算过孙子直接取结果。 123456789101112131415161718class Solution &#123;public: unordered_map&lt;TreeNode*, int&gt; umap; int rob(TreeNode* root) &#123; if (root == nullptr) return 0; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) return root-&gt;val; if (umap[root]) return umap[root]; // 如果umap已经有记录，表示已经以该节点为子树计算过，直接返回 // 偷父节点 int val1 = root-&gt;val; if (root-&gt;left) val1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); // 跳过左孩子不偷，考虑左孩子的孩子 if (root-&gt;right) val1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 跳过右孩子不偷，考虑右孩子的孩子 // 不偷父节点 int val2 = rob(root-&gt;left) + rob(root-&gt;right); // 考虑偷左右孩子 umap[root] = max(val1, val2); // 记录到umap中 return max(val1, val2); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(log n) 动态规划，树形DP 12345678910111213141516171819class Solution &#123;public: // 长度为2的数组：0：不偷，1：偷 vector&lt;int&gt; robTree(TreeNode* node) &#123; if (node == nullptr) return &#123;0, 0&#125;; vector&lt;int&gt; left = robTree(node-&gt;left); vector&lt;int&gt; right = robTree(node-&gt;right); // 偷当前节点，左右孩子一定不偷 int val1 = node-&gt;val + left[0] + right[0]; // 不偷当前节点，可以 考虑 偷左右节点，取决于偷或不偷较大值的情况 int val2 = max(left[0], left[1]) + max(right[0], right[1]); return &#123;val2, val1&#125;; &#125; int rob(TreeNode* root) &#123; vector&lt;int&gt; result = robTree(root); return max(result[0], result[1]); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(log n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"多重背包","slug":"p/leetcode/day83","date":"2024-07-09T16:00:00.000Z","updated":"2024-07-11T02:34:21.720Z","comments":true,"path":"p/leetcode/day83/","permalink":"https://krystencollins.github.io/p/leetcode/day83/","excerpt":"","text":"多重背包有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 例如： 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况毫无区别：这就转成了一个01背包问题了，且每个物品只用一次。 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 携带矿石资源题目描述：你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。 示例：输入描述 输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 接下来的三行，每行包含 N 个正整数。具体如下： 第二行包含 N 个整数，表示 N 种矿石的重量。 第三行包含 N 个整数，表示 N 种矿石的价格。 第四行包含 N 个整数，表示 N 种矿石的可用数量上限。 输出描述 输出一个整数，代表获取的最大价值。 输入示例 123410 31 3 415 20 302 3 2 输出示例 190 提示：数据范围：1 &lt;&#x3D; C &lt;&#x3D; 10000;1 &lt;&#x3D; N &lt;&#x3D; 10000;1 &lt;&#x3D; w[i], v[i], k[i] &lt;&#x3D; 10000; 题解：动态规划方法一：低效，超时 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main() &#123; int bagweight, n; cin &gt;&gt; bagweight &gt;&gt; n; vector&lt;int&gt; weight(n, 0); vector&lt;int&gt; value(n, 0); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; weight[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; value[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; nums[i]; for (int i = 0; i &lt; n; ++i) &#123; while (nums[i] &gt; 1) &#123; // 物品数量不是1的，都展开 weight.push_back(weight[i]); value.push_back(value[i]); --nums[i]; &#125; &#125; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; weight.size(); ++i) &#123; // 遍历物品，注意此时物品数量不是n for (int j = bagweight; j &gt;= weight[i]; --j) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[bagweight] &lt;&lt; endl;&#125; 方法二：增加遍历每个物品数量 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int bagweight, n; cin &gt;&gt; bagweight &gt;&gt; n; vector&lt;int&gt; weight(n, 0); vector&lt;int&gt; value(n, 0); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; weight[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; value[i]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; nums[i]; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; n; ++i) &#123; // 遍历物品 for (int j = bagweight; j &gt;= weight[i]; --j) &#123; // 遍历背包容量 // 以上为01背包，再加一个遍历个数为多重背包 for (int k = 1; k &lt;= nums[i] &amp;&amp; j - k * weight[i] &gt;= 0; ++k) &#123; // 遍历个数 dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]); &#125; &#125; &#125; cout &lt;&lt; dp[bagweight] &lt;&lt; endl;&#125; 时间复杂度：O(n * m * k) 空间复杂度：O(n * m)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"背包问题总结","slug":"p/leetcode/day83_1","date":"2024-07-09T16:00:00.000Z","updated":"2024-07-18T03:01:32.442Z","comments":true,"path":"p/leetcode/day83_1/","permalink":"https://krystencollins.github.io/p/leetcode/day83_1/","excerpt":"","text":"背包九讲（简略版） 递推公式 能否装满（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) 416. 分割等和子集 1049. 最后一块石头的重量 II 装满背包有多少种方法：dp[j] += dp[j - nums[i]] 494. 目标和 518. 零钱兑换 II 377. 组合总和 Ⅳ 57. 爬楼梯(进阶版) 背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 474. 一和零 装满背包所有物品的最小个数：dp[j]= min(dp[j], dp[j - coins[i]]) 322. 零钱兑换 279. 完全平方数 遍历顺序 01背包 二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环从小到大遍历 一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环从大到小遍历 完全背包 纯完全背包：一维dp数组先遍历物品还是先遍历背包都可以，且第二成for循环从小到大遍历 其他完全背包：组合类问题 先遍历物品再遍历背包 ​ 排列类问题 先遍历背包再遍历物品 ​ 最小数 遍历顺序无所谓 组合类：518. 零钱兑换 II 排列类：377. 组合总和 Ⅳ、57. 爬楼梯(进阶版) 最小数：322. 零钱兑换、279. 完全平方数","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"分割字符串II","slug":"p/leetcode/day82","date":"2024-07-08T16:00:00.000Z","updated":"2024-07-10T08:19:53.607Z","comments":true,"path":"p/leetcode/day82/","permalink":"https://krystencollins.github.io/p/leetcode/day82/","excerpt":"","text":"132. 分割回文串 II题目描述：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。 返回符合要求的 最少分割次数 。 示例：示例 1： 123输入：s = &quot;aab&quot;输出：1解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。 示例 2： 12输入：s = &quot;a&quot;输出：0 示例 3： 12输入：s = &quot;ab&quot;输出：1 提示： 1 &lt;= s.length &lt;= 2000 s 仅由小写英文字母组成 题解：回溯(超出时间限制) 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int result = INT_MAX; vector&lt;string&gt; path; bool isPalindrome(string subStr) &#123; int size = subStr.size(); for (int i = 0, j = size - 1; i &lt; size / 2; ++i, --j) &#123; if (subStr[i] != subStr[j]) return false; &#125; return true; &#125; void backtracking(string s, int startIdx) &#123; if (startIdx == s.size()) &#123; result = path.size() - 1 &lt; result ? path.size() - 1 : result; return; &#125; // startIdx记录每个节点集合开始遍历的下标，n记录子串长度， for (int i = startIdx, n = 1; i &lt; s.size(); ++i, ++n) &#123; string subStr = s.substr(startIdx, n); // 横向：每次从startIdx开始取n个字符 if (!isPalindrome(subStr)) continue; // 遇到子串为 非回文串，必须continue，后续子串可能构成回文 path.push_back(subStr); // 处理 backtracking(s, i + 1); // 递归 path.pop_back(); // 回溯 &#125; &#125; int minCut(string s) &#123; backtracking(s, 0); return result; &#125;&#125;; 回溯+动态规划（超出时间限制） 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int result = INT_MAX; vector&lt;string&gt; path; // 放已经回文的子串 vector&lt;vector&lt;bool&gt;&gt; isPalindrome; // 放事先计算好的是否回文子串的结果 void backtracking (const string&amp; s, int startIdx) &#123; if (startIdx == s.size()) &#123; // 如果起始位置为s的大小，说明找到了一组分割方案 result = path.size() - 1 &lt; result ? path.size() - 1 : result; return; &#125; for (int i = startIdx; i &lt; s.size(); ++i) &#123; if (!isPalindrome[startIdx][i]) continue; // 不是回文子串，跳过 string str = s.substr(startIdx, i - startIdx + 1); path.push_back(str); backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯 &#125; &#125; void computePalindrome (const string&amp; s) &#123; // isPalindrome[i][j] 表示s[i:j](包括双边)是否是回文子串 isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false)); // 根据字符串s，刷新布尔矩阵的大小 for (int i = s.size(); i&gt;= 0; --i) &#123; // 需要倒序计算，保证在i行时，i+1行已经计算好了 for (int j = i; j &lt; s.size(); ++j) &#123; if (j == i) &#123;isPalindrome[i][j] = true;&#125; // 单个字符一定是回文串 else if (j - i == 1) &#123;isPalindrome[i][j] = (s[i] == s[j]);&#125; // 子串长度为2，判断两个字符是否相同 else &#123;isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125; // 子串长度大于2，只需要判断首尾字符是否相同 与 剩下的子串是否为回文串 &#125; &#125; &#125; int minCut(string s) &#123; computePalindrome(s); backtracking(s, 0); return result; &#125;&#125;; 两次动态规划1234567891011121314151617181920212223242526272829class Solution &#123;public: int minCut(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, true)); for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; g[i][j] = (s[i] == s[j]) &amp;&amp; g[i + 1][j - 1]; &#125; &#125; vector&lt;int&gt; f(n, INT_MAX); for (int i = 0; i &lt; n; ++i) &#123; if (g[0][i]) &#123; f[i] = 0; &#125; else &#123; for (int j = 0; j &lt; i; ++j) &#123; if (g[j + 1][i]) &#123; f[i] = min(f[i], f[j] + 1); &#125; &#125; &#125; &#125; return f[n - 1]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"单词拆分","slug":"p/leetcode/day81","date":"2024-07-07T16:00:00.000Z","updated":"2024-07-10T16:53:43.173Z","comments":true,"path":"p/leetcode/day81/","permalink":"https://krystencollins.github.io/p/leetcode/day81/","excerpt":"","text":"139. 单词拆分题目描述：给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例：示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 提示： 1 &lt;= s.length &lt;= 300 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 20 s 和 wordDict[i] 仅由小写英文字母组成 wordDict 中的所有字符串 互不相同 题解：回溯(超出时间限制) 12345678910111213141516171819202122class Solution &#123;public: bool backtracking(const string&amp; s, const unordered_set&lt;string&gt;&amp; wordSet, int startIdx) &#123; if (startIdx == s.size()) &#123; // 起始分割位置为s大小，分割结束，返回true return true; &#125; for (int i = startIdx; i &lt; s.size(); ++i) &#123; string word = s.substr(startIdx, i - startIdx + 1); // s[startIdx:i]子串在字典中，且s[i+1:]子串也在子串中，返回true；否则跳过，继续判断以下一个i结尾的子串 if (wordSet.find(word) != wordSet.end() &amp;&amp; backtracking(s, wordSet, i + 1)) &#123; return true; &#125; &#125; return false; &#125; bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); return backtracking(s, wordSet, 0); &#125;&#125;; 时间复杂度：O(2 ^ n) 空间复杂度：O(n) 回溯+记忆化搜索使用memory数组保存每次计算的 以startIdx起始的计算结果，如果memory[startIdx]里已经被赋值了，直接用memory[startIdx]的结果 1234567891011121314151617181920212223242526class Solution &#123;public: bool backtracking(const string&amp; s, const unordered_set&lt;string&gt;&amp; wordSet, vector&lt;bool&gt;&amp; memory, int startIdx) &#123; if (startIdx == s.size()) &#123; // 起始分割位置为s大小，分割结束，返回true return true; &#125; // 如果memory[startIdx]不是初始值了，直接使用memory[startIdx]的结果 if (!memory[startIdx]) return memory[startIdx]; for (int i = startIdx; i &lt; s.size(); ++i) &#123; string word = s.substr(startIdx, i - startIdx + 1); // s[startIdx:i]子串在字典中，且s[i+1:]子串也在子串中，返回true；否则跳过，继续判断以下一个i结尾的子串 if (wordSet.find(word) != wordSet.end() &amp;&amp; backtracking(s, wordSet, memory, i + 1)) &#123; return true; &#125; &#125; memory[startIdx] = false; // 记录以startIdx开始的子串是不可以被拆分的 return false; &#125; bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; memory(s.size(), true); return backtracking(s, wordSet, memory, 0); &#125;&#125;; 时间复杂度：O(2 ^ n) 空间复杂度：O(n) 动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 完全背包：字符串s长度为背包容量，单词为物品，单词能否组成字符串，可重复使用单词 1. dp数组以及下标含义：dp[j]=true表示长度为i的字符串可以拆分为一个或多个在字典中出现的单词 2. 递推公式：当dp[i]=true 且 [i,j]这个区间的子串出现在字典里，则dp[j]=true, (i&lt;j) 3. dp数组初始化：dp[0]=true，其他为false。指定字符串为空时，出现在字典里。题目给定非空字符 4. 遍历顺序：先背包再物品，正序！。完全背包 且 排列类问题 5. 举例推导dp数组： */ bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool&gt; dp(s.size() + 1, false); dp[0] = true; for (int j = 1; j &lt;= s.size(); ++j) &#123; // 遍历背包 for (int i = 0; i &lt; j; ++i) &#123; // 遍历物品 string word = s.substr(i, j - i); // substr(起始位置，截取的个数) if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[i]) &#123; dp[j] = true; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; 时间复杂度：O(n ^ 3) 空间复杂度：O(n) 140. 单词拆分 II题目描述：给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。 注意：词典中的同一个单词可能在分段中被重复使用多次。 示例：示例 1： 12输入:s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]输出:[&quot;cats and dog&quot;,&quot;cat sand dog&quot;] 示例 2： 123输入:s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]输出:[&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]解释: 注意你可以重复使用字典中的单词。 示例 3： 12输入:s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]输出:[] 提示： 1 &lt;= s.length &lt;= 20 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 10 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中所有字符串都 不同 题解：回溯12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; result; string path; void backtracking(const string&amp; s, const unordered_set&lt;string&gt;&amp; wordSet, int startIdx) &#123; if (startIdx == s.size()) &#123; // 起始分割位置为s大小，分割结束，返回true string str = path.substr(0, path.size() - 1); // 保存的结果去掉最后一个空格 result.push_back(str); return; &#125; for (int i = startIdx; i &lt; s.size(); ++i) &#123; string word = s.substr(startIdx, i - startIdx + 1); if (wordSet.find(word) != wordSet.end()) &#123; // word子串在字典中 path += word + &quot; &quot;; // 增加空格 backtracking(s, wordSet, i + 1); // 递归从i+1起始分割 path = path.substr(0, path.size() - word.size() - 1); // 回溯 &#125; &#125; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); backtracking(s, wordSet, 0); return result; &#125;&#125;; 记忆化搜索 12345678910111213141516171819202122232425262728293031class Solution &#123;public: unordered_map&lt;int, vector&lt;string&gt;&gt; ans; // 下标i，从下标i开始的部分组成的句子列表 unordered_set&lt;string&gt; wordSet; // 单词字典哈希表 void backtracking(const string&amp; s, int startIdx) &#123; // 当前起始下标已经访问过，直接跳过 if (ans.count(startIdx)) return; // 起始下标为s长度，结果记录为空并返回 if (startIdx == s.size()) &#123; ans[startIdx] = &#123;&quot;&quot;&#125;; return; &#125; ans[startIdx] = &#123;&#125;; // 初始化句子列表 for (int i = startIdx; i &lt; s.size(); ++i) &#123; string word = s.substr(startIdx, i - startIdx + 1); if (wordSet.count(word)) &#123; backtracking(s, i + 1); for (const string&amp; succ : ans[i + 1]) &#123; ans[startIdx].push_back(succ.empty() ? word : word + &quot; &quot; + succ); &#125; &#125; &#125; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; wordSet = unordered_set(wordDict.begin(), wordDict.end()); backtracking(s, 0); return ans[0]; &#125;&#125;; 时间复杂度：O(n * 2 ^ n) 空间复杂度：O(n * 2 ^ n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"完全平方数","slug":"p/leetcode/day80","date":"2024-07-05T16:00:00.000Z","updated":"2024-07-08T06:11:27.158Z","comments":true,"path":"p/leetcode/day80/","permalink":"https://krystencollins.github.io/p/leetcode/day80/","excerpt":"","text":"279. 完全平方数题目描述：给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例：示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 104 题解：动态规划先物品再背包容量 123456789101112131415161718192021class Solution &#123;public: /* 完全背包问题：背包容量为整数n，物品为小于n的完全平方数，价值为完全平方数个数 1. dp数组以及下标含义：dp[j]表示装满容量为j的背包所需的最少完全平方数 2. 递推公式：dp[j] = min(dp[j], dp[j - i*i] + 1)，对于当前物品，放或不放 3. dp数组初始化：dp[0] = 0，其余为INT_MAX 4. 遍历顺序：先物品再背包容量，正序！！ 5. 举例推导dp数组： */ int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int i = 1; i * i &lt;= n; ++i) &#123; // 遍历物品，能组成n的最大完全平方数不大于根号n for (int j = i * i; j &lt;= n; ++j) &#123; // 遍历背包 dp[j] = min(dp[j], dp[j - i * i] + 1); &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n * √n) 空间复杂度：O(n) 先背包容量再物品 123456789101112131415161718192021class Solution &#123;public: /* 完全背包问题：背包容量为整数n，物品为小于n的完全平方数，价值为完全平方数个数 1. dp数组以及下标含义：dp[j]表示装满容量为j的背包所需的最少完全平方数 2. 递推公式：dp[j] = min(dp[j], dp[j - i*i] + 1)，对于当前物品，放或不放 3. dp数组初始化：dp[0] = 0，其余为INT_MAX 4. 遍历顺序：先背包容量再物品，正序！！ 5. 举例推导dp数组： */ int numSquares(int n) &#123; vector&lt;int&gt; dp(n + 1, INT_MAX); dp[0] = 0; for (int j = 0; j &lt;= n; ++j) &#123; // 遍历背包容量 for (int i = 1; i * i &lt;= j; ++i) &#123; // 遍历物品，从1到根号j ！！ dp[j] = min(dp[j], dp[j - i * i] + 1); &#125; &#125; return dp[n]; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"零钱兑换","slug":"p/leetcode/day79","date":"2024-07-04T16:00:00.000Z","updated":"2024-07-08T06:08:05.975Z","comments":true,"path":"p/leetcode/day79/","permalink":"https://krystencollins.github.io/p/leetcode/day79/","excerpt":"","text":"322. 零钱兑换题目描述：给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例：示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 231 - 1 0 &lt;= amount &lt;= 104 题解;动态规划先遍历物品再遍历背包容量 12345678910111213141516171819202122232425class Solution &#123;public: /* 完全背包问题：背包容量为总金额，物品为硬币，价值为硬币面额 求最少物品数，不强调组合还是排列 1. dp数组以及下标含义：dp[j]表示装满容量为j的背包所需的最少物品数 2. 递推公式：dp[j] = min(dp[j], dp[j - coins[i]] + 1)，对于当前coins[i]放或不放进背包 3. dp数组初始化：dp[0] = 0，其他初始化为INT_MAX！！！ 4. 遍历顺序：先物品在背包容量，正序！！ 5. 举例推导dp数组： */ int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int i = 0; i &lt; coins.size(); ++i) &#123; // 遍历物品 for (int j = coins[i]; j &lt;= amount; ++j) &#123; // 遍历背包容量 if (dp[j - coins[i]] != INT_MAX) // 当dp[j-coins[i]]为初始值时跳过 dp[j] = min(dp[j], dp[j - coins[i]] + 1); &#125; &#125; return dp[amount] == INT_MAX ? -1 : dp[amount]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(m) 先遍历背包再遍历物品 1234567891011121314151617181920class Solution &#123;public: /* 完全背包问题：背包容量为总金额，物品为硬币，价值为硬币面额 求最少物品数，不强调组合还是排列 */ int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, INT_MAX); dp[0] = 0; for (int j = 1; j &lt;= amount; ++j) &#123; // 遍历背包容量 for (int i = 0; i &lt; coins.size(); ++i) &#123; // 遍历物品 if (j &gt;= coins[i] &amp;&amp; dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1); &#125; &#125; return dp[amount] == INT_MAX ? -1 : dp[amount]; &#125;&#125;; 983. 最低票价题目描述：在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有 三种不同的销售方式 ： 一张 为期一天 的通行证售价为 costs[0] 美元； 一张 为期七天 的通行证售价为 costs[1] 美元； 一张 为期三十天 的通行证售价为 costs[2] 美元。 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。 返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费 。 示例：示例 1： 12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。 示例 2： 1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示： 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days 按顺序严格递增 costs.length == 3 1 &lt;= costs[i] &lt;= 1000 题解：动态规划 1234567891011121314151617181920212223242526class Solution &#123;public: /* 完全背包问题：背包容量为最大旅行日子，物品为通行证，价值为票价 */ int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; int n = days.size(); vector&lt;int&gt; nums = &#123;1, 7, 30&#125;; vector&lt;int&gt; dp(days[n - 1] + 1, 0); int idx = 0; for (int i = 1; i &lt;= days[n - 1]; ++i) &#123; if (i == days[idx]) &#123; int tmp = INT_MAX; for (int j = 0; j &lt; costs.size(); ++j) &#123; tmp = min(tmp, dp[max(0, i - nums[j])] + costs[j]); &#125; dp[i] = tmp; ++idx; &#125; else &#123; dp[i] = dp[i - 1]; &#125; &#125; return dp[days[n - 1]]; &#125;&#125;; 时间复杂度：O(L * m)，L为最大旅行日子，m为通行证种类 空间复杂度：O(L) 记忆化搜索????","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"零钱兑换II","slug":"p/leetcode/day78","date":"2024-07-03T16:00:00.000Z","updated":"2024-07-05T05:32:10.894Z","comments":true,"path":"p/leetcode/day78/","permalink":"https://krystencollins.github.io/p/leetcode/day78/","excerpt":"","text":"518. 零钱兑换 II题目描述：给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例：示例 1： 1234567输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 示例 2： 123输入：amount = 3, coins = [2]输出：0解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 12输入：amount = 10, coins = [10] 输出：1 提示： 1 &lt;= coins.length &lt;= 300 1 &lt;= coins[i] &lt;= 5000 coins 中的所有值 互不相同 0 &lt;= amount &lt;= 5000 题解：动态规划 遍历顺序：外层for循环遍历物品，内层for循环遍历背包——求组合数 外层for循环遍历背包，内层for循环遍历物品——求排列数 12345678910111213141516171819202122class Solution &#123;public: /* 问题转化：完全背包问题，总金额为背包容量，硬币为物品，面额为价值，硬币可以无限取 组合类问题：dp[j] += dp[j - coins[i]] 1. dp数组以及下标含义：dp[j]表示凑成总金额为j的硬币共有多少种组合 2. 递推公式：dp[j] += dp[j - coins[i]]，每确定一个硬币面额coins[i]，就有dp[j - coins[i]]种方法 3. 初始化：dp[0] = 1, !!!! 4. 遍历顺序：先物品再背包容量，背包容量正序！！ 5. 举例推导dp数组 */ int change(int amount, vector&lt;int&gt;&amp; coins) &#123; vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; coins.size(); ++i) &#123; // 遍历物品 for (int j = coins[i]; j &lt;= amount; ++j) &#123; // 遍历背包容量 dp[j] += dp[j - coins[i]]; &#125; &#125; return dp[amount] == 0 ? 0 : dp[amount]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n) 二维数组： 1234567891011121314151617181920class Solution &#123;public: /* 问题转化：完全背包问题，总金额为背包容量，硬币为物品，面额为价值，硬币可以无限取 组合类问题：dp[j] += dp[j - coins[i]] 二维数组 */ int change(int amount, vector&lt;int&gt;&amp; coins) &#123; int n = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(amount + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; // 遍历物品 for (int j = 0; j &lt;= amount; ++j) &#123; // 遍历背包容量 if (j &lt; coins[i - 1]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; &#125; &#125; return dp[n][amount]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 377. 组合总和 Ⅳ题目描述：给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例：示例 1： 123456789101112输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。 示例 2： 12输入：nums = [9], target = 3输出：0 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 1000 nums 中的所有元素 互不相同 1 &lt;= target &lt;= 1000 进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ 题解：动态规划 1234567891011121314151617class Solution &#123;public: /* 排列类问题，先遍历背包容量，再遍历物品 */ int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= target; ++j) &#123; // 遍历背包容量 for (int i = 0; i &lt; nums.size(); ++i) &#123; // 遍历物品 if (j &gt;= nums[i] &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(m) 关于INT_MAX的问题，出错的用例如下： [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330,340,350,360,370,380,390,400,410,420,430,440,450,460,470,480,490,500,510,520,530,540,550,560,570,580,590,600,610,620,630,640,650,660,670,680,690,700,710,720,730,740,750,760,770,780,790,800,810,820,830,840,850,860,870,880,890,900,910,920,930,940,950,960,970,980,990,111] target&#x3D;999 这个用例的答案只有一种，就是9个111 。可以看到前面n-1个数都是10的倍数，是不可能得到和为999的。 但是dp计算的过程中会计算和为0-999所有数字。例如计算dp[990], 排列数目会有很多，可能越界。 最符合理论的解法是：使用unsigned long long, 这样完全满足传递方程， 保证中间计算值不越界。 官方的解法有偷巧的地方，因为最终结果保证不超过INT_MAX, 所以超过就不传递了。实际确实也不传递，假设dp[990] &gt; INT_MAX, dp[999] 实际无法通过dp[990]传递，因为nums里面没有一个值是9. 总结：dp中间值可能大于INT_MAX, 但是目标值是小于INT_MAX的。测试用例特殊，目标值实际不需要中间值（大于INT_MAX)的传递。 57. 爬楼梯（进阶版）题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例：输入描述 输入共一行，包含两个正整数，分别表示n, m 输出描述 输出一个整数，表示爬到楼顶的方法数。 输入示例 13 2 输出示例 13 提示信息数据范围：1 &lt;&#x3D; m &lt; n &lt;&#x3D; 32; 当 m &#x3D; 2，n &#x3D; 3 时，n &#x3D; 3 这表示一共有三个台阶，m &#x3D; 2 代表你每次可以爬一个台阶或者两个台阶。 此时你有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 题解：动态规划1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/* 完全背包问题：背包容量n，物品个数m，价值为物品值； 排列类问题！！ 1. dp数组以及下标含义：dp[j]表示装满容量为j的背包共有多少种方法 2. 递推公式：dp[j] += dp[j - nums[i]] 3. dp数组初始化：dp[0] = 1 ！！ 4. 遍历顺序：先背包容量再物品，正序！！ 5. 举例推导dp数组：*/int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= n; ++j) &#123; // 遍历背包 for (int i = 1; i &lt;= m; ++i) &#123; // 遍历物品 if (j &gt;= i) dp[j] += dp[j - i]; &#125; &#125; cout &lt;&lt; dp[n];&#125; 时间复杂度：O(n * m) 空间复杂度：O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"完全背包","slug":"p/leetcode/day77","date":"2024-07-02T16:00:00.000Z","updated":"2024-07-03T08:16:17.622Z","comments":true,"path":"p/leetcode/day77/","permalink":"https://krystencollins.github.io/p/leetcode/day77/","excerpt":"","text":"完全背包理论基础 携带研究材料题目描述：小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。 小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。 示例：输入描述 第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值 输出描述 输出一个整数，表示最大价值。 输入示例 123454 51 22 43 44 5 输出示例 110 提示信息第一种材料选择五次，可以达到最大值。 数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 10000;1 &lt;&#x3D; V &lt;&#x3D; 10000;1 &lt;&#x3D; wi, vi &lt;&#x3D; 10^9. 题解：动态规划先物品再背包 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/*完全背包：1. dp数组以及下标含义：dp[j]表示容量为j的背包，能装入物品的最大价值2. 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])3. 初始化：dp[j] = 04. 遍历顺序：完全背包问题 滚动数组 先遍历背包容量还是先遍历物品无所谓！ 遍历背包容量需要从小到大，因为物品可以无限取！！5. 举例推导dp数组*/void completePack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int bagWeight) &#123; vector&lt;int&gt; dp(bagWeight + 1, 0); for (int i = 0; i &lt; weight.size(); ++i) &#123; // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; ++j) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;&#125;int main() &#123; int N, V; cin &gt;&gt; N &gt;&gt; V; vector&lt;int&gt; weight; vector&lt;int&gt; value; for (int i = 0; i &lt; N; ++i) &#123; int w, v; cin &gt;&gt; w &gt;&gt; v; weight.push_back(w); value.push_back(v); &#125; completePack(weight, value, V); return 0;&#125; 时间复杂度：O(N * V) 空间复杂度：O(V) 先背包再物品 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; /*完全背包：1. dp数组以及下标含义：dp[j]表示容量为j的背包，能装入物品的最大价值2. 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])3. 初始化：dp[j] = 04. 遍历顺序：完全背包问题 滚动数组 先遍历背包容量还是先遍历物品无所谓！ 遍历背包容量需要从小到大，因为物品可以无限取！！5. 举例推导dp数组*/ void completePack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int bagWeight) &#123; vector&lt;int&gt; dp(bagWeight + 1, 0); for (int j = 0; j &lt;= bagWeight; ++j) &#123; // 遍历背包容量 for (int i = 0; i &lt; weight.size(); ++i) &#123; // 遍历物品 if (j &gt;= weight[i]) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;&#125; int main() &#123; int N, V; cin &gt;&gt; N &gt;&gt; V; vector&lt;int&gt; weight; vector&lt;int&gt; value; for (int i = 0; i &lt; N; ++i) &#123; int w, v; cin &gt;&gt; w &gt;&gt; v; weight.push_back(w); value.push_back(v); &#125; completePack(weight, value, V); return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"一和零","slug":"p/leetcode/day76","date":"2024-07-01T16:00:00.000Z","updated":"2024-07-03T08:08:56.365Z","comments":true,"path":"p/leetcode/day76/","permalink":"https://krystencollins.github.io/p/leetcode/day76/","excerpt":"","text":"474. 一和零题目描述：给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例：示例 1： 1234输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 123输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。 提示： 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 &#39;0&#39; 和 &#39;1&#39; 组成 1 &lt;= m, n &lt;= 100 题解：动态规划12345678910111213141516171819202122232425262728class Solution &#123;public: /* 问题转化：物品为strs中的元素，背包容量为m、n两个维度！物品价值为物品的数量 三维数组 */ int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; int l = strs.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(l + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1, 0))); for (int i = 1; i &lt;= l; ++i) &#123; int zeroNum = 0; int oneNum = 0; for (char ch : strs[i - 1]) &#123; if (ch == &#x27;0&#x27;) ++zeroNum; else ++oneNum; &#125; for (int j = 0; j &lt;= m; ++j) &#123; for (int k = 0; k &lt;= n; ++k) &#123; dp[i][j][k] = dp[i - 1][j][k]; if (j &gt;= zeroNum &amp;&amp; k &gt;= oneNum) &#123; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - zeroNum][k - oneNum] + 1); &#125; &#125; &#125; &#125; return dp[l][m][n]; &#125;&#125;; 时间复杂度：O(l * m * n + L)，L为所有子串的长度总和 空间复杂度：O(l * m * n) 滚动数组 1234567891011121314151617181920212223242526272829class Solution &#123;public: /* 问题转化：物品为strs中的元素，背包容量为m、n两个维度！物品价值为物品的数量 1. dp数组以及下标含义：dp[i][j]表示最多有i个0和j个1的strs的最大子集的大小 2. 递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)，当前元素放或不放 3. dp数组初始化：dp[i][j] = 0 4. 遍历顺序：外循环物品，内循环背包容量：dp数组两个维度都表示背包容量，倒序遍历！！哪个维度优先无所谓 5. 举例推导dp数组： */ int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1 , 0)); for (string str : strs) &#123; // 遍历物品 int zeroNum = 0; int oneNum = 0; for (char ch : str) &#123; if (ch == &#x27;0&#x27;) ++zeroNum; else ++oneNum; &#125; // 遍历背包容量，从后往前 for (int i = m; i &gt;= zeroNum; --i) &#123; for (int j = n; j &gt;= oneNum; --j) &#123; dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 时间复杂度：O(l* m * n + L) 空间复杂度：O(m * n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"目标和","slug":"p/leetcode/day75","date":"2024-06-17T16:00:00.000Z","updated":"2024-07-02T09:33:59.326Z","comments":true,"path":"p/leetcode/day75/","permalink":"https://krystencollins.github.io/p/leetcode/day75/","excerpt":"","text":"494. 目标和题目描述：给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例：示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 示例 2： 12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 题解：回溯超出内存限制 1234567891011121314151617181920212223242526272829class Solution &#123;public: int result = 0; int sum = 0; void backtracking(vector&lt;int&gt; nums, int target, int startIdx) &#123; if (startIdx == nums.size()) &#123; if (target == sum) ++result; return; &#125; for (int i = 0; i &lt;= 1; ++i) &#123; if (i) &#123; sum += nums[startIdx]; backtracking(nums, target, startIdx + 1); sum -= nums[startIdx]; &#125; else &#123; sum -= nums[startIdx]; backtracking(nums, target, startIdx + 1); sum += nums[startIdx]; &#125; &#125; &#125; int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; backtracking(nums, target, 0); return result; &#125;&#125;; 动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 问题转化：a+b=sum, a-b=target ---&gt; a=(sum+target)/2, b=(sum-target)/2 组合类问题：dp[j] += dp[j - nums[i]] */ int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if ((sum - target) % 2 == 1) return 0; // 不能整除，原问题无解 if (abs(target) &gt; sum) return 0; // target绝对值大于所有非负非负整数和，也无解 int b = (sum - target) / 2; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt; (b + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int num = nums[i - 1]; for (int j = 0; j &lt;= b; ++j) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= num) dp[i][j] += dp[i - 1][j - num]; &#125; &#125; return dp[n][b]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2) 滚动数组： 1234567891011121314151617181920212223242526class Solution &#123;public: /* 问题转化：a+b=sum, a-b=target ---&gt; a=(sum+target)/2, b=(sum-target)/2 组合类问题：dp[j] += dp[j - nums[i]] 1. dp数组含义：dp[j]表示装满容量为a的背包有多少种方案 2. 递推公式：dp[j] += dp[j - nums[i]]，每次确定了一个nums[i]的容量，就有dp[j - nums[i]]种方法 3. dp数组初始化：dp[0] = 1,.. 4. 遍历顺序：nums在外循环，target在内循环，内循环倒序 5. 举例推导dp数组： */ int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if ((sum + target) % 2 == 1) return 0; // 不能整除，原问题无解 if (abs(target) &gt; sum) return 0; // target绝对值大于所有非负非负整数和，也无解 int a = (sum + target) / 2; vector&lt;int&gt; dp(a + 1, 0); dp[0] = 1; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = a; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[a]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"分割等和子集","slug":"p/leetcode/day74","date":"2024-06-16T16:00:00.000Z","updated":"2024-07-02T09:17:17.178Z","comments":true,"path":"p/leetcode/day74/","permalink":"https://krystencollins.github.io/p/leetcode/day74/","excerpt":"","text":"416. 分割等和子集题目描述：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例：示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 题解：动态规划1234567891011121314151617181920212223242526class Solution &#123;public: /* 转化问题：任意数组元素是否可以组成和sum/2的序列。背包容量为sum/2, 每个元素重量为nums[i],价值也为nums[i] 1. dp数以及下标含义：dp[i][j]表示从0~i中任意取物品，放进容量为j的背包价值总和最大是多少 2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - nums[i]] + nums[i]) 3. dp数组初始化：dp[i][0] = 0; 当j &gt;= nums[0], dp[0][j] = nums[0], 否则dp[0][j] = 0 4. 遍历顺序：先物品再背包 5. 举例推导dp数组： */ bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; // 总和为奇数一定不可能分割成两个等和的子集 int bagweight = sum / 2; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(bagweight + 1, 0)); for (int j = bagweight; j &gt;= nums[0]; --j) dp[0][j] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= bagweight; ++j) &#123; if (j &lt; nums[i]) dp[i][j] = dp[i -1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]); &#125; &#125; return dp[n - 1][bagweight] == bagweight; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(n * sum) 空间优化： 123456789101112131415161718class Solution &#123;public: /* 转化问题：任意数组元素是否可以组成和sum/2的序列。背包容量为sum/2, 每个元素重量为nums[i],价值也为nums[i] */ bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; int bagweight = sum / 2; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = bagweight; j &gt;= nums[i]; --j) &#123; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); &#125; &#125; return dp[bagweight] == bagweight; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(sum) 1049. 最后一块石头的重量 II题目描述：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例：示例 1： 1234567输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 12输入：stones = [31,26,33,21,40]输出：5 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 题解：动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 问题转化：尽可能分割石头为重量相等的两个子集，背包重量为sum/2, 每个石头重量为stones[i], 价值也为stones[i] 1. dp数组以及下标含义：dp[i][j]表示从0~i的石头中任意取，放进背包容量为j的价值总和最大是多少 2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i]] + stones[i]) 3. dp数组初始化： 4. 遍历顺序： 5、 举例推导dp数组： */ int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int sum = accumulate(stones.begin(), stones.end(), 0); int bagweight = sum / 2; int n = stones.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(bagweight + 1, 0)); for (int j = bagweight; j &gt;= stones[0]; --j) dp[0][j] = stones[0]; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= bagweight; ++j) &#123; if (j &lt; stones[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[n - 1][bagweight] * 2; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(n * sum) 滚动数组 1234567891011121314class Solution &#123;public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int sum = accumulate(stones.begin(), stones.end(), 0); int bagweight = sum / 2; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; stones.size(); ++i) &#123; for (int j = bagweight; j &gt;= stones[i]; --j) &#123; dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[bagweight] * 2; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(sum)","categories":[],"tags":[]},{"title":"统计字典序元音字符串的数目","slug":"p/leetcode/day73","date":"2024-06-15T16:00:00.000Z","updated":"2024-07-02T09:06:32.049Z","comments":true,"path":"p/leetcode/day73/","permalink":"https://krystencollins.github.io/p/leetcode/day73/","excerpt":"","text":"1641. 统计字典序元音字符串的数目题目描述：给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。 示例：示例 1： 123输入：n = 1输出：5解释：仅由元音组成的 5 个字典序字符串为 [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;] 示例 2： 12345输入：n = 2输出：15解释：仅由元音组成的 15 个字典序字符串为[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;]注意，&quot;ea&quot; 不是符合题意的字符串，因为 &#x27;e&#x27; 在字母表中的位置比 &#x27;a&#x27; 靠后 示例 3： 12输入：n = 33输出：66045 提示： 1 &lt;= n &lt;= 50 题解：回溯123456789101112131415161718192021222324class Solution &#123;public: int result = 0; vector&lt;string&gt; vowel = &#123;&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;&#125;; string path; void backtracking(int startIdx, int n) &#123; if (path.size() == n) &#123; ++result; return; &#125; for (int i = startIdx; i &lt; vowel.size(); ++i) &#123; path += vowel[i]; backtracking(i, n); path.pop_back(); &#125; &#125; int countVowelStrings(int n) &#123; backtracking(0, n); return result; &#125;&#125;; 动态规划 1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示长度为i+1，以j结尾的仅含元音字典序排序的字符串数量 2. 递推公式：i = 0, dp[i][j] = 1; i &gt; 0, dp[i][j] = sum(dp[i-1][k]), k从0到j 3. dp数组初始化： 4. 遍历顺序： 5. 举例推导dp数组： */ int countVowelStrings(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(5, 0)); for (int j = 0; j &lt; 5; ++j) dp[0][j] = 1; for (int i = 1; i &lt; n; ++i) &#123; dp[i][0] = dp[i -1][0]; for (int j = 1; j &lt; 5; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; int result = 0; for (int j = 0; j &lt; 5; ++j) result += dp[n - 1][j]; return result; &#125;&#125;; 时间复杂度：O(n * M)， M&#x3D;5 空间复杂度：O(n * M) 空间优化： 123456789101112class Solution &#123;public: int countVowelStrings(int n) &#123; vector&lt;int&gt; dp(5, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; 5; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return accumulate(dp.begin(), dp.end(), 0); &#125;&#125;; 时间复杂度：O(n * M) ，M&#x3D;5 空间复杂度：O(M)","categories":[],"tags":[]},{"title":"0-1背包","slug":"p/leetcode/day72","date":"2024-06-14T16:00:00.000Z","updated":"2024-07-02T09:02:41.771Z","comments":true,"path":"p/leetcode/day72/","permalink":"https://krystencollins.github.io/p/leetcode/day72/","excerpt":"","text":"0-1背包基础理论 有n件物品和一个最多能装重量为w的背包，第i件物品的重量是weight[i]，得到的价值是value[i]，每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 确定dp数组以及下标含义 dp[i][j]表示从下标为0~i的物品里任意取，放进容量为j的背包，价值总和最大是多少 确定递推公式 不放物品i：dp[i][j] = dp[i-1][j]，相当于当物品i重量大于背包剩余重量时，物品无法放进背包中 放物品i：dp[i][j] = dp[i-1][j - weight[i]] + value[i] dp数组初始化：dp[i][0] = 0，dp[0][j] = value[0], 当j &gt;= wight[0]时，否则为0 遍历顺序：二维数组先遍历物品 or 先遍历背包都可以，先遍历物品再遍历背包容易理解 滚动数组 确定dp数组的定义：在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： 1dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了 一维dp数组遍历顺序 代码如下： 123456for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125;&#125; 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15 如果正序遍历 dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15 dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？ 倒序就是先算dp[2] dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0） dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？ 因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！ 再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？ 不可以！ 因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。 46. 携带研究材料题目描述：小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。 输入描述 第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。 第二行包含 M 个正整数，代表每种研究材料的所占空间。 第三行包含 M 个正整数，代表每种研究材料的价值。 输出描述 输出一个整数，代表小明能够携带的研究材料的最大价值。 示例： 输入示例 1236 12 2 3 1 5 22 3 1 5 4 3 输出示例 15 提示信息小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 数据范围：1 &lt;&#x3D; N &lt;&#x3D; 50001 &lt;&#x3D; M &lt;&#x3D; 5000研究材料占用空间和价值都小于等于 1000 题解：动态规划1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; /*1. dp数组以及下标含义：dp[i][j]从下标0~i的物品中任意取，放进空间为j的背包，价值总和是多少2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - weights[i] + vaules[i]), 放与不放取较大值3. dp数组初始化：dp[0][j] = vaules[0], 当j &gt;= weights[0], 否则dp[0][j]=0 4. 遍历顺序：先遍历物品再遍历背包，或者相反5. 举例推导dp数组：*/ int main() &#123; int M, N; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; weights(M, 0); vector&lt;int&gt; values(M, 0); for (int i = 0; i &lt; M; ++i) cin &gt;&gt; weights[i]; for (int i = 0; i &lt; M; ++i) cin &gt;&gt; values[i]; vector&lt;vector&lt;int&gt;&gt; dp(M, vector&lt;int&gt;(N+1, 0)); for (int j = weights[0]; j &lt;= N; ++j) dp[0][j] = values[0]; for (int i = 1; i &lt; M; ++i) &#123; for (int j = 0; j &lt;= N; ++j) &#123; if (j &lt; weights[i]) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]); &#125; &#125; cout &lt;&lt; dp[M-1][N] &lt;&lt; endl; return 0;&#125; 时间复杂度：O(M * N) 空间复杂度：O(M * N) 滚动数组123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; /*1. dp数组以及下标含义：dp[j]表示空间为j的背包，价值总和是多少2. 递推公式：dp[j] = max(dp[j], dp[j - weights[i] + vaules[i]), 放与不放取较大值3. dp数组初始化：dp[0] = 0,4. 遍历顺序：先遍历物品再遍历背包，（背包倒序遍历！）5. 举例推导dp数组：*/ int main() &#123; int M, N; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; weights(M, 0); vector&lt;int&gt; values(M, 0); for (int i = 0; i &lt; M; ++i) cin &gt;&gt; weights[i]; for (int i = 0; i &lt; M; ++i) cin &gt;&gt; values[i]; vector&lt;int&gt; dp(N+1, 0); for (int i = 0; i &lt; M; ++i) &#123; for (int j = N; j &gt;= weights[i]; --j) &#123; //背包重量只需从N减少到当前研究材料所占空间 dp[j] = max(dp[j], dp[j - weights[i]] + values[i]); &#125; &#125; cout &lt;&lt; dp[N] &lt;&lt; endl; return 0;&#125; 时间复杂度：O(N * M) 空间复杂度：O(N)","categories":[],"tags":[]},{"title":"整数拆分","slug":"p/leetcode/day71","date":"2024-06-13T16:00:00.000Z","updated":"2024-08-26T14:53:33.873Z","comments":true,"path":"p/leetcode/day71/","permalink":"https://krystencollins.github.io/p/leetcode/day71/","excerpt":"","text":"343. 整数拆分题目描述：给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例：示例 1: 123输入: n = 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 123输入: n = 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示: 2 &lt;= n &lt;= 58 题解：动态规划 1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标的含义：dp[i]表示整数i拆分后所得最大乘积 2. 递推公式：dp[i] = max(dp[i], j*(i - j), j*dp[i-j]) , j从1到i-1 3. dp数组初始化：dp[2] = 1 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1, 0); dp[2] = 1; for (int i = 3; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i - 1; ++j) &#123; dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 贪心算法每次拆成n个3，如果剩下是4，则保留4，然后相乘，但是这个结论需要数学证明其合理性！ 123456789101112131415class Solution &#123;public: int integerBreak(int n) &#123; if (n == 2) return 1; if (n == 3) return 2; if (n == 4) return 4; int result = 1; while (n &gt; 4) &#123; result *= 3; n -= 3; &#125; result *= n; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 95. 不同的二叉搜索树 II题目描述：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例：示例 1： 12输入：n = 3输出：5 示例 2： 12输入：n = 1输出：1 提示： 1 &lt;= n &lt;= 19 题解：动态规划12345678910111213141516171819202122class Solution &#123;public: /* 1. dp数组有以及下标含义：dp[i]表示i个节点不同的二叉搜索树有多少种 2. 递推公式：dp[i] = sum(dp[j] * dp[i-j-1]), j: 0~ i-1 3. dp数组初始化：dp[0] = 1, dp[1] = 1 3. 遍历顺序：从前往后 5. 举例推导dp数组： */ int numTrees(int n) &#123; if (n == 1) return n; vector&lt;int&gt; dp(n+1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= i - 1; ++j) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 递归12345678910111213class Solution &#123;public: int result = 0; int numTrees(int n) &#123; if (n == 0) return 1; if (n == 1 || n == 2) return n; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum += numTrees(i - 1) * numTrees(n - i); &#125; return sum; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"不同路径","slug":"p/leetcode/day70","date":"2024-06-12T16:00:00.000Z","updated":"2024-08-26T14:54:02.713Z","comments":true,"path":"p/leetcode/day70/","permalink":"https://krystencollins.github.io/p/leetcode/day70/","excerpt":"","text":"62. 不同路径题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例：示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i行j列共有多少条不同路径 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： p[1][j]=dp[i][1]=1, 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 1)); for (int i = 2; i &lt;= m; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 空间优化： 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; vector&lt;int&gt; dp(n+1, 1); for (int i = 2; i &lt;= m; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; dp[j] = dp[j-1] + dp[j]; &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n) 深度优先搜索 &#x3D;&#x3D;超出时间限制&#x3D;&#x3D; 123456789101112class Solution &#123;public: int dfs(int i, int j, int m, int n) &#123; if (i &gt; m || j &gt; n) return 0; // 越界 if (i == m || j == n) return 1; // 找到一种方法，相当于找到叶子节点 return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); &#125; int uniquePaths(int m, int n) &#123; return dfs(1, 1, m, n); &#125;&#125;; 时间复杂度：O(2 ^ (m+n+1)) 空间复杂度：O(m+n+1) 数论无论怎么走，走到终点都需要m+n-2步，其中一定有m-1步往下走，不用管什么时候往下走 组合问题：$C^{m-1}_{m+n-2}$ 防止两个int相乘溢出 1234567891011121314151617class Solution &#123;public: int uniquePaths(int m, int n) &#123; long long numerator = 1; // 分子 int denominator = m - 1; // 分母 int count = m - 1; int t = m + n - 2; while (count--) &#123; numerator *= (t--); while (denominator != 0 &amp;&amp; numerator % denominator == 0) &#123; numerator /= denominator; // 计算过程中不断除以分母，防止溢出 denominator--; &#125; &#125; return numerator; &#125;&#125;; 时间复杂度：O(m) 空间复杂度：O(1) 63. 不同路径 II题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例：示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 题解：动态规划1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i-1行j-1列共有多少条不同路径,i,j从0开始 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： dp[0][j] = ?, dp[i][0] = ? 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if (obstacleGrid[0][0] == 1) return 0; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; // 起始位置一定可达，因为已排除不可达情况 for (int i = 1; i &lt; m; ++i) &#123; // 若当前位置没有障碍物，且上一个位置可达，则当前位置可达 if (obstacleGrid[i][0] == 0 &amp;&amp; dp[i-1][0] != 0) &#123; dp[i][0] = 1; &#125; else dp[i][0] = 0; // 若当前位置有障碍物，或者上一个位置不可达，则当前位置不可达 &#125; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 0 &amp;&amp; dp[0][j-1] != 0) dp[0][j] = 1; else dp[0][j] = 0; // 可省略，已初始化 &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 时间复杂度：O(m * n) 空间复杂度：O(m * n) 简化代码： 123456789101112131415161718192021222324class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i-1行j-1列共有多少条不同路径,i,j从0开始 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： dp[0][j] = ?, dp[i][0] = ? 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; ++i) dp[i][0] = 1; for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; ++j) dp[0][j] = 1; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 空间优化： 1234567891011121314151617181920class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; dp(n, 0); for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; ++j) dp[j] = 1; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (j == 0) &#123; if (obstacleGrid[i][j] == 1) dp[j] = 0; continue; &#125; if (obstacleGrid[i][j] == 1) dp[j] = 0; else dp[j] = dp[j] + dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 时间复杂度：O(m * n) 空间复杂度：O(n)","categories":[{"name":"leetcod","slug":"leetcod","permalink":"https://krystencollins.github.io/categories/leetcod/"}],"tags":[]},{"title":"动态规划理论","slug":"p/leetcode/day69","date":"2024-06-11T16:00:00.000Z","updated":"2024-08-26T14:54:38.679Z","comments":true,"path":"p/leetcode/day69/","permalink":"https://krystencollins.github.io/p/leetcode/day69/","excerpt":"","text":"动态规划步骤： 确定dp数组，以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 递推公式决定了dp数组如何初始化 如何debug？把dp数组打印出来，看看究竟是不是按照自己思路推导的 509. 斐波那契数题目描述：斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 示例：示例 1： 123输入：n = 2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：n = 3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：n = 4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 题解：递归1234567class Solution &#123;public: int fib(int n) &#123; if (n == 0 || n == 1) return n; return fib(n - 1) + fib(n - 2); &#125;&#125;; 时间复杂度：O(2^n) 空间复杂度：O(n) 动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. 确定dp数组以及下标含义：第i个数的斐波那契数值为dp[i] 2. 确定递推公式：dp[i]=dp[i-1]+dp[i-2] 3. dp数组初始化：dp[0]=0, dp[1]=1 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int fib(int n) &#123; if (n &lt;= 1) return n; vector&lt;int&gt; dp(n + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化：只需要维护两个数值即可，不需要记录整个序列 123456789101112131415class Solution &#123;public: int fib(int n) &#123; if (n &lt;= 1) return n; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 70. 爬楼梯题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例：示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示到达i阶有多少种方法 2. 确定递推公式：dp[i] = dp[i-1] + dp[i-2] 3. dp数组初始化：dp[1]=1, dp[2]=2 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int climbStairs(int n) &#123; if (n &lt;= 2) return n; vector&lt;int&gt; dp(n+1); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 123456789101112131415class Solution &#123;public: int climbStairs(int n) &#123; if (n &lt;= 2) return n; int dp[2]; dp[0] = 1; dp[1] = 2; for (int i = 3; i &lt;= n; ++i) &#123; int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 递归超出时间限制 1234567class Solution &#123;public: int climbStairs(int n) &#123; if (n &lt;= 2) return n; return climbStairs(n - 1) + climbStairs(n - 2); &#125;&#125;; 746. 使用最小花费爬楼梯题目描述：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 示例：示例 1： 12345输入：cost = [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。 示例 2： 12345678910输入：cost = [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。 提示： 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标的含义：dp[i]表示到达第i阶需要支付的 最小费用 2. 确定递推公式：dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]) 3. dp数组初始化：dp[0] = 0, dp[1]=0 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n+1); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 123456789101112131415class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); int dp[2]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; int sum = min(dp[1] + cost[i - 1], dp[0] + cost[i - 2]); dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"单调递增的数字","slug":"p/leetcode/day68","date":"2024-06-10T16:00:00.000Z","updated":"2024-08-26T14:55:22.507Z","comments":true,"path":"p/leetcode/day68/","permalink":"https://krystencollins.github.io/p/leetcode/day68/","excerpt":"","text":"738. 单调递增的数字题目描述：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 示例：示例 1: 12输入: n = 10输出: 9 示例 2: 12输入: n = 1234输出: 1234 示例 3: 12输入: n = 332输出: 299 提示: 0 &lt;= n &lt;= 10^9 题解：暴力法12345678910111213141516171819202122class Solution &#123;public: // 判断一个数字的各位是否递增 bool isIncreasing(int num) &#123; int max = 10; // 记录上一个数最后一个数字 while (num) &#123; int t = num % 10; // 记录当前最后一个数字 if (max &gt;= t) max = t; // 若不递减则更新 else return false; // 否则返回false num = num / 10; // 取剩下的高位数字 &#125; return true; &#125; int monotoneIncreasingDigits(int n) &#123; // 从大到小遍历 for (int i = n; i &gt; 0; --i) &#123; if (isIncreasing(i)) return i; &#125; return 0; &#125;&#125;; 时间复杂度：O(n * m)，m为数字n的长度 空间复杂度：O(1) 贪心 12345678910111213141516171819class Solution &#123;public: int monotoneIncreasingDigits(int n) &#123; string strNum = to_string(n); int m = strNum.size(); int flag = m; // 标记赋值9从哪开始 // 从后往前遍历，从哪开始出现递减则后面的各位数字都为9 for (int i = m - 1; i &gt; 0; --i) &#123; if (strNum[i - 1] &gt; strNum[i]) &#123; flag = i; strNum[i - 1]--; &#125; &#125; for (int i = flag; i &lt; m; ++i) &#123; strNum[i] = &#x27;9&#x27;; &#125; return stoi(strNum); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"监控二叉树","slug":"p/leetcode/day67","date":"2024-06-09T16:00:00.000Z","updated":"2024-08-26T14:55:47.412Z","comments":true,"path":"p/leetcode/day67/","permalink":"https://krystencollins.github.io/p/leetcode/day67/","excerpt":"","text":"968. 监控二叉树题目描述：给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例：示例 1： 123输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。 示例 2： 123输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 题解：贪心从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少；整体最优：全部摄像头摄像头数量所用最少 大致思路：从下往上，先给叶子节点的父节点放一个摄像头，然后每隔两个节点放一个摄像头，直到二叉树的头节点 如何隔两个节点放一个摄像头！！ 状态转移 0：本节点无覆盖 1：本节点有摄像头 2：本节点有覆盖 详细思路 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int result = 0; int postOrder(TreeNode* node) &#123; // 空节点，表示有覆盖 if (node == nullptr) return 2; int left = postOrder(node-&gt;left); int right = postOrder(node-&gt;right); // 1. 左右节点都有覆盖 if (left == 2 &amp;&amp; right == 2) return 0; // 2. 左右节点至少一个无覆盖 // left == 0 &amp;&amp; right == 0 // left == 0 &amp;&amp; right == 1 // left == 0 &amp;&amp; right == 2 // left == 1 &amp;&amp; right == 0 // left == 2 &amp;&amp; right == 0 if (left == 0 || right == 0) &#123; ++result; return 1; &#125; // 3. 左右节点至少有一个有摄像头 // left == 1 &amp;&amp; right == 1 // left == 1 &amp;&amp; right == 2 // left == 2 &amp;&amp; right == 2 // 其他情况以上已经包含 if (left == 1 || right == 1) return 2; // 逻辑不会走到这 return -1; &#125; int minCameraCover(TreeNode* root) &#123; // 若头节点未覆盖，还需要一个摄像头 if (postOrder(root) == 0) &#123; ++result; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 代码简化： 123456789101112131415161718192021class Solution &#123;public: int result = 0; int postOrder(TreeNode* node) &#123; if (node == nullptr) return 2; int left = postOrder(node-&gt;left); int right = postOrder(node-&gt;right); if (left == 2 &amp;&amp; right == 2) return 0; else if (left == 0 || right == 0) &#123; ++result; return 1; &#125; else return 2; &#125; int minCameraCover(TreeNode* root) &#123; if (postOrder(root) == 0) ++result; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"子字符串的最优划分","slug":"p/leetcode/day66","date":"2024-06-08T16:00:00.000Z","updated":"2024-08-26T14:56:20.946Z","comments":true,"path":"p/leetcode/day66/","permalink":"https://krystencollins.github.io/p/leetcode/day66/","excerpt":"","text":"2405. 子字符串的最优划分题目描述：给你一个字符串 s ，请你将该字符串划分成一个或多个 子字符串 ，并满足每个子字符串中的字符都是 唯一 的。也就是说，在单个子字符串中，字母的出现次数都不超过 一次 。 满足题目要求的情况下，返回 最少 需要划分多少个子字符串。 注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。 示例：示例 1： 12345输入：s = &quot;abacaba&quot;输出：4解释：两种可行的划分方法分别是 (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) 和 (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;) 。可以证明最少需要划分 4 个子字符串。 示例 2： 1234输入：s = &quot;ssssss&quot;输出：6解释：只存在一种可行的划分方法 (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;) 。 提示： 1 &lt;= s.length &lt;= 105 s 仅由小写英文字母组成 题解：哈希表从头开始遍历字符串，同时哈希表记录出现过的字符，当遇到已经出现的字符，说明找到一个划分，哈希表清空，继续遍历 12345678910111213141516171819class Solution &#123;public: int partitionString(string s) &#123; if (s.size() == 1) return 1; vector&lt;int&gt; hash(26, 0); int result = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (hash[s[i] - &#x27;a&#x27;] == 0) &#123; hash[s[i] - &#x27;a&#x27;] = 1; // 之前未出现，记录到哈希表中 &#125; else &#123; // 出现重复字符，划分数++ ++result; hash = vector&lt;int&gt;(26, 0); // 清空哈希表，这里直接重定义 hash[s[i] - &#x27;a&#x27;] = 1; // 注意：把当前字符加入“新哈希表”中 &#125; &#125; return ++result; // 加上最后一个划分 &#125;&#125;; 时间复杂度：O(n)，n为字符串长度 空间复杂度：O(m)，m&#x3D;26 3. 无重复字符的最长子串题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例：示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题解：滑动窗口+哈希表代码一： 出现重复字符时，通过left指针 一直移除哈希表中 “重复字符之前的字符”包括 该重复字符 123456789101112131415161718192021222324class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; // 哈希表，记录每个字符是否出现过 unordered_set&lt;char&gt; uset; int maxLen = 0; uset.insert(s[0]); // 首先将第一个字符插入哈希表 // left相当于 起始字符 for (int left = 0, right = 1; left &lt; n; ++left) &#123; // 不断移动右指针，直到出现重复字符，同时插入哈希表 while (right &lt; n &amp;&amp; !uset.count(s[right])) &#123; uset.insert(s[right]); ++right; &#125; // 出现重复字符，记录最长不重复字符串 maxLen = max(maxLen, right - left); // 移除在哈希表中的 left所指字符，相当于从下一个 字符开始 uset.erase(s[left]); &#125; return maxLen; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 代码二： 相同的思路：遇到重复字符时，start指针更新为 之前start 与 出现重复字符位置 的较大值 12345678910111213141516171819202122232425class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; unordered_map&lt;char, int&gt; umap; int maxLen = 0; int curLen = 0; int start = 0; for (int i = 0; i &lt; n; ++i) &#123; if (!umap.count(s[i])) &#123; ++curLen; umap.insert(pair&lt;char, int&gt; (s[i], i)); &#125; else &#123; maxLen = max(maxLen, curLen); start = max(umap[s[i]], start); curLen = i - start; umap[s[i]] = i; &#125; &#125; maxLen = max(maxLen, curLen); return maxLen; &#125;&#125;; 986. 区间列表的交集题目描述：给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。 返回这 两个区间列表的交集 。 形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。 两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。 示例：示例 1： 12输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] 示例 2： 12输入：firstList = [[1,3],[5,9]], secondList = []输出：[] 示例 3： 12输入：firstList = [], secondList = [[4,8],[10,12]]输出：[] 示例 4： 12输入：firstList = [[1,7]], secondList = [[3,10]]输出：[[3,7]] 提示： 0 &lt;= firstList.length, secondList.length &lt;= 1000 firstList.length + secondList.length &gt;= 1 0 &lt;= starti &lt; endi &lt;= 109 endi &lt; starti+1 0 &lt;= startj &lt; endj &lt;= 109 endj &lt; startj+1 题解：双指针123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList) &#123; int n = firstList.size(); int m = secondList.size(); if (n == 0) return firstList; if (m == 0) return secondList; vector&lt;vector&lt;int&gt;&gt; result; int start = 0; int end = 0; for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m;) &#123; if (firstList[i][1] &lt; secondList[j][0]) &#123; ++i; &#125; else if (firstList[i][0] &gt; secondList[j][1]) &#123; ++j; &#125; else &#123; start = max(firstList[i][0], secondList[j][0]); if (firstList[i][1] &lt; secondList[j][1]) &#123; end = firstList[i][1]; ++i; &#125; else &#123; end = secondList[j][1]; ++j; &#125; result.push_back(&#123;start, end&#125;); &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(max(n, m)) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"无重叠区间","slug":"p/leetcode/day65","date":"2024-06-07T16:00:00.000Z","updated":"2024-08-26T14:57:05.884Z","comments":true,"path":"p/leetcode/day65/","permalink":"https://krystencollins.github.io/p/leetcode/day65/","excerpt":"","text":"435. 无重叠区间题目描述：给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例：示例 1: 123输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 123输入: intervals = [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 123输入: intervals = [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 题解：贪心方法一：对终止位置排序， 1）从前往后遍历，以最小右边界判断是否重叠 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; // 需要移除区间数初始化为0 int num = intervals[0][1]; // 记录 当前最小右边界 for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 若 下一个区间左边界 严格小于 当前最小右边界，说明有重叠，result++ if (num &gt; intervals[i][0]) &#123; ++result; &#125; else &#123; // 否则，更新最小右边界 num = intervals[i][1]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 2）从后往前遍历 1234567891011121314151617181920212223242526class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int size = intervals.size(); int num = intervals[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (num &lt; intervals[i][1]) &#123; ++result; num = max(num, intervals[i][0]); // 左边界更新为“最大值”，相等于移除左边界更小的区间 &#125; else &#123; num = intervals[i][0]; &#125; &#125; return result; &#125;&#125;; 方法二：对区间 起始位置排序， 1）从前往后遍历， 遇到重叠时，更新 右边界为“最小值”，相当于移除了右边界更大的区间，因为右边界更大的区间可能与后续其他区间重叠，根据“贪心策略”，需要保证移除的区间数最少， 12例1： [[1,5],[6,7],[7, 8], [7,9],[9, 10]]例2： [[1,10],[2,4],[5, 6], [7,9]] 只需要移除[1,10] 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int num = intervals[0][1]; for (int i = 1; i &lt; intervals.size(); ++i) &#123; if (num &gt; intervals[i][0]) &#123; ++result; num = min(num, intervals[i][1]); // 更新右边界为“最小值” &#125; else &#123; num = intervals[i][1]; &#125; &#125; return result; &#125;&#125;; 2）从后往前遍历，以最大左边界判断是否重叠，遇到重叠时则不需要更新“num“ 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int size = intervals.size(); int num = intervals[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (num &lt; intervals[i][1]) &#123; ++result; &#125; else &#123; num = intervals[i][0]; &#125; &#125; return result; &#125;&#125;; 763. 划分字母区间题目描述：给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 示例：示例 1： 123456输入：s = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 示例 2： 12输入：s = &quot;eccbbbbdec&quot;输出：[10] 提示： 1 &lt;= s.length &lt;= 500 s 仅由小写英文字母组成 题解：贪心方法一： 统计字符串中所有字符的 起始位置和结束位置，将这些区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠，（即区间为 435. 无重叠区间的输入） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; vector&lt;int&gt; partitionLabels(string s) &#123; // 哈希表记录每个字母出现的区间 vector&lt;vector&lt;int&gt;&gt; letter_hash(26, vector&lt;int&gt;&#123;&#125;); for (int i = 0; i &lt; s.size(); ++i) &#123; int idx = s[i] - &#x27;a&#x27;; if (letter_hash[idx].size() == 0) &#123; letter_hash[idx] = &#123;i, i&#125;; &#125; else &#123; letter_hash[idx][1] = i; &#125; &#125; // 去除字符串中未出现的字母 区间 vector&lt;vector&lt;int&gt;&gt; intervals; for (vector&lt;int&gt; vec : letter_hash) &#123; if (vec.size() != 0) intervals.push_back(vec); &#125; // 按左边界从小到大排序 sort(intervals.begin(), intervals.end(), cmp()); vector&lt;int&gt; result; int start = intervals[0][0]; // 可直接令为 0 int end = intervals[0][1]; // 当前 最大右边界 for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 若下一个区间 起始位置 小于当前最大右边界，说明有重叠，更新最大右边界 if (end &gt; intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; // 否则不再重叠，找到一个片段， result.push_back(end - start + 1); // 将片段长度记录到result start = intervals[i][0]; // 更新左右边界 end = intervals[i][1]; &#125; &#125; result.push_back(end - start + 1); // 将最后一个片段长度记录到result return result; &#125;&#125;; 时间复杂度：O(nlog n) + O(m)，n&#x3D;26，m为字符串长度 空间复杂度：O(log n) 方法二： 局部最优：寻找每个片段可能的最小结束下标，保证每个片段的长度一定符合要求的最短长度；若取更短的片段，一定会出现同一个字母出现在多个片段中 全局最优：每次取得片段都是符合要求的最短片段，得到片段数最多 统计每个字符最后出现的位置， 从头遍历，并更新字符最远出现下标，若找到字符最远出现下标 和当前下标相等，则找到一个分割点 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; partitionLabels(string s) &#123; int hash[26]; for (int i = 0; i &lt; s.size(); ++i) &#123; hash[s[i] - &#x27;a&#x27;] = i; // 统计每个字符最后出现的位置 &#125; vector&lt;int&gt; result; int start = 0; int end = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; end = max(end, hash[s[i] - &#x27;a&#x27;]); // 更新字符最远出现下标 if (end == i) &#123; // 字符最远出现下标与当前下标相等，则为一个分割点 result.push_back(end - start + 1); start = end + 1; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(m)，m为字符串长度 空间复杂度：O(n)，n &#x3D; 26 56. 合并区间题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例：示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 123输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 题解：贪心对起始位置排序，从前往后遍历，发现重叠区间时，更新右边界为较大值，表示合并 1234567891011121314151617181920212223242526272829class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); vector&lt;vector&lt;int&gt;&gt; result; int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 发现重叠区间，进行合并：更新右边界为较大值 if (end &gt;= intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; // 不重叠，加入result，更新下一个左右边界 result.push_back(&#123;start, end&#125;); start = intervals[i][0]; end = intervals[i][1]; &#125; &#125; result.push_back(&#123;start, end&#125;); // 加入最后一个区间 return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 57. 插入区间题目描述：给你一个 无重叠的 ，按照区间起始端点排序的区间列表 intervals，其中 intervals[i] = [starti, endi] 表示第 i 个区间的开始和结束，并且 intervals 按照 starti 升序排列。同样给定一个区间 newInterval = [start, end] 表示另一个区间的开始和结束。 在 intervals 中插入区间 newInterval，使得 intervals 依然按照 starti 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。 返回插入之后的 intervals。 注意 你不需要原地修改 intervals。你可以创建一个新数组然后返回它。 示例：示例 1： 12输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 提示： 0 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 105 intervals 根据 starti 按 升序 排列 newInterval.length == 2 0 &lt;= start &lt;= end &lt;= 105 题解： 待插入区间 与原区间列表中 任何一个都无交集，可能在 两个区间之间，可能排 在第一个或最后一个 有交集：与 “左区间”重叠；与“右区间”重叠 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; // 寻找插入位置 for (; i &lt; intervals.size(); ++i) &#123; // 若某一个区间右边界 大于等于 待插入区间 的左边界， // 说明找到插入位置，但尚不知哪种情况 if (intervals[i][1] &gt;= newInterval[0]) break; else result.push_back(intervals[i]); &#125; // 若原区间列表没有一个 区间右边界 大于等于 待插入区间左边界 // 说明 插入位置为区间列表尾部，直接加入，并返回 if (i == intervals.size()) &#123; result.push_back(newInterval); return result; &#125; // 记录插入位置 左右边界 int start = intervals[i][0]; int end = intervals[i][1]; // 若插入位置左边界 大于 待插入区间右边界，说明“无交集”，并且 插入位置在右，待插入区间在左 if (newInterval[1] &lt; start) &#123; result.push_back(newInterval); &#125; else &#123; // 否则，出现重叠，直接合并区间：取左边界较小值，取右边界较大值 start = min(start, newInterval[0]); end = max(end, newInterval[1]); &#125; // 继续判断插入后，后续区间是否出现重叠 for (++i; i &lt; intervals.size(); ++i) &#123; if (end &gt;= intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; result.push_back(&#123;start, end&#125;); start = intervals[i][0]; end = intervals[i][1]; &#125; &#125; // 加入最后一个区间 result.push_back(&#123;start, end&#125;); return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"根据身高重建队列","slug":"p/leetcode/day64","date":"2024-06-06T16:00:00.000Z","updated":"2024-08-26T14:58:22.866Z","comments":true,"path":"p/leetcode/day64/","permalink":"https://krystencollins.github.io/p/leetcode/day64/","excerpt":"","text":"406. 根据身高重建队列题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例：示例 1： 12345678910输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 12输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= hi &lt;= 106 0 &lt;= ki &lt; people.length 题目数据确保队列可以被重建 题解：贪心算法遇到两个维度权衡时，一定要先确定一个维度，再确定另一个维度！ 身高一定从大到小（相同身高K值小的站前面）。前面节点一定比本节点高 局部最优：优先按身高 高的people的k来插入，插入操作过后的people满足队列属性 全局最优：完成所有插入操作，整个队列满足题目队列属性 123456789101112131415161718192021class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; // 优先按升高从大到小排序，若身高相同，k值小的排前面 sort(people.begin(), people.end(), cmp()); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; people.size(); ++i) &#123; int position = people[i][1]; result.insert(result.begin() + position, people[i]); &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) + O(n^2) 空间复杂度：O(n) 代码优化： vector的插入insert()操作非常耗时，改成list效率更好 123456789101112131415161718192021222324class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), cmp()); list&lt;vector&lt;int&gt;&gt; result; // list底层是链表实现，插入效率比vector高得多 for (int i = 0; i &lt; people.size(); ++i) &#123; int position = people[i][1]; // 插入到下标为position的位置 list&lt;vector&lt;int&gt;&gt;::iterator it = result.begin(); while (position--) &#123; // 寻找插入位置 ++it; &#125; result.insert(it, people[i]); &#125; return vector&lt;vector&lt;int&gt;&gt; (result.begin(), result.end()); &#125;&#125;; 时间复杂度：O(nlog n) + O(n^2) 空间复杂度：O(n) 452. 用最少数量的箭引爆气球题目描述：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 示例：示例 1： 12345输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:-在x = 6处射出箭，击破气球[2,8]和[1,6]。-在x = 11处发射箭，击破气球[10,16]和[7,12]。 示例 2： 123输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3： 12345输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用2支箭来爆破:- 在x = 2处发射箭，击破气球[1,2]和[2,3]。- 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 题解：贪心算法局部最优：当气球出现重叠时，一起射，所用弓箭最少； 全局最优：把所有气球射爆所用弓箭最少 为了让气球尽可能重叠，需要对数组进行排序，按起始位置或按终止位置排序都可以，遍历顺序不同而已 方法一：对终止位置排序后，重叠气球最小右边界 为第一个气球右边界！！ 1234567891011121314151617181920212223242526class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; // 对终止位置升序排序 sort(points.begin(), points.end(), cmp()); int result = 1; // points不为空，至少需要一支箭 int num = points[0][1]; // 记录当前最小右边界 for (int i = 1; i &lt; points.size(); ++i) &#123; // 下一个气球左边界 不在当前最小右边界内，说明不重叠 if (points[i][0] &gt; num) &#123; ++result; // 必须要另一支箭 num = points[i][1]; // 更新最小右边界 &#125; // 下一个气球 左边界 在当前最小右边界内，说明有重叠，可以一起射爆，则继续判断下一个 else if (points[i][0] &lt;= num) continue; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 方法二：对起始位置排序，从后往前遍历 123456789101112131415161718192021222324class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(points.begin(), points.end(), cmp()); int result = 1; int size = points.size(); int num = points[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (points[i][1] &lt; num) &#123; ++result; num = points[i][0]; &#125; else if (points[i][1] &gt;= num) continue; &#125; return result; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"柠檬水找零","slug":"p/leetcode/day63","date":"2024-06-05T16:00:00.000Z","updated":"2024-08-26T14:57:40.023Z","comments":true,"path":"p/leetcode/day63/","permalink":"https://krystencollins.github.io/p/leetcode/day63/","excerpt":"","text":"860. 柠檬水找零题目描述：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例：示例 1： 1234567输入：bills = [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 1234567输入：bills = [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 1 &lt;= bills.length &lt;= 105 bills[i] 不是 5 就是 10 或是 20 题解：贪心策略局部最优：遇到20美元，优先消耗10美元找零； 全局最优：完成全部账单找零 方法一：长度为3的数组分别记录5美元、10美元、20美元的数量 12345678910111213141516171819202122232425262728class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; if (bills[0] != 5) return false; vector&lt;int&gt; vec(3, 0); for (int i = 0; i &lt; bills.size(); ++i) &#123; if (bills[i] == 5) &#123; vec[0]++; &#125; else if (bills[i] == 10) &#123; if (vec[0] &gt;= 1) &#123; vec[0]--; vec[1]++; &#125; else return false; &#125; else if (bills[i] == 20) &#123; if (vec[1] &gt;= 1 &amp;&amp; vec[0] &gt;= 1) &#123; vec[2]++; vec[1]--; vec[0]--; &#125; else if (vec[0] &gt;= 3) &#123; vec[2]++; vec[0] = vec[0] - 3; &#125; else return false; &#125; &#125; return true; &#125;&#125;; 代码优化：只使用两个变量分别记录5美元、10美元的数量，20美元数没必要记录，因为不使用它来找零 1234567891011121314151617181920212223242526class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; int five = 0; int ten = 0; for (int i = 0; i &lt; bills.size(); ++i) &#123; if (bills[i] == 5) ++five; if (bills[i] == 10) &#123; if (five &gt; 0) &#123; ++ten; --five; &#125; else return false; &#125; if (bills[i] == 20) &#123; if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; --ten; --five; &#125; else if (five &gt;= 3) five -= 3; else return false; &#125; &#125; return true; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"分发糖果","slug":"p/leetcode/day62","date":"2024-06-04T16:00:00.000Z","updated":"2024-08-26T14:58:03.632Z","comments":true,"path":"p/leetcode/day62/","permalink":"https://krystencollins.github.io/p/leetcode/day62/","excerpt":"","text":"135. 分发糖果题目描述：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例：示例 1： 123输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 1234输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= ratings[i] &lt;= 2 * 104 题解：贪心算法首先确定一边之后再确定另一边：先比较每一个孩子左边再比较每一个孩子右边，两边一起考虑一定会顾此失彼 右边评分大于左边评分：（从前往后遍历） 局部最优：只要右边评分比左边评分大，右边孩子就比左边多一个糖果 全局最优：相邻孩子中，评分高的右孩子比左边孩子得到更多糖果 左边评分大于左边评分：（一定从后往前遍历，因为确定左边孩子糖果数需要用到右边数据） 局部最优：只要左边评分比右边评分高，并且已经获得糖果数未比右边多，左边孩子就比右边多一个糖果 全局最优：两两相邻孩子评分更高得孩子获得更多糖果 12345678910111213141516171819202122class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); vector&lt;int&gt; candys(size, 1); // 从前往后 for (int i = 1; i &lt; size; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candys[i] = candys[i - 1] + 1; &#125; &#125; // 从后往前 for (int i = size - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1] &amp;&amp; candys[i] &lt;= candys[i + 1]) &#123; candys[i] = candys[i + 1] + 1; &#125; &#125; // 统计结果 int sum = accumulate(candys.begin(), candys.end(), 0); return sum; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 常数空间遍历？？？","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"加油站","slug":"p/leetcode/day61","date":"2024-06-03T16:00:00.000Z","updated":"2024-08-26T14:57:21.789Z","comments":true,"path":"p/leetcode/day61/","permalink":"https://krystencollins.github.io/p/leetcode/day61/","excerpt":"","text":"134. 加油站题目描述：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例：示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 123456789输入: gas = [2,3,4], cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 提示: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 题解：暴力法思维陷阱：是否“断油” 和 是否绕环路一周 分开判断，若一圈后 油量有剩余，则陷入死循环 必须同时判断是否“断油” 和 绕环路一周 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); for (int i = 0; i &lt; n; ++i) &#123; int rest = gas[i] - cost[i]; // 剩余油量 int index = (i + 1) % n; // 模拟以i为起点行驶一周 while (rest &gt; 0 &amp;&amp; index != i) &#123; rest += gas[index] + -cost[index]; index = (index + 1) % n; &#125; // 绕环路行驶一周后，回到起点 if (rest &gt;= 0 &amp;&amp; index == i) return i; &#125; return -1; &#125;&#125;; 时间复杂度：O(n^2) 空间复杂度：O(1) 贪心算法方法一：全局贪心选择 若gas总和&lt;cost总和，无论从哪出发一定跑不了一圈 每天剩余油量rest[i] &#x3D; gas[i] - cost[i]，若从索引0开始累加每天剩余油量到最后一站，累加过程没有出现负数，说明从0出发，油没有断过，则0为起点 若累加过程中出现的最小值为负数，说明索引0不是起点，则从后往前，看那个节点能把这个负数填平，能把这个负数填平的节点为出发节点（因为从0出发说明初始油量为0，而从0出发会有累加剩余油量为负，即油量不够；从后往前，就是将剩余油量累计都索引0，相当于从0出发时 初始油量 不为0！） 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int curSum = 0; int minSum = INT_MAX; // 从索引0出发，剩余油量累加过程中出现的最小值 for (int i = 0; i &lt; gas.size(); ++i) &#123; curSum += gas[i] - cost[i]; minSum = min(curSum, minSum); &#125; if (curSum &lt; 0) return -1; if (minSum &gt;= 0) return 0; for (int i = gas.size() - 1; i &gt;= 0; --i) &#123; minSum += gas[i] - cost[i]; if (minSum &gt;= 0) return i; &#125; return -1; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 方法二：i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。 局部最优：当前rest[i]累加和curSum一旦小于0，起始位置至少要从 i+1 开始，因为i之前开始一定不行 全局最优：找到可以跑一圈的位置 如果 curSum&lt;0 说明 区间和1 + 区间和2 &lt; 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2&gt;0。 区间和1 + 区间和2 &lt; 0 同时 区间和2&gt;0，只能说明区间和1 &lt; 0， 那么就会从假设的箭头初就开始从新选择其实位置了。 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int curSum = 0; int totalSum = 0; int start = 0; for (int i = 0; i &lt; gas.size(); ++i) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; // 当前rest[i]累加和 curSum小于0 start = i + 1; // 更新起始位置 curSum = 0; // 重置curSum &#125; &#125; if (totalSum &lt; 0) return -1; return start; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 2099. 找到和最大的长度为 K 的子序列题目描述：给你一个整数数组 nums 和一个整数 k 。你需要找到 nums 中长度为 k 的 子序列 ，且这个子序列的 和最大 。 请你返回 任意 一个长度为 k 的整数子序列。 子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。 示例：示例 1： 1234输入：nums = [2,1,3,3], k = 2输出：[3,3]解释：子序列有最大和：3 + 3 = 6 。 示例 2： 1234输入：nums = [-1,-2,3,4], k = 3输出：[-1,3,4]解释：子序列有最大和：-1 + 3 + 4 = 6 。 示例 3： 12345输入：nums = [3,4,3,3], k = 2输出：[3,4]解释：子序列有最大和：3 + 4 = 7 。另一个可行的子序列为 [4, 3] 。 提示： 1 &lt;= nums.length &lt;= 1000 -105 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= nums.length 题解：排序先对数值进行降序排序，再对前K个元素的索引进行升序排序 在维护索引的同时对数组进行排序？ 使用“哈希表”，构造排序仿函数 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: class cmp1 &#123; public: bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.second &gt; b.second; &#125; &#125;; class cmp2 &#123; public: bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.first &lt; b.first; &#125; &#125;; vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;pair&lt;int, int&gt;&gt; vals; for (int i = 0; i &lt; nums.size(); ++i) &#123; vals.push_back(pair&lt;int, int&gt; (i, nums[i])); &#125; // 按照数值降序排序 sort(vals.begin(), vals.end(), cmp1()); // 取前k个元素按照下标升序排序 sort(vals.begin(), vals.begin() + k, cmp2()); vector&lt;int&gt; ans; for (int i = 0; i &lt; k; ++i) &#123; ans.push_back(vals[i].second); &#125; return ans; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"","slug":"p/leetcode/day60","date":"2024-06-02T16:00:00.000Z","updated":"2024-06-04T03:10:16.528Z","comments":true,"path":"p/leetcode/day60/","permalink":"https://krystencollins.github.io/p/leetcode/day60/","excerpt":"","text":"1005. K 次取反后最大化的数组和题目描述：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例：示例 1： 123输入：nums = [4,2,3], k = 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2： 123输入：nums = [3,-1,0,2], k = 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3： 123输入：nums = [2,-3,-1,5,-4], k = 2输出：13解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104 题解：暴力法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123; // 从小到大排序 sort(nums.begin(), nums.end()); int index = 0; int sum = 0; // 每遇到一个负数取反一次。注意：index&lt;nums.size()判断条件必须放到前面 while (index &lt; nums.size() &amp;&amp; nums[index] &lt; 0 &amp;&amp; k &gt; 0) &#123; nums[index] = -nums[index]; sum += nums[index]; ++index; --k; &#125; // 所有负数都变正了，k还大于0，取绝对值最小的数进行取反 if (k != 0) &#123; // 还需要取反 齐次数 if (k % 2 == 1) &#123; // 数组未遍历完并且不是第一个元素 if (index &gt; 0 &amp;&amp; index &lt; nums.size()) &#123; sum -= nums[index - 1]; // sum先减掉index前一个元素 // 取绝对值小的取反 if (nums[index - 1] &lt; nums[index]) &#123; sum += -nums[index - 1] + nums[index]; &#125; else &#123; sum += -nums[index] + nums[index - 1]; &#125; &#125; else if (index == 0)&#123; //index为0说明原数组全部非负 sum -= nums[index]; &#125; else if (index == nums.size()) &#123; // index为原数组大小说明全部非正，之前已经 取正累加和，因此减掉2倍 sum -= nums[index - 1] * 2; &#125; &#125; else if(index &lt; nums.size()) &#123; // 还需要取反 偶次数。若index未越界直接累加，否则不做处理 sum += nums[index]; &#125; ++index; // index指向元素已经考虑 &#125; // 累加剩下非负数（若存在） while (index &lt; nums.size()) &#123; sum += nums[index]; ++index; &#125; return sum; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1) 贪心算法两次贪心： 1）局部最优：让绝对值大的负数变为正数，当前数值达到最大； ​ 整体最优：整个数组和达到最大 若所有负数都转变为正数了，k依然大于0，如何转变k次正负让数组和达到最大？ 2）局部最优：找到数值最小的正整数进行反转 ​ 整体最优：整个数组和达到最大 123456789101112131415161718192021222324252627class Solution &#123;public: class cmp &#123; public: bool operator()(int a, int b) &#123; return abs(a) &gt; abs(b); &#125; &#125;; int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123; // 按 绝对值大小 从大到小排序 sort(nums.begin(), nums.end(), cmp()); // 从前向后遍历，每遇到一个负数取反一次，同时k-- for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; 0 &amp;&amp; k &gt; 0) &#123; nums[i] *= -1; --k; &#125; &#125; // 若k还大于0，反复取反数值最小的数，将k用完 if (k % 2 == 1) nums[nums.size() - 1] *= -1; // 求和 int result = 0; for (int i = 0; i &lt; nums.size(); ++i) result += nums[i]; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day59","date":"2024-05-30T16:00:00.000Z","updated":"2024-06-03T07:28:17.989Z","comments":true,"path":"p/leetcode/day59/","permalink":"https://krystencollins.github.io/p/leetcode/day59/","excerpt":"","text":"55. 跳跃游戏题目描述：给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例：示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 105 题解：暴力法判断是否可以跳过数组中出现的0 123456789101112131415161718192021222324class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); // 统计数组中出现的0的下标，数组最后一个元素不论大小都不需要统计 vector&lt;int&gt; zeroIdx; for (int i = 0; i &lt; size - 1; ++i) &#123; if (nums[i] == 0) zeroIdx.push_back(i); &#125; // 对于每一个0，判断是否可以跳过： // 每一个0之前的元素大小nums[j]大于 与当前0的距离，并且nums[j]不为0，则可以跳过， // 只要找到一个元素可以跳过即退出循环 // 否则，当前0之前没有一个元素大小 使其 可以跳过，则一定不可到达最后一个下标 for (int i = 0; i &lt; zeroIdx.size(); ++i) &#123; int j = zeroIdx[i] - 1; while (j &gt;= 0) &#123; if (zeroIdx[i] - j &lt; nums[j] &amp;&amp; nums[j] != 0) break; --j; &#125; if (j &lt; 0) return false; &#125; return true; &#125;&#125;; 时间复杂度：O(n^2) 空间复杂度：O(1) 贪心算法每次移动取最大跳跃步数（得到最大的覆盖范围），每次移动一个单位，更新最大覆盖范围 局部最优：每次取最大跳跃步数 全局最优：最后得到的整体最大覆盖范围，判断是否能到终点 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int cover = 0; for (int i = 0; i &lt;= cover; ++i) &#123; // 注意这里i小于等于cover cover = max(i + nums[i], cover); // 每次更新当前可以覆盖的最大覆盖范围 if (i == nums.size() - 1) return true; // 可到达终点，返回true &#125; return false; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 小优化： 123456789101112class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int cover = 0; for (int i = 0; i &lt;= cover; ++i) &#123; cover = max(i + nums[i], cover); // 当cover大于等于终点时，即说明可以到达终点！！ if (cover &gt;= nums.size() - 1) return true; &#125; return false; &#125;&#125;; 45. 跳跃游戏 II题目描述：给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 &lt;= j &lt;= nums[i] i + j &lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 示例：示例 1: 1234输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 12输入: nums = [2,3,0,1,4]输出: 2 提示: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 题目保证可以到达 nums[n-1] 题解：贪心算法关键点：什么时候步数才一定要加1 从覆盖范围出发，不管怎么跳，覆盖范围一定可以跳到，以最小步数增加覆盖范围，覆盖范围一旦覆盖了终点即得到最小步数 维护两个变量：当前这一步最大覆盖范围和下一步最大覆盖范围 每一步尽可能多走，若移动下标到达当前这一步最大覆盖最远距离，还没有到达终点，必须再走下一步来增加覆盖范围。那么，下一步覆盖范围是多少？在遍历过程中，同时更新下一步最远覆盖距离！！ 1234567891011121314151617181920class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int curDistance = 0; // 当前覆盖最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖最远距离下标 for (int i = 0; i &lt; nums.size() - 1; i++) &#123; // 更新下一步覆盖最远距离下标 nextDistance = max(nums[i] + i, nextDistance); // 遇到当前覆盖最远距离下标 if (i == curDistance) &#123; ans++; // 需要走下一步 curDistance = nextDistance; // 更新当前覆盖最远距离下标 // 当前覆盖最远距到达集合终点，直接结束 if (nextDistance &gt;= nums.size() - 1) break; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day58","date":"2024-05-29T16:00:00.000Z","updated":"2024-06-03T06:30:52.623Z","comments":true,"path":"p/leetcode/day58/","permalink":"https://krystencollins.github.io/p/leetcode/day58/","excerpt":"","text":"697. 数组的度题目描述：给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例：示例 1： 1234567输入：nums = [1,2,2,3,1]输出：2解释：输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。连续子数组里面拥有相同度的有如下所示：[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。 示例 2： 12345输入：nums = [1,2,2,3,1,4,2]输出：6解释：数组的度是 3 ，因为元素 2 重复出现 3 次。所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。 提示： nums.length 在 1 到 50,000 范围内。 nums[i] 是一个在 0 到 49,999 范围内的整数。 题解哈希表12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; // 哈希表：统计nums元素的频数，key数组元素，value出现频数 unordered_map&lt;int, int&gt; umap; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (!umap.count(nums[i])) umap[nums[i]] = 1; else ++umap[nums[i]]; &#125; // 求nums的众数：可能众数不止一个 vector&lt;int&gt; ans; int count = umap.begin()-&gt;second; // 记录可能最大频数 ans.push_back(umap.begin()-&gt;first); for (unordered_map&lt;int, int&gt;::iterator it = umap.begin(); it != umap.end(); ++it) &#123; if (it-&gt;second == count) &#123; // 频数相同，加入ans ans.push_back(it-&gt;first); &#125; else if (it-&gt;second &gt; count) &#123; // 频数更大，说明ans中的不是众数，清空，重置 ans.clear(); ans.push_back(it-&gt;first); count = it-&gt;second; &#125; &#125; // 对于每个众数，在原数组中找到第一个元素和最后一个元素，并比较最短连续子数组的长度 int result = nums.size(); for (int i = 0; i &lt; ans.size(); ++i) &#123; int pre = 0, last = nums.size() - 1; for (int j = 0; j &lt; nums.size(); ++j) &#123; if (nums[j] == ans[i]) &#123; pre = j; break; &#125; &#125; for (int j = last; j &gt;= 0; --j) &#123; if (nums[j] == ans[i]) &#123; last = j; break; &#125; &#125; result = min(last - pre + 1, result); // 取连续子数组长度的最小值 &#125; return result; &#125;&#125;; 时间复杂度：O(n)，？？ 空间复杂度：O(n) 代码优化： 哈希表每个数映射一个长度为3的数组：这个数出现的次数、在原数组中第一次出现的位置、在原数组最后一次出现的位置 1234567891011121314151617181920212223242526class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, vector&lt;int&gt;&gt; mp; int n = nums.size(); for (int i = 0; i &lt; nums.size(); ++i) &#123; // 哈希表中已有nums[i]，频数+1，更新最后一次出现的位置 if (mp.count(nums[i])) &#123; mp[nums[i]][0]++; mp[nums[i]][2] = i; &#125; else &#123; mp[nums[i]] = &#123;1, i, i&#125;; &#125; &#125; int maxNum = 0, minLen = 0; for (auto&amp; [_, vec] :mp) &#123; if (maxNum &lt; vec[0]) &#123; maxNum = vec[0]; minLen = vec[2] - vec[1] + 1; &#125; else if (maxNum == vec[0]) &#123; // 遇到具有相同频数的元素，取最短连续子数组 minLen = min(vec[2] - vec[1] + 1, minLen); &#125; &#125; return minLen; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"买卖股票的最佳时机","slug":"p/leetcode/day57","date":"2024-05-28T16:00:00.000Z","updated":"2024-07-20T07:10:02.919Z","comments":true,"path":"p/leetcode/day57/","permalink":"https://krystencollins.github.io/p/leetcode/day57/","excerpt":"","text":"121. 买卖股票的最佳时机题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例：示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104**** 题解：用一个变量记录历史最低价格minprice，假设自己的股票是在那天买的，在第i天卖出股票得到的利润为prices[i]-minprice。同时更新最大利润！！ 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int inf = 1e9; // 模拟无穷大 int minprice = inf; // 初始化历史最低价格为无穷大 int maxprofit = 0; // 初始化最大利润为0 for (int i = 0; i &lt; prices.size(); ++i) &#123; // 更新最大利润：假设在历史最低价格买入，在当前价格卖出 maxprofit = max(maxprofit, prices[i] - minprice); // 更新历史最低价 minprice = min(minprice, prices[i]); &#125; return maxprofit; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 动态规划 确定dp数组以及下标含义： dp[i][0]表示第i天持有股票所得最多现金，持有不是买入 dp[i][1]表示第i天不持有股票所得最多现金 递推公式 dp数组初始化 dp[0][0] = -prices[0] dp[0][1] = 0 遍历顺序：从前往后遍历 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) &#123; dp[i][0] = max(dp[i - 1][0], -prices[i]); dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); &#125; return dp[len - 1][1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(2)); // 注意这里只开辟了一个2 * 2大小的二维数组 dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; i++) &#123; dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]); dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]); &#125; return dp[(len - 1) % 2][1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 122. 买卖股票的最佳时机 II题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例：示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 题解：贪心算法把利润分解为以每天为单位的维度，而不是整体去考虑 局部最优：收集每天的正利润 全局最优：求得最大利润 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int result = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; if (prices[i] &gt; prices[i - 1]) &#123; result += prices[i] - prices[i - 1]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 小优化： 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int result = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; result += max(prices[i] - prices[i - 1], 0); &#125; &#125; return result;&#125;; 动态规划1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; len; ++i) &#123; dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]); &#125; return dp[len - 1][1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(2, vector&lt;int&gt;(2, 0)); dp[0][0] -= prices[0]; // 0表示持有 dp[0][1] = 0; // 1表示卖出 for (int i = 1; i &lt; len; ++i) &#123; // 前一天持有；不限制交易次数，再次买股票时，加上之前的收益 dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]); // 前一天卖出；或当天卖出，当天卖出得先持有 dp[i % 2][1] = max(dp[(i - 1) % 2][1], dp[(i - 1) % 2][0] + prices[i]); &#125; return dp[(len - 1) % 2][1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 继续优化：空间只需两个变量 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int first = -prices[0]; // 持有 int second = 0; // 卖出 for (int i = 1; i &lt; prices.size(); ++i) &#123; // 前一天持有；不限制交易次数，再次买入时需要加上之前的收益 first = max(first, second - prices[i]); // 前一天卖出；或当天卖出，那么当天卖出得先持有 second = max(second, first + prices[i]); &#125; return second; &#125;&#125;; 123. 买卖股票的最佳时机 III题目描述：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例：示例 1: 1234输入：prices = [3,3,5,0,0,3,1,4]输出：6解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 12345输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 123输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 12输入：prices = [1]输出：0 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 105 题解：动态规划 dp数组以及下标含义：dp[i][j]表示第i天状态j下所剩最大现金 j有四种状态： 1 第一次持有股票 2 第一次卖出股票 3 第二次持有股票 4 第二次卖出股票 递推公式 1234567891011// 第i天 第一次持有股票状态下：前一天就持有；第i天买入（之前利润为0）dp[i][1] = max(dp[i-1][1], -prices[i]);// 第i天 第一次卖出股票状态下：前一天就卖出；第i天卖出，等于前一天 持有 价格加上 第i天股票价格dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);// 第i天 第二次持有股票状态下：前一天就第二次持有；第i天第二次买入，之前利润为dp[i-1][2]前一天卖出所得dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);// 第i天 第二次卖出股票状态下：前一天就第二吃卖出；第i天第二次卖出，前一天第二次持有 加上 第i天股票价格dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]); dp数组初始化： 1234dp[0][1] = -prices[0];dp[0][2] = 0; // 在第0天先买入再卖出dp[0][3] = -prices[0]; // 在第0天：买入卖出（第一次完成），第二次买入dp[0][4] = 0; // 第0天买入卖出两次 完整代码： 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(5, 0)); dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for (int i = 1; i &lt; len; ++i) &#123; dp[i][1] = max(dp[i - 1][1], -prices[i]); dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]); dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]); dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]); &#125; return dp[len - 1][4]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(4, 0); dp[0] = -prices[0]; dp[2] = -prices[0]; for (int i = 1; i &lt; prices.size(); ++i) &#123; dp[0] = max(dp[0], -prices[i]); dp[1] = max(dp[1], dp[0] + prices[i]); dp[2] = max(dp[2], dp[1] - prices[i]); dp[3] = max(dp[3], dp[2] + prices[i]); &#125; return dp[3]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 188. 买卖股票的最佳时机 IV题目描述：给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例：示例 1： 123输入：k = 2, prices = [2,4,1]输出：2解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 1234输入：k = 2, prices = [3,2,6,5,0,3]输出：7解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 1 &lt;= k &lt;= 100 1 &lt;= prices.length &lt;= 1000 0 &lt;= prices[i] &lt;= 1000 题解：动态规划123456789101112131415class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; dp(2 * k, 0); for (int j = 0; j &lt; k; ++j) dp[j * 2] = -prices[0]; for (int i = 1; i &lt; prices.size(); ++i) &#123; for (int j = 0; j &lt; k; ++j) &#123; if (j == 0) dp[j] = max(dp[j], -prices[i]); else dp[j * 2] = max(dp[j * 2], dp[j * 2 - 1] - prices[i]); dp[j * 2 + 1] = max(dp[j * 2 + 1], dp[j * 2] + prices[i]); &#125; &#125; return dp[2 * k - 1]; &#125;&#125;; 时间复杂度：O(n * k) 空间复杂度：O(k)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"最大子数组和","slug":"p/leetcode/day56","date":"2024-05-27T16:00:00.000Z","updated":"2024-07-25T04:50:26.420Z","comments":true,"path":"p/leetcode/day56/","permalink":"https://krystencollins.github.io/p/leetcode/day56/","excerpt":"","text":"53. 最大子数组和题目描述：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 示例：示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 题解：贪心算法123456789101112131415class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int result = INT_MIN; int sum = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum += nums[i]; // 取区间累计的最大值，相当于不断确定最大子序列终止位置 result = sum &gt; result ? sum : result; // 重置最大子序列起始位置，因为遇到总和为负数了 后续一定拉低总和 if (sum &lt;= 0) sum = 0; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示以nums[i]结尾的连续子数组的最大和 2. 递推公式：dp[i] = max(dp[i-1] + nums[i], nums[i]), 即nums[i]之前的最大和为正数即可连续，否则从头开始 3. 初始化： dp[0] = nums[0] 4. 遍历顺序： 从前往后 5. 举例推导dp数组： */ int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(), 0); int result = nums[0]; dp[0] = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) &#123; dp[i] = max(dp[i - 1] + nums[i], nums[i]); result = max(result, dp[i]); &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 分治法1// 待定","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"","slug":"p/leetcode/day55","date":"2024-05-26T16:00:00.000Z","updated":"2024-05-28T06:47:10.466Z","comments":true,"path":"p/leetcode/day55/","permalink":"https://krystencollins.github.io/p/leetcode/day55/","excerpt":"","text":"贪心算法解题步骤： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解推叠成全局最优解 想清楚 局部最优是什么？如何推出全局最优？ 455. 分发饼干题目描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例：示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 题解：方法一局部最优：大饼干喂给大胃口的， 全局最优：喂饱尽可能多的小孩 12345678910111213141516class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int result = 0; // 遍历胃口 for (int i = g.size() - 1, index = s.size() - 1; i &gt;= 0 &amp;&amp; index &gt;= 0; --i) &#123; if (s[index] &gt;= g[i]) &#123; // 相当于遍历饼干 ++result; --index; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1) 方法二小饼干先喂饱小胃口 123456789101112131415class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = 0; // 遍历饼干 for (int i = 0; i &lt; s.size() &amp;&amp; index &lt; g.size(); ++i) &#123; if (g[index] &lt;= s[i]) &#123; // 相当于遍历胃口 ++index; &#125; &#125; return index; &#125;&#125;; 376. 摆动序列题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例：示例 1： 123输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 1234输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 12输入：nums = [1,2,3,4,5,6,7,8,9]输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 进阶：你能否用 O(n) 时间复杂度完成此题? 题解：贪心算法12345678910111213141516171819class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); int curDiff = 0; // 当前一对差值 int preDiff = 0; // 前一对差值 int result = 1; // 初始化为1 for (int i = 0; i &lt; nums.size() - 1; ++i) &#123; curDiff = nums[i + 1] - nums[i]; // 先 非递增 再严格递增； 先 非递减 再严格递减 // 即 只要出现平坡都只计算最后一个相等数值 if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) &#123; ++result; preDiff = curDiff; // 只要摆动变化了就更新preDiff &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 动态规划1","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day54","date":"2024-05-25T16:00:00.000Z","updated":"2024-05-27T12:00:09.974Z","comments":true,"path":"p/leetcode/day54/","permalink":"https://krystencollins.github.io/p/leetcode/day54/","excerpt":"","text":"332. 重新安排行程题目描述：给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例：示例 1： 12输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;] 示例 2： 123输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。 提示： 1 &lt;= tickets.length &lt;= 300 tickets[i].length == 2 fromi.length == 3 toi.length == 3 fromi 和 toi 由大写英文字母组成 fromi != toi 题解：详细思路 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // unordered_map&lt;出发机场，map&lt;到达机场，航班次数&gt;&gt; target unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) &#123; if (result.size() == ticketNum + 1) &#123; return true; &#125; for (pair&lt;const string, int&gt;&amp; target :targets[result.back()]) &#123; if (target.second &gt; 0) &#123; // 记录到达机场是否飞过了 result.push_back(target.first); --target.second; if (backtracking(ticketNum, result)) return true; ++target.second; result.pop_back(); &#125; &#125; return false; &#125; vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123; targets.clear(); vector&lt;string&gt; result; for (const vector&lt;string&gt;&amp; vec : tickets) &#123; targets[vec[0]][vec[1]]++; // 记录映射关系 &#125; result.push_back(&quot;JFK&quot;); // 起始机场 backtracking(tickets.size(), result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day53","date":"2024-05-17T16:00:00.000Z","updated":"2024-05-19T08:54:28.537Z","comments":true,"path":"p/leetcode/day53/","permalink":"https://krystencollins.github.io/p/leetcode/day53/","excerpt":"","text":"46. 全排列题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例：示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 题解：回溯 排列：每个节点都从0开始遍历 去重，横向纵向同时进行，”哈希表“为“全局变量”，需要做回溯 结果，在叶子节点收集 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int used[21] = &#123;0&#125;; // 数组作哈希表（题目给出数组范围[-10, 10]） void backtracking(vector&lt;int&gt; nums) &#123; // 当path长度等于nums长度，已遍历完一遍nums if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; // 每个节点都从0开始遍历 for (int i = 0; i &lt; nums.size(); ++i) &#123; // 去重（包含横向纵向），若当前层已使用 或 根节点到该节点路径上已使用，跳过（而不是退出） if (used[nums[i] + 10] == 1) continue; used[nums[i] + 10] = 1; // 记录已使用 path.push_back(nums[i]); backtracking(nums); // 递归 used[nums[i] + 10] = 0; // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums); return result; &#125;&#125;; 时间复杂度：O(n!) 空间复杂度：O(n) 优化，”哈希表“只开辟 当前数组长度 的大小，但需要使用引用 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (used[i] == 1) continue; used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;; 47. 全排列 II题目描述：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例：示例 1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 示例 2： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 题解：回溯 横向去重和纵向去重分别进行 数组used纵向去重，需要回溯 数组uset横向去重，不需要回溯，非排序，相同值元素出现位置可能不连续 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; int uset[21] = &#123;0&#125;; // 题目给定数组范围[-10, 10], for (int i = 0; i &lt; nums.size(); ++i) &#123; if (uset[nums[i] + 10] == 1 || used[i] == 1) continue; uset[nums[i] + 10] = 1; // 不需要回溯 used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;; 时间复杂度：O(n * n!) 空间复杂度：O(n) 排序+回溯 横向去重：先排序，使用数组下标和used数组配合 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; // 前半部分：横向去重，必须有used[i - 1] == 0，说明同一层used[i-1]使用过（已回溯为0） // used[i - 1] == 1说明同一树枝used[i-1]使用过，另一种思路，“树更茂盛” // 后半部分：纵向去重 if ((i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0) || used[i] == 1) continue; used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); // 排序 vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"非递减子序列","slug":"p/leetcode/day52","date":"2024-05-16T16:00:00.000Z","updated":"2024-05-19T07:23:02.196Z","comments":true,"path":"p/leetcode/day52/","permalink":"https://krystencollins.github.io/p/leetcode/day52/","excerpt":"","text":"491. 非递减子序列题目描述：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 示例：示例 1： 12输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2： 12输入：nums = [4,4,3,2,1]输出：[[4,4]] 提示： 1 &lt;= nums.length &lt;= 15 -100 &lt;= nums[i] &lt;= 100 题解：回溯，哈希表横向去重 不能先排序，因为排序后整个数组即非递减 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; // 可省略 unordered_set&lt;int&gt; uset; // 横向去重：哈希表记录当前层已遍历相同值元素 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; // 哈希表若已存在相同值元素，直接跳过，而不是break退出循环 if (uset.count(nums[i])) continue; uset.insert(nums[i]); // 错误去重，未排序数组，同一层 相同值元素位置可能不连续！！ // if (i &gt; startIdx &amp;&amp; nums[i] == nums[i - 1]) continue; int size = path.size(); // 判断是否非递减 if (size != 0 &amp;&amp; nums[i] &lt; path[size - 1]) continue; path.push_back(nums[i]); // 至少两个元素构成一个结果。在搜索树中的每一个节点收集结果，而不是叶子节点收集 if (size != 0) result.push_back(path); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n) 代码优化，使用数组作为哈希表 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (path.size() &gt; 1) result.push_back(path); int used[201] = &#123;0&#125;; // 题目给出数组范围[-] for (int i = startIdx; i &lt; nums.size(); ++i) &#123; if (used[nums[i] + 100] == 1 || (!path.empty() &amp;&amp; nums[i] &lt; path.back())) continue; used[nums[i] + 100] = 1; path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day51","date":"2024-05-15T16:00:00.000Z","updated":"2024-05-19T09:10:28.289Z","comments":true,"path":"p/leetcode/day51/","permalink":"https://krystencollins.github.io/p/leetcode/day51/","excerpt":"","text":"78. 子集题目描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例：示例 1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 题解：定义法将新元素 分别插入原幂集每一个子集中 循环+递归： 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; int size = result.size(); // 提取记录当前result大小，因为循环过程中不断变化 for (int i = 0; i &lt; size; ++i) &#123; vector&lt;int&gt; path = result[i]; // 取出上一层result所有子集 path.push_back(nums[startIdx]); // 在末尾追加当前遍历元素nums[startidx] result.push_back(path); // 插入到result中 &#125; backtracking(nums, startIdx + 1); // 下一层，递归遍历nums[startIdx+1] &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 优化，双重循环 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result = &#123;&#123;&#125;&#125;; for (int i = 0; i &lt; nums.size(); ++i) &#123; int size = result.size(); for (int j = 0; j &lt; size; ++j) &#123; vector&lt;int&gt; path = result[j]; path.push_back(nums[i]); result.push_back(path); &#125; &#125; return result; &#125;&#125;; 回溯1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; // startIdx遍历位置为nums长度时，已遍历完 if (startIdx == nums.size()) return; // 可省略 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; path.push_back(nums[i]); result.push_back(path); // 搜索树每个节点都收集中间结果，而不是叶子节点再收集 backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 90. 子集 II题目描述：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例：示例 1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 题解：回溯排序，横向去重 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; // 可省略 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; // 横向去重：若遇到已经遍历的相同值元素，跳过，而不是直接退出，因为后续可能还有其他值元素 if (i &gt; startIdx &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); result.push_back(path); // 在搜素中的每个节点收集中间结果，而不是叶子节点 backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); // 去重，先排序 result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n) 哈希表去重使用哈希表横向去重，也必须优先排序，因为递归的时候下一个startIdx是i+1而不是0（即相同值位置不连续，每个节点从startIdx开始遍历，未排序的话就无法真正去重） 因此本题哈希表作用不明显，可直接使用下标去重 若为全排列，每次从0开始遍历，使用哈希表去重作用明显 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; unordered_set&lt;int&gt; uset; for (int i = startIdx; i &lt; nums.size(); ++i) &#123; if (uset.count(nums[i])) continue; uset.insert(nums[i]); path.push_back(nums[i]); result.push_back(path); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day50","date":"2024-05-14T16:00:00.000Z","updated":"2024-05-19T05:43:17.145Z","comments":true,"path":"p/leetcode/day50/","permalink":"https://krystencollins.github.io/p/leetcode/day50/","excerpt":"","text":"131. 分割回文串题目描述：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 示例：示例 1： 12输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 示例 2： 12输入：s = &quot;a&quot;输出：[[&quot;a&quot;]] 提示： 1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成 题解：回溯12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 判断是否为回文串 bool isPalindrome(string subStr) &#123; int size = subStr.size(); for (int i = 0, j = size - 1; i &lt; size / 2; ++i, --j) &#123; if (subStr[i] != subStr[j]) return false; &#125; return true; &#125; void backtracking(string s, int startIdx) &#123; if (startIdx == s.size()) &#123;// 当分割开始下标为s长度时，已分割完 result.push_back(path); return; &#125; // startIdx记录每个节点集合开始遍历的下标，n记录子串长度， for (int i = startIdx, n = 1; i &lt; s.size(); ++i, ++n) &#123; string subStr = s.substr(startIdx, n); // 横向：每次从startIdx开始取n个字符 if (!isPalindrome(subStr)) continue; // 遇到子串为 非回文串，必须continue，后续子串可能构成回文 path.push_back(subStr); // 处理 backtracking(s, i + 1); // 递归，i+1不可重复使用字符 path.pop_back(); // 回溯 &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; backtracking(s, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2*n) 空间复杂度：O(n) 动态规划+回溯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 vector&lt;vector&lt;bool&gt;&gt; isPalindrome; // 放事先计算好的是否回文子串的结果 void backtracking (const string&amp; s, int startIndex) &#123; // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) &#123; result.push_back(path); return; &#125; for (int i = startIndex; i &lt; s.size(); i++) &#123; if (isPalindrome[startIndex][i]) &#123; // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); &#125; else &#123; // 不是回文，跳过 continue; &#125; backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 &#125; &#125; // 动态规划：计算子串是否为回文串 void computePalindrome(const string&amp; s) &#123; // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小 for (int i = s.size() - 1; i &gt;= 0; i--) &#123; // 需要倒序计算, 保证在i行时, i+1行已经计算好了 for (int j = i; j &lt; s.size(); j++) &#123; if (j == i) &#123;isPalindrome[i][j] = true;&#125; else if (j - i == 1) &#123;isPalindrome[i][j] = (s[i] == s[j]);&#125; else &#123;isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125; &#125; &#125; &#125; public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; result.clear(); path.clear(); computePalindrome(s); backtracking(s, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n^2) 93. 复原 IP 地址题目描述：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#39;.&#39; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例：示例 1： 12输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] 示例 2： 12输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;] 示例 3： 12输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;] 提示： 1 &lt;= s.length &lt;= 20 s 仅由数字组成 题解：回溯123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;string&gt; result; string path; // 判断子串ip是否有效 bool isValid(string subStr) &#123; // 含有前导0，无效 if (subStr.size() &gt; 1 &amp;&amp; subStr[0] == &#x27;0&#x27;) return false; int num = atoi(subStr.c_str()); // string转int型 if (num &lt; 0 || num &gt; 255) return false; return true; &#125; // startIdx记录遍历起始位置，depth记录树深度（即分割次数，子串数量） void backtracking(string s, int startIdx, int depth) &#123; // 起始位置为s大小且刚好分割4次，找到一组有效ip分割方案 if (startIdx == s.size() &amp;&amp; depth == 4) &#123; string ip = path.substr(0, path.size() - 1); // 去掉末尾的&quot;.&quot;，不能改变path，因为在上一层回溯 result.push_back(ip); return; &#125; for (int i = startIdx, n = 1; i &lt; s.size() &amp;&amp; n &lt;= 3; ++i, ++n) &#123; if (depth == 4) return; // 分割4次还未分割完，无效，直接返回 string subStr = s.substr(startIdx, n); // 横向：每次从startIdx开始取n个字符，且最多取三个 if (!isValid(subStr)) return; // 无效子串直接返回，而不是continue，因为该循环内后续一定无效 int size = path.size(); path += subStr + &quot;.&quot;; // 处理：追加子串和ip分隔符&quot;.&quot; backtracking(s, i + 1, depth + 1); // 递归：depth隐藏回溯 path.erase(size, subStr.size() + 1); // 回溯：移除末尾子串和分割符 &#125; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; backtracking(s, 0, 0); return result; &#125;&#125;; 时间复杂度：O(3^4)，ip地址最多包含4个数字，每个数字最多3种可能的分割方式，即搜索树最大深度为4，每个几点最多3个节点 空间复杂度：O(n) 优化，”剪枝“ 根据字符串长度剪枝 不使用path变量，直接在原字符串插入分隔符 单个字符判断是否有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;string&gt; result; // startIdx记录搜索的起始位置，pointNum记录添加分隔符数量 void backtracking(string&amp; s, int startIdx, int pointNum) &#123; if (pointNum == 3) &#123; // 判断第四段子串是否合法，若合法就放进result if (isValid(s, startIdx, s.size() - 1)) result.push_back(s); return; &#125; for (int i = startIdx; i &lt; s.size(); ++i) &#123; // 判断[startIdx, i]这个区间的子串是否合法， if (isValid(s, startIdx, i)) &#123; s.insert(s.begin() + i + 1, &#x27;.&#x27;); // 在i的后面插入一个分隔符 ++pointNum; backtracking(s, i + 2, pointNum); // 递归：插入分隔符后下一个子串的起始位置为i+2 --pointNum; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉分隔符 &#125; else break; //不合符，直接退出本层循环 &#125; &#125; // 判断字符串s在左闭右闭[start, end]区间内，所组成的数字是否合法 bool isValid(string&amp; s, int start, int end) &#123; if (start &gt; end) return false; // 含有前导0 if (s[start] == &#x27;0&#x27; &amp;&amp; start != end) return false; int num = 0; for (int i = start; i &lt;= end; ++i) &#123; // 遇到非数字字符 if (s[i] &gt; &#x27;9&#x27; || s[i] &lt; &#x27;0&#x27;) return false; num = num * 10 + (s[i] - &#x27;0&#x27;); // num大于255非法数字串 if (num &gt; 255) return false; &#125; return true; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; // “剪枝” if (s.size() &lt; 4 || s.size() &gt; 12) return result; backtracking(s, 0, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day49","date":"2024-05-13T16:00:00.000Z","updated":"2024-05-16T13:42:48.083Z","comments":true,"path":"p/leetcode/day49/","permalink":"https://krystencollins.github.io/p/leetcode/day49/","excerpt":"","text":"39. 组合总和题目描述：给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例：示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例 2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 12输入: candidates = [2], target = 1输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 2 &lt;= candidates[i] &lt;= 40 candidates 的所有元素 互不相同 1 &lt;= target &lt;= 40 题解：递归，回溯123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; // 存储中间和 void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (sum &gt; target) return; // 当sum&gt;target，不必再递归 if (sum == target) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt; candidates.size(); ++i) &#123; sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); // 不使用i+1，可重复使用元素 sum -= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(candidates, target, 0); return result; &#125;&#125;; 优化 取消中间和1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int&amp; target, int startIdx) &#123; if (target &lt; 0) return; if (target == 0) &#123; result.push_back(path); return; &#125; // target每次减掉遍历元素， 当target减为0时找到符合条件组合 for (int i = startIdx; i &lt; candidates.size(); ++i) &#123; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(candidates, target, 0); return result; &#125;&#125;; 剪枝优化1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (target == 0) &#123; result.push_back(path); return; &#125; // 剪枝：排序后，当target减为0时不再递归 for (int i = startIdx; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0; ++i) &#123; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); // 不用i+1,可以重复使用元素 target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 剪枝先排序 backtracking(candidates, target, 0); return result; &#125;&#125;; 40. 组合总和 II题目描述：给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例：示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]] 提示: 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 题解：横向剪枝优化123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (sum &gt; target) return; if (sum == target) &#123; result.push_back(path); return; &#125; // 剪枝：已排序，当sum+下一个元素&gt;target不再递归 for (int i = startIdx; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123; // 横向剪枝，在同一个节点的分支不重复取相同 值 的元素 if(i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - 1]) continue; sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i + 1); // 纵向可以取相同值的元素 sum -= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 先排序，利于剪枝 backtracking(candidates, target, 0); return result; &#125;&#125;; 优化，取消中间和123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (target == 0) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0; ++i) &#123; if(i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - 1]) continue; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i + 1); target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0); return result; &#125;&#125;; 216. 组合总和 III题目描述：找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例：示例 1: 12345输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。 示例 2: 1234567输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。 示例 3: 1234输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。 提示: 2 &lt;= k &lt;= 9 1 &lt;= n &lt;= 60 题解：递归，回溯12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(int k, int n, int startIdx) &#123; // 当选择元素已满或sum&gt;n直接返回 if (path.size() &gt; k || sum &gt; n) return; if (path.size() == k &amp;&amp; sum == n) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt;= 9 ; ++i) &#123; sum += i; path.push_back(i); backtracking(k, n, i + 1); sum -= i; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return result; &#125;&#125;; 剪枝优化123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(int k, int n, int startIdx) &#123; if (sum &gt; n) return; // 若sum &gt; n 直接返回 if (path.size() == k) &#123; if (sum == n) result.push_back(path); return; // 若path.size() == k，但 sum != n直接返回 &#125; // 剪枝遍历范围 for (int i = startIdx; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; sum += i; path.push_back(i); backtracking(k, n, i + 1); sum -= i; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day48","date":"2024-05-12T16:00:00.000Z","updated":"2024-05-19T03:33:47.376Z","comments":true,"path":"p/leetcode/day48/","permalink":"https://krystencollins.github.io/p/leetcode/day48/","excerpt":"","text":"回溯回溯算法模板： 123456789101112void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中的元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果; &#125;&#125; 77. 组合题目描述：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 示例：示例 1： 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 示例 2： 12输入：n = 1, k = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= n 题解： 递归，回溯1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件的集合 vector&lt;int&gt; path; // 存放遍历路径 void backtracking(int n, int k, int startIdx) &#123; if (path.size() == k) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt;= n; ++i) &#123; path.push_back(i); // 遍历节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n) 剪枝，优化 已经选择的元素个数：path.size() 还需要的元素个数：k - path.size() 在集合n中至多要从 n - (k - path.size()) + 1开始遍历 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件的集合 vector&lt;int&gt; path; // 存放遍历路径 void backtracking(int n, int k, int startIdx) &#123; if (path.size() == k) &#123; result.push_back(path); return; &#125; // 剪枝优化 for (int i = startIdx; i &lt;= n - (k - path.size()) + 1; ++i) &#123; path.push_back(i); // 遍历节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; backtracking(n, k, 1); return result; &#125;&#125;; 17. 电话号码的字母组合题目描述：给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例：示例 1： 12输入：digits = &quot;23&quot;输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;] 示例 2： 12输入：digits = &quot;&quot;输出：[] 示例 3： 12输入：digits = &quot;2&quot;输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 提示： 0 &lt;= digits.length &lt;= 4 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。 题解：哈希 + 回溯123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;string&gt; result; string path; // 哈希表存储每个数字对应的字母 // key键值使用char！！！ unordered_map&lt;char, string&gt; umap = &#123;&#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125;, &#125;; void backtracking(string digits, int startIdx) &#123; if (path.size() == digits.size()) &#123; result.push_back(path); return; &#125; // 取数字对应的字符集 string nums = umap[digits[startIdx]]; for (int i = 0; i &lt; nums.size(); ++i) &#123; path += nums[i]; // 处理 backtracking(digits, startIdx + 1); // 递归 path.pop_back(); // 回溯 &#125; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.size() == 0) return result; backtracking(digits, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day47","date":"2024-05-11T16:00:00.000Z","updated":"2024-05-13T08:42:25.045Z","comments":true,"path":"p/leetcode/day47/","permalink":"https://krystencollins.github.io/p/leetcode/day47/","excerpt":"","text":"108. 将有序数组转换为二叉搜索树题目描述：给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。 示例：示例 1： 123输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2： 123输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 按 严格递增 顺序排列 题解：递归法123456789101112131415161718192021222324class Solution &#123;public: TreeNode* arrayToBST(vector&lt;int&gt;&amp; nums, int low, int high) &#123; // 子数组为空 if (low == high) return nullptr; // 取子数组中间元素（向下取整） int middle = low + (high - low) / 2; TreeNode* node = new TreeNode(nums[middle]); // 只有一个元素，叶子节点 if (high - low == 1) return node; // 左闭右开区间 node-&gt;left = arrayToBST(nums, low, middle); node-&gt;right = arrayToBST(nums, middle + 1, high); return node; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = arrayToBST(nums, 0, nums.size()); return root; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(log n) 迭代法12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return nullptr; TreeNode* root = new TreeNode(0); // 初始化根节点 queue&lt;int&gt; leftQue; // 保存左区间节点下标 queue&lt;int&gt; rightQue; // 保存右区间下标 queue&lt;TreeNode*&gt; nodeQue; // 存储遍历的节点 nodeQue.push(root); // 根节点入队 leftQue.push(0); // 初始化左区间下标位置 rightQue.push(nums.size() - 1); // 初始化右区间下标位置 （左闭右闭） while (!nodeQue.empty()) &#123; TreeNode* node = nodeQue.front(); nodeQue.pop(); int left = leftQue.front(); leftQue.pop(); int right = rightQue.front(); rightQue.pop(); int mid = left + (right - left) / 2; // 取当前区间中间节点：向下取整 node-&gt;val = nums[mid]; // 将mid对应元素赋值中间节点 if (left &lt;= mid - 1) &#123; // 处理左区间 node-&gt;left = new TreeNode(0); nodeQue.push(node-&gt;left); leftQue.push(left); // 左闭右闭 rightQue.push(mid - 1); &#125; if (right &gt;= mid + 1) &#123; // 处理右区间 node-&gt;right = new TreeNode(0); nodeQue.push(node-&gt;right); leftQue.push(mid + 1); // 左闭右闭 rightQue.push(right); &#125; &#125; return root; &#125;&#125;; 代码优化： 123456789101112131415161718192021222324252627282930class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return nullptr; TreeNode* root = new TreeNode(0); queue&lt;TreeNode*&gt; nodeQue; queue&lt;int&gt; indexQue; nodeQue.push(root); indexQue.push(0); indexQue.push(nums.size() - 1); while (!nodeQue.empty()) &#123; TreeNode* node = nodeQue.front(); nodeQue.pop(); int left = indexQue.front(); indexQue.pop(); int right = indexQue.front(); indexQue.pop(); int mid = left + (right - left) / 2; node-&gt;val = nums[mid]; if (left &lt;= mid - 1) &#123; node-&gt;left = new TreeNode(0); nodeQue.push(node-&gt;left); indexQue.push(left); indexQue.push(mid - 1); &#125; if (right &gt;= mid + 1) &#123; node-&gt;right = new TreeNode(0); nodeQue.push(node-&gt;right); indexQue.push(mid + 1); indexQue.push(right); &#125; &#125; return root; &#125;&#125;; 109. 有序链表转换二叉搜索树题目描述：给定一个单链表的头节点 head ，其中的元素 按升序排序 ，将其转换为 平衡 二叉搜索树。 示例：示例 1: 123输入: head = [-10,-3,0,5,9]输出: [0,-3,9,-10,null,5]解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。 示例 2: 12输入: head = []输出: [] 提示: head 中的节点数在[0, 2 * 104] 范围内 -105 &lt;= Node.val &lt;= 105 题解：链表转数组12345678910111213141516171819202122class Solution &#123;public: TreeNode* listToBST(vector&lt;int&gt;&amp; nums, int low, int high) &#123; if (low == high) return nullptr; int middle = low + (high - low) / 2; TreeNode* node = new TreeNode(nums[middle]); if (high - low == 1) return node; node-&gt;left = listToBST(nums, low, middle); node-&gt;right = listToBST(nums, middle + 1, high); return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; vector&lt;int&gt; nums; while (head) &#123; nums.push_back(head-&gt;val); head = head-&gt;next; &#125; TreeNode* root = listToBST(nums, 0, nums.size()); return root; &#125;&#125;; 快慢指针12345678910111213141516171819202122232425class Solution &#123;public: // 快慢指针获取中间节点 ListNode* getMiddle(ListNode* left, ListNode* right) &#123; ListNode* slow = left, * fast = left; while (fast != right &amp;&amp; fast-&gt;next != right) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125; // 递归构建二叉搜索树，左闭右开区间（链表无法获取中间节点前驱节点） TreeNode* listToBST(ListNode* left, ListNode* right) &#123; if (left == right) return nullptr; ListNode* mid = getMiddle(left, right); TreeNode* node = new TreeNode(mid-&gt;val); node-&gt;left = listToBST(left, mid); node-&gt;right = listToBST(mid-&gt;next, right); return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; return listToBST(head, nullptr); &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 分治+中序遍历分支过程中，不用着急找出链表中间节点，而是用一个占位节点，等到中序遍历到该节点时，再填充它的值 1234567891011121314151617181920212223class Solution &#123;public: // 中序遍历，每次都 优先构建左子树，列表指针自然指向中间节点 // 列表指针必须使用 引用 // 左闭右闭区间，（也可以使用左闭右开区间） TreeNode* listToBST(ListNode*&amp; head, int left, int right) &#123; if (left &gt; right) return nullptr; int mid = left + (right - left) / 2; TreeNode* node = new TreeNode(0); node-&gt;left = listToBST(head, left, mid - 1); // 左 node-&gt;val = head-&gt;val; // 中 head = head-&gt;next; node-&gt;right = listToBST(head, mid + 1, right); // 右 return node; &#125; TreeNode* sortedListToBST(ListNode* head) &#123; int size = 0; ListNode* p = head; for (; p != nullptr ; ++size, p = p-&gt;next); return listToBST(head, 0, size - 1); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(log n) 1382. 将二叉搜索树变平衡题目描述：给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 示例：示例 1： 123输入：root = [1,null,2,null,3,null,4,null,null]输出：[2,1,3,null,null,null,4]解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 示例 2： 12输入: root = [2,1,3]输出: [2,1,3] 提示： 树节点的数目在 [1, 104] 范围内。 1 &lt;= Node.val &lt;= 105 题解：1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; nums; void inOrder(TreeNode* node) &#123; if (node == nullptr) return; inOrder(node-&gt;left); nums.push_back(node-&gt;val); inOrder(node-&gt;right); &#125; TreeNode* buildBST(int left, int right) &#123; if (left == right) return nullptr; int mid = left + (right - left) / 2; TreeNode* node = new TreeNode(nums[mid]); if (right - left == 1) return node; node-&gt;left = buildBST(left, mid); node-&gt;right = buildBST(mid + 1, right); return node; &#125; TreeNode* balanceBST(TreeNode* root) &#123; inOrder(root); return buildBST(0, nums.size()); &#125;&#125;;","categories":[],"tags":[]},{"title":"修剪二叉搜索树","slug":"p/leetcode/day46","date":"2024-05-10T16:00:00.000Z","updated":"2024-05-13T07:24:57.822Z","comments":true,"path":"p/leetcode/day46/","permalink":"https://krystencollins.github.io/p/leetcode/day46/","excerpt":"","text":"669. 修剪二叉搜索树题目描述：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例：示例 1： 12输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2] 示例 2： 12输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1] 示例3： 12输入：[33,10,54,6,22,36,60,null, null,15], low = 15, high = 36输出：[33,22,36,15] 提示： 树中节点数在范围 [1, 104] 内 0 &lt;= Node.val &lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 &#96;0 &lt;&#x3D; low &lt;&#x3D; high &lt;&#x3D; 104 题解：递归法1234567891011121314class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return nullptr; // 当前节点值小于下界，只有右子树可能存在符合区间的节点，递归遍历右子树 if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high); // 当前节点值大于上界，只有左子树可能存在符合区间的节点，递归遍历左子树 if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high); // 当前节点值在符合区间内，则分别递归遍历左右子树 root-&gt;left = trimBST(root-&gt;left, low, high); // root-&gt;left接入符合条件的左孩子 root-&gt;right = trimBST(root-&gt;right, low, high); // root-&gt;right接入符合条件的右孩子 return root; &#125;&#125;; 迭代法​ 二叉搜索树的有序性，不需要栈模拟递归过程 剪枝过程： 将root移动到[low, high]范围内，左闭右闭区间 剪枝左子树 剪枝右子树 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return nullptr; // 处理头节点，让root移动到[low, high]内，左闭右闭 while (root != nullptr &amp;&amp; (root-&gt;val &lt; low || root-&gt;val &gt; high)) &#123; if (root-&gt;val &lt; low) root = root-&gt;right; // 小于low，往右走 else root = root-&gt;left; // 大于high，往左走 &#125; TreeNode* cur = root; // 此时root已在[low, high]内，处理左孩子小于low的情况 while (cur != nullptr) &#123; // 当前节点 左孩子存在，且左孩子节点值小于下界，则删除该左孩子（赋值为 左孩子的右子树） while (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt; low) &#123; cur-&gt;left = cur-&gt;left-&gt;right; &#125; cur = cur-&gt;left; &#125; cur = root; // 此时root已经在[low, high]内，处理右孩子大于high的情况 while (cur != nullptr) &#123; // 当前节点 右孩子存在，且右孩子节点值大于上界，则删除该右孩子（赋值为 右孩子的左子树） while (cur-&gt;right &amp;&amp; (cur-&gt;right-&gt;val &gt; high)) &#123; cur-&gt;right = cur-&gt;right-&gt;left; &#125; cur = cur-&gt;right; &#125; return root; &#125;&#125;; 1022. 从根到叶的二进制数之和题目描述：给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。 例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。 返回这些数字之和。题目数据保证答案是一个 32 位 整数。 相似题目： 129. 求根节点到叶节点数字之和 示例：示例 1： 123输入：root = [1,0,1,0,1,0,1]输出：22解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 示例 2： 12输入：root = [0]输出：0 提示： 树中的节点数在 [1, 1000] 范围内 Node.val 仅为 0 或 1 题解：递归法前序遍历，回溯 1234567891011121314151617181920212223242526class Solution &#123;public: void traversal(TreeNode* node, int&amp; sum, int&amp; result) &#123; sum = sum * 2 + node-&gt;val; // 中：累加路径和 // 若为叶子节点，累加最终结果 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result += sum; return; &#125; if (node-&gt;left) &#123; // 左 traversal(node-&gt;left, sum, result); sum /= 2; // 回溯 &#125; if (node-&gt;right) &#123; // 右 traversal(node-&gt;right, sum, result); sum /= 2; // 回溯 &#125; &#125; int sumRootToLeaf(TreeNode* root) &#123; int result = 0; // 记录所有 叶子节点 路径和 int sum = 0; // 记录遍历路径和 traversal(root, sum, result); return result; &#125;&#125;; 迭代法层序遍历，双队列存储中间结果 12345678910111213141516171819202122232425262728class Solution &#123;public: int sumRootToLeaf(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que_node; // 存储遍历节点 queue&lt;int&gt; que_val; // 存储路径和 int result = 0; que_node.push(root); que_val.push(root-&gt;val); while (!que_node.empty()) &#123; // 同时取出队头 节点和路径和 TreeNode* node = que_node.front(); que_node.pop(); int sum = que_val.front(); que_val.pop(); // 若节点为叶子节点，result累加路径和 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result += sum; &#125; if (node-&gt;left) &#123; // 左孩子不空，入队，更新路径和 que_node.push(node-&gt;left); que_val.push(sum * 2 + node-&gt;left-&gt;val); &#125; if (node-&gt;right) &#123; // 右孩子不空，入队，更新路径和 que_node.push(node-&gt;right); que_val.push(sum * 2 + node-&gt;right-&gt;val); &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"删除二叉搜索树中的节点","slug":"p/leetcode/day45","date":"2024-05-09T16:00:00.000Z","updated":"2024-05-12T14:23:01.165Z","comments":true,"path":"p/leetcode/day45/","permalink":"https://krystencollins.github.io/p/leetcode/day45/","excerpt":"","text":"450. 删除二叉搜索树中的节点题目描述：给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例：示例 1: 12345输入：root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2: 123输入: root = [5,3,6,2,4,null,7], key = 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点 示例 3: 12输入: root = [], key = 0输出: [] 提示: 节点数的范围 [0, 104]. -105 &lt;= Node.val &lt;= 105 节点值唯一 题解： 第一种情况：没找到删除节点，直接返回 找到删除节点： 第二种情况：目标节点为叶子节点，直接删除 第三种情况：目标节点左孩子为空，右孩子不为空，删除目标节点，右孩子补位，返回右子树 第四种情况：目标节点左孩子不空，左孩子为空，删除目标节点，左孩子补位，返回左子树 第五种情况：目标节点左右孩子都不空，将目标节点 左子树头节点 放到 目标节点右子树 最左边的叶子节点 的左孩子上，删除目标节点，返回右子树 递归法123456789101112131415161718192021222324252627282930class Solution &#123;public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == nullptr) return root; // 第一种情况：未找到目标节点，直接返回 if (root-&gt;val == key) &#123; // 第二种情况：目标节点为叶子节点，直接删除 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; delete root; return nullptr; &#125; // 第三种情况：目标节点左孩子为空，右孩子不为空，删除目标节点，右孩子补位，返回右子树 else if (root-&gt;left == nullptr) return root-&gt;right; // 第四种情况：目标节点左孩子不空，左孩子为空，删除目标节点，左孩子补位，返回左子树 else if (root-&gt;right == nullptr) return root-&gt;left; // 第五种情况：目标节点左右孩子都不空 else &#123; TreeNode * cur = root-&gt;right; while (cur-&gt;left != nullptr) cur = cur-&gt;left; cur-&gt;left = root-&gt;left; TreeNode* tmp = root; root = root-&gt;right; delete tmp; return root; &#125; &#125; if (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key); if (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key); return root; &#125;&#125;; 迭代法12345678910111213141516171819202122232425262728293031class Solution &#123;public: // 将目标节点的左子树放到右子树的最左边叶子节点的左孩子上，返回目标节点右孩子为新的根节点 TreeNode* deleteOneNode(TreeNode* target) &#123; if (target == nullptr) return target; // 目标节点为叶子节点，或目标节点右孩子为空但左孩子不为空 if (target-&gt;right == nullptr) return target-&gt;left; TreeNode* cur = target-&gt;right; while (cur-&gt;left) cur = cur-&gt;left; cur-&gt;left = target-&gt;left; return target-&gt;right; &#125; TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == nullptr) return root; TreeNode* cur = root; TreeNode* pre = nullptr; // 记录父节点，用来删除cur while (cur) &#123; if (cur-&gt;val == key) break; pre = cur; if (cur-&gt;val &gt; key) cur = cur-&gt;left; else cur = cur-&gt;right; &#125; // 若搜索树只用头节点：头节点值为目标值（cur为空），或头节点值不等于目标值（cur为root） if (pre == nullptr) return deleteOneNode(cur); // 判断删除pre的左孩子还是右孩子 if (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) pre-&gt;left = deleteOneNode(cur); if (pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val == key) pre-&gt;right = deleteOneNode(cur); return root; &#125;&#125;;","categories":[],"tags":[]},{"title":"把二叉搜索树转换为累加树","slug":"p/leetcode/day44","date":"2024-05-08T16:00:00.000Z","updated":"2024-05-11T02:25:38.889Z","comments":true,"path":"p/leetcode/day44/","permalink":"https://krystencollins.github.io/p/leetcode/day44/","excerpt":"","text":"538. 把二叉搜索树转换为累加树题目描述：给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 本题和 1038. 从二叉搜索树到更大和树 相同 示例：示例 1： 12输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 12输入：root = [0,null,1]输出：[1,null,1] 示例 3： 12输入：root = [1,0,2]输出：[3,3,2] 示例 4： 12输入：root = [3,2,4,1]输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 题解： 逆中序遍历，记录前一个遍历节点的指针（初始化为空指针） 或 只记录前一个节点值（初始化为0） 递归法1234567891011121314151617class Solution &#123;public: TreeNode* pre = nullptr; // 记录前一个节点指针 TreeNode* convertBST(TreeNode* root) &#123; if (root == nullptr) return root; convertBST(root-&gt;right); // 右 if (pre) root-&gt;val += pre-&gt;val; // 中 pre = root; convertBST(root-&gt;left); // 左 return root; &#125;&#125;; 统一迭代法12345678910111213141516171819202122class Solution &#123;public: TreeNode* convertBST(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); TreeNode* pre = nullptr; while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;left) stk.push(node-&gt;left); // 左 stk.push(node); // 中 stk.push(nullptr); if (node-&gt;right) stk.push(node-&gt;right); // 右 &#125; else &#123; node = stk.top(); stk.pop(); if (pre) node-&gt;val += pre-&gt;val; pre = node; &#125; &#125; return root; &#125;&#125;; 938. 二叉搜索树的范围和题目描述：给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。 示例：示例 1： 12输入：root = [10,5,15,3,7,null,18], low = 7, high = 15输出：32 示例 2： 12输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10输出：23 提示： 树中节点数目在范围 [1, 2 * 104] 内 1 &lt;= Node.val &lt;= 105 1 &lt;= low &lt;= high &lt;= 105 所有 Node.val 互不相同 题解：中序遍历，或任何一种遍历 递归法1234567891011121314class Solution &#123;public: int result = 0; int rangeSumBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return 0; rangeSumBST(root-&gt;left, low, high); // 左 // 中 if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) result += root-&gt;val; rangeSumBST(root-&gt;right, low, high); // 右 return result; &#125;&#125;; 剪枝，优化： 1234567891011121314class Solution &#123;public: int result = 0; int rangeSumBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return 0; // 当前节点值 小于 下界，不再遍历左子树 if (root-&gt;val &gt;= low) rangeSumBST(root-&gt;left, low, high); if (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) result += root-&gt;val; // 当前节点值 大于 上界，不再遍历右子树 if (root-&gt;val &lt;= high) rangeSumBST(root-&gt;right, low, high); return result; &#125;&#125;; 再优化，取消全局变量，利用递归函数返回值： 看不出哪种遍历方式 123456789101112class Solution &#123;public: int rangeSumBST(TreeNode* root, int low, int high) &#123; if (root == nullptr) return 0; // 当前节点值 大于 上界，返回左子树范围和 if (root-&gt;val &gt; high) return rangeSumBST(root-&gt;left, low, high); // 当前节点值 小于 下界，返回右子树范围和 if (root-&gt;val &lt; low) return rangeSumBST(root-&gt;right, low, high); // 否则，返回当前节点值 + 左右子树范围和 return root-&gt;val + rangeSumBST(root-&gt;left, low, high) + rangeSumBST(root-&gt;right, low, high); &#125;&#125;; 统一迭代法中序遍历 1234567891011121314151617181920212223class Solution &#123;public: int rangeSumBST(TreeNode* root, int low, int high) &#123; int result= 0; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; // 右：右孩子存在且当前节点值 在上界内，入栈 if (node-&gt;right &amp;&amp; node-&gt;val &lt;= high) stk.push(node-&gt;right); stk.push(node); // 中 stk.push(nullptr); // 左：左孩子存在且当前节点值 在下界内，入栈 if (node-&gt;left &amp;&amp; node-&gt;val &gt;= low) stk.push(node-&gt;left); &#125; else &#123; node = stk.top(); stk.pop(); if (node-&gt;val &gt;= low &amp;&amp; node-&gt;val &lt;= high) result += node-&gt;val; &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day43","date":"2024-05-07T16:00:00.000Z","updated":"2024-05-09T02:52:05.949Z","comments":true,"path":"p/leetcode/day43/","permalink":"https://krystencollins.github.io/p/leetcode/day43/","excerpt":"","text":"236. 二叉树的最近公共祖先题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例：示例 1： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 123输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 12输入：root = [1,2], p = 1, q = 2输出：1 提示： 树中节点数目在范围 [2, 105] 内。 -109 &lt;= Node.val &lt;= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 题解： 求最小公共祖先，需要自底向上遍历，只有后序遍历（回溯）可实现自底向上 在回溯过程中，要遍历完整颗二叉树，即使已经找到结构也要把其他节点遍历完，因为要使用递归函数返回值 作逻辑判断 重点理解在中间节点找到 公共祖先 时，如何通过返回值一层一层向上返回结果到根节点 递归法后序遍历 123456789101112131415161718class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 找到节点p或q，直接返回；未找到，节点未空，返回空 if (root == p || root == q || root == nullptr) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); // 左右子树返回值都不为空，说明当前节点为 最近公共祖先，直接返回 if (left != nullptr &amp;&amp; right != nullptr) return root; // 只有左子树或只有右子树返回值不为空，返回不为空的返回值（通过这样的方式将最近公共祖先传递到顶层） if (left == nullptr &amp;&amp; right != nullptr) return right; else if (left != nullptr &amp;&amp; right == nullptr) return left; else return nullptr; // 左右子树返回值都为空，p和q都不在该子树中，返回空 &#125;&#125;; 代码简洁版： 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == p || root == q || root == nullptr) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; return left ? left : right; &#125;&#125;; 存储父节点 从根节点出发遍历整颗二叉树，用哈希表记录每个节点的父节点指针 从p结点开始不断往它的祖先移动，并用数据结构（）记录已经访问过的祖先节点 同样，再从q节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是p和q的最近公共祖先 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: unordered_map&lt;int, TreeNode*&gt; father; // key：当前节点值，value：父节点指针 unordered_map&lt;int, bool&gt; visit; // key：当前节点值，value：是否访问过 void dfs(TreeNode* node) &#123; // 叶子节点 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) return; // 中：不需要处理 if (node-&gt;left != nullptr) &#123; // 左 father[node-&gt;left-&gt;val] = node; dfs(node-&gt;left); &#125; if (node-&gt;right != nullptr) &#123; // 右 father[node-&gt;right-&gt;val] = node; dfs(node-&gt;right); &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; father[root-&gt;val] = nullptr; // 根节点的父节点初始化为空 dfs(root); while (p != nullptr) &#123; // p为空，说明已回溯到根节点的父节点，退出循环 visit[p-&gt;val] = true; // 当前节点已访问，记为true p = father[p-&gt;val]; // p更新为 p节点的父节点 &#125; while (q != nullptr) &#123; if (visit[q-&gt;val]) return q; // 判断祖先是否被访问过， q = father[q-&gt;val]; // q更新为 q节点的父节点 &#125; return nullptr; &#125;&#125;; 235. 二叉搜索树的最近公共祖先题目描述：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例：例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 题解：一般二叉树 的剪枝： 123456789101112131415161718class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; // 找到节点p或q，直接返回；未找到，节点未空，返回空 if (root == p || root == q || root == nullptr) return root; TreeNode* left = root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val ? nullptr : lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val ? nullptr : lowestCommonAncestor(root-&gt;right, p, q); // 左右子树返回值都不为空，说明当前节点为 最近公共祖先，直接返回 if (left != nullptr &amp;&amp; right != nullptr) return root; // 只有左子树或只有右子树返回值不为空，返回不为空的返回值（通过这样的方式将最近公共祖先传递到顶层） if (left == nullptr &amp;&amp; right != nullptr) return right; else if (left != nullptr &amp;&amp; right == nullptr) return left; else return nullptr; // 左右子树返回值都为空，p和q都不在该子树中，返回空 &#125;&#125;; 从根节点开始遍历 若当前节点值大于p和q节点值，说明p和q应该在当前节点的左子树，因此将当前节点移动到左子树 若当前节点值小于p和q 的节点值，说明p和q应该在当前节点的右子树，因此将当前节点移动到右子树 若当前节点不满足上述条件，说明当前节点就是“分岔点”，此时，p和q要么在当前节点不同子树中，要么其中一个就是当前节点 递归法12345678class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); else return root; &#125;&#125;; 迭代法1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while (root) &#123; if (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left; else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right; else return root; &#125; return nullptr; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day42","date":"2024-05-06T16:00:00.000Z","updated":"2024-05-08T07:57:10.155Z","comments":true,"path":"p/leetcode/day42/","permalink":"https://krystencollins.github.io/p/leetcode/day42/","excerpt":"","text":"98. 验证二叉搜索树题目描述：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左 子树 只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例：示例 1： 12输入：root = [2,1,3]输出：true 示例 2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 &lt;= Node.val &lt;= 231 - 1 题解：二叉搜索树的中序遍历为 严格递增序列 递归法12345678910111213141516171819202122class Solution &#123;public: bool inOrder(TreeNode* node, long long&amp; preValue) &#123; if (node == nullptr) return true; bool result = true; result = inOrder(node-&gt;left, preValue); // 左 // 若中序遍历序列为 非严格递增，则不有效 if (node-&gt;val &lt;= preValue) return false; // 中 else preValue = node-&gt;val; // 更新前一个节点值 // 若当前节点左子树已无效，不需要遍历右子树，直接返回result if (result) result = inOrder(node-&gt;right, preValue); // 右 return result; &#125; bool isValidBST(TreeNode* root) &#123; long long minValue = LONG_MIN; // 初始化最小值，不能使用INT_MIN，因为测试数据存在INT_MIN return inOrder(root, minValue); &#125;&#125;; 前一个节点值 设为全局变量，未剪枝版： 1234567891011121314151617class Solution &#123;public: long long maxValue = LONG_MIN; // 测试数据中有int最小值 bool isValidBST(TreeNode* root) &#123; if (root == nullptr) return true; bool left = isValidBST(root-&gt;left); // 中序遍历，验证遍历元素是否从大到小 if (maxValue &lt; root-&gt;val) maxValue = root-&gt;val; else return false; bool right = isValidBST(root-&gt;right); return left &amp;&amp; right; &#125;&#125;; 记录前一个节点的指针，避免使用最小值： 12345678910111213141516class Solution &#123;public: TreeNode* pre = nullptr; // 记录前一个节点指针，避免使用最小值 bool isValidBST(TreeNode* root) &#123; if (root == nullptr) return true; bool left = isValidBST(root-&gt;left); if (pre != nullptr &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; else pre = root; // 记录前一个节点 bool right = isValidBST(root-&gt;right); return left &amp;&amp; right; &#125;&#125;; 统一迭代法1234567891011121314151617181920212223class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; long long preValue = LONG_MIN; // 初始化最小值 stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 stk.push(node); // 中 stk.push(nullptr); if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; else &#123; node = stk.top(); stk.pop(); // 中序遍历，当前节点值 小于等于 上一个节点值，不是有效二叉搜索树 if (preValue &gt;= node-&gt;val) return false; else preValue = node-&gt;val; &#125; &#125; return true; &#125;&#125;; 530. 二叉搜索树的最小绝对差题目描述：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 本题与 783. 二叉搜索树节点最小距离相同 示例：示例 1： 12输入：root = [4,2,6,1,3]输出：1 示例 2： 12输入：root = [1,0,48,null,null,12,49]输出：1 提示： 树中节点的数目范围是 [2, 104] 0 &lt;= Node.val &lt;= 105 题解：递归法123456789101112131415161718192021class Solution &#123;public: int minDiff = INT_MAX; // 初始化最小绝对差 TreeNode* pre = nullptr; // 记录前一个节点 int getMinimumDifference(TreeNode* root) &#123; if (root == nullptr) return minDiff; int left = getMinimumDifference(root-&gt;left); // 左 if (pre != nullptr) &#123; // 中，若前一个节点不为空，比较当前绝对差和最小绝对差 int diff = root-&gt;val - pre-&gt;val; minDiff = diff &lt; minDiff ? diff : minDiff; &#125; pre = root; // 更新前一个节点 int right = getMinimumDifference(root-&gt;right); // 右 return left &lt; right ? left : right; &#125;&#125;; 统一迭代法1234567891011121314151617181920212223242526class Solution &#123;public: int getMinimumDifference(TreeNode* root) &#123; int minDiff = INT_MAX; TreeNode* pre = nullptr; stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 stk.push(node); // 中 stk.push(nullptr); if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; else &#123; node = stk.top(); stk.pop(); if (pre != nullptr) &#123; int diff = node-&gt;val - pre-&gt;val; minDiff = diff &lt; minDiff ? diff : minDiff; &#125; pre = node; &#125; &#125; return minDiff; &#125;&#125;; 501. 二叉搜索树中的众数题目描述：给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例：示例 1： 12输入：root = [1,null,2,2]输出：[2] 示例 2： 12输入：root = [0]输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 &lt;= Node.val &lt;= 105 进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 题解：哈希表一般二叉树求众数的方法： 123456789101112131415161718192021222324252627282930class Solution &#123;public: void searchBST(TreeNode* node, unordered_map&lt;int, int&gt;&amp; map) &#123; if (node == nullptr) return; ++map[node-&gt;val]; searchBST(node-&gt;left, map); searchBST(node-&gt;right, map); &#125; // 仿函数：对second从大到小排序 bool static cmp(const pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.second &gt; b.second; &#125; vector&lt;int&gt; findMode(TreeNode* root) &#123; unordered_map&lt;int, int&gt; map; // key:元素，value: 频率 vector&lt;int&gt; result; if (root == nullptr) return result; searchBST(root, map); vector&lt;pair&lt;int, int&gt;&gt; vec(map.begin(), map.end()); sort(vec.begin(), vec.end(), cmp); // 对频率排序 result.push_back(vec[0].first); for (int i = 1; i &lt; vec.size(); ++i) &#123; // 取频率最高的放入result数组中 if (vec[i].second == vec[0].second) result.push_back(vec[i].first); else break; &#125; return result; &#125;&#125;; 递归法中序遍历，记录已出现最大频率，当出现更大频率时，重置结果数组，达到优化空间目的 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int maxCount = 0; // 最大频率 int count = 0; // 统计频率 TreeNode* pre = nullptr; // 前一个节点 vector&lt;int&gt; result; void searchBST(TreeNode* node) &#123; if (node == nullptr) return; searchBST(node-&gt;left); // 左 // 中 // pre为空，node为第一个节点，初始化count为1；前一个节点与当前节点不相同，重置count为1 if (pre == nullptr || pre-&gt;val != node-&gt;val) count = 1; else ++count; // 当前节点与前一个节点相同，累加频率 pre = node; //更新前一个节点 // 相同频率，存入result if (count == maxCount) result.push_back(node-&gt;val); else if (count &gt; maxCount) &#123; // 统计频率大于最大频率 maxCount = count; // 更新最大频率 result.clear(); // 清空result，重置众数 result.push_back(node-&gt;val); &#125; searchBST(node-&gt;right); // 右 &#125; vector&lt;int&gt; findMode(TreeNode* root) &#123; searchBST(root); return result; &#125;&#125;; 统一迭代法1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; findMode(TreeNode* root) &#123; vector&lt;int&gt; result; int maxCount = 0; int count = 0; TreeNode* pre = nullptr; stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 stk.push(node); // 中 stk.push(nullptr); if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; else &#123; node = stk.top(); stk.pop(); if (pre == nullptr || pre-&gt;val != node-&gt;val) count = 1; else ++count; pre = node; // 更新前一个节点 if (count == maxCount) result.push_back(node-&gt;val); else if (count &gt; maxCount) &#123; maxCount = count; result.clear(); result.push_back(node-&gt;val); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day41","date":"2024-05-05T16:00:00.000Z","updated":"2024-05-07T04:15:28.414Z","comments":true,"path":"p/leetcode/day41/","permalink":"https://krystencollins.github.io/p/leetcode/day41/","excerpt":"","text":"617. 合并二叉树题目描述：给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例：示例 1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例 2： 12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 &lt;= Node.val &lt;= 104 题解：递归法前序遍历，直接修改root1 12345678910111213class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if (root1 == nullptr) return root2; if (root2 == nullptr) return root1; root1-&gt;val += root2-&gt;val; // 中 root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); // 左 root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); // 右 return root1; &#125;&#125;; 中序遍历， 重新定义一棵树 1234567891011121314class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if (root1 == nullptr) return root2; // 如果root1为空，合并后为root2 if (root2 == nullptr) return root1; // 如果root2为空，合并后为root1 TreeNode* root = new TreeNode(0); root-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); // 左 root-&gt;val = root1-&gt;val + root2-&gt;val; // 中 root-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); // 右 return root; &#125;&#125;; 迭代法层序遍历 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if (root1 == nullptr) return root2; if (root2 == nullptr) return root1; queue&lt;TreeNode*&gt; que; que.push(root1); que.push(root2); while (!que.empty()) &#123; TreeNode* t1 = que.front(); que.pop(); TreeNode* t2 = que.front(); que.pop(); // 此时两个节点一定不为空，cal相加 t1-&gt;val += t2-&gt;val; // 若两个左节点都不为空，加入队列 if (t1-&gt;left &amp;&amp; t2-&gt;left) &#123; que.push(t1-&gt;left); que.push(t2-&gt;left); &#125; // 若两个右节点都不为空，加入队列 if (t1-&gt;right &amp;&amp; t2-&gt;right) &#123; que.push(t1-&gt;right); que.push(t2-&gt;right); &#125; // 当t1左节点为空，t2左节点不为空，直接赋值过去 if (t1-&gt;left == nullptr &amp;&amp; t2-&gt;left != nullptr) &#123; t1-&gt;left = t2-&gt;left; &#125; // 当t1右节点为空，t2右节点不为空，直接赋值过去 if (t1-&gt;right == nullptr &amp;&amp; t2-&gt;right != nullptr) &#123; t1-&gt;right = t2-&gt;right; &#125; &#125; return root1; &#125;&#125;; 700. 二叉搜索树中的搜索题目描述：给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例：示例 1: 12输入：root = [4,2,7,1,3], val = 2输出：[2,1,3] 示例 2: 12输入：root = [4,2,7,1,3], val = 5输出：[] 提示： 树中节点数在 [1, 5000] 范围内 1 &lt;= Node.val &lt;= 107 root 是二叉搜索树 1 &lt;= val &lt;= 107 题解：递归法123456789101112class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; // 如果节点为空，或节点值等于val，直接返回root if (root == nullptr || root-&gt;val == val) return root; if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val); if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val); // 当不存在节点值为val时返回nullptr return nullptr; &#125;&#125;; 迭代法12345678910class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; while (root) &#123; if (root-&gt;val == val) return root; root = root-&gt;val &lt; val ? root-&gt;right : root-&gt;left; &#125; return nullptr; &#125;&#125;; 701. 二叉搜索树中的插入操作题目描述：给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例：示例 1： 123输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是： 示例 2： 12输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25] 示例 3： 12输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 &lt;= Node.val &lt;= 108 所有值 Node.val 是 独一无二 的。 -108 &lt;= val &lt;= 108 保证 val 在原始BST中不存在。 题解：插入节点作为一个叶子节点， 注意插入位置父节点不一定为叶子节点，但保证插入位置为空 递归法1234567891011class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; // 节点为空，找到插入位置 if (root == nullptr) return new TreeNode(val); if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val); return root; &#125;&#125;; 迭代法1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; // 根节点为空，返回插入的新节点 if (root == nullptr) return new TreeNode(val); TreeNode* node = root; // node指向当前遍历节点 while (true) &#123; // 不可能无限循环，总能在叶子节点或左孩子为空或右孩子为空处找到一个 插入位置 if (node-&gt;val &gt; val) &#123; // 当前节点左孩子为空，说明找到插入位置 // 插入节点需要知道父节点，因此不可直接 node=node-&gt;left if (node-&gt;left == nullptr) &#123; node-&gt;left = new TreeNode(val); break; // 插入节点后退出循环 &#125; else &#123; node = node-&gt;left; &#125; &#125; else &#123; // 当前节点右孩子为空，说明找到插入位置 if (node-&gt;right == nullptr) &#123; node-&gt;right = new TreeNode(val); break; &#125; else &#123; node = node-&gt;right; &#125; &#125; &#125; return root; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day40","date":"2024-05-04T16:00:00.000Z","updated":"2024-05-06T03:14:28.362Z","comments":true,"path":"p/leetcode/day40/","permalink":"https://krystencollins.github.io/p/leetcode/day40/","excerpt":"","text":"654. 最大二叉树题目描述：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 示例：示例 1： 123456789101112输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示：- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： 12输入：nums = [3,2,1]输出：[3,null,2,null,1] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 nums 中的所有整数 互不相同 题解：递归法12345678910111213141516171819202122232425262728293031class Solution &#123;public: TreeNode* maximumBinaryTree(auto begin, auto end) &#123; // 子数组为空 if (begin == end) return nullptr; // 最大值的迭代器 auto maxPosition = max_element(begin, end); TreeNode* root = new TreeNode(*maxPosition); // 只有一个元素，叶子节点 if (end - begin == 1) return root; // 左闭右开区间！ auto leftBegin = begin; auto leftEnd = maxPosition; auto rightBegin = maxPosition + 1; auto rightEnd = end; root-&gt;left = maximumBinaryTree(leftBegin, leftEnd); root-&gt;right = maximumBinaryTree(rightBegin, rightEnd); return root; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = maximumBinaryTree(nums.begin(), nums.end()); return root; &#125;&#125;; 单调栈 hold on ! 123456789101112131415161718192021222324252627282930313233343536```### [998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/)#### 题目描述：**最大树** 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。给你最大树的根节点 `root` 和一个整数 `val` 。就像 [之前的问题](https://leetcode.cn/problems/maximum-binary-tree/) 那样，给定的树是利用 `Construct(a)` 例程从列表 `a`（`root = Construct(a)`）递归地构建的：- 如果 `a` 为空，返回 `null` 。- 否则，令 `a[i]` 作为 `a` 的最大元素。创建一个值为 `a[i]` 的根节点 `root` 。- `root` 的左子树将被构建为 `Construct([a[0], a[1], ..., a[i - 1]])` 。- `root` 的右子树将被构建为 `Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])` 。- 返回 `root` 。请注意，题目没有直接给出 `a` ，只是给出一个根节点 `root = Construct(a)` 。假设 `b` 是 `a` 的副本，并在末尾附加值 `val`。题目数据保证 `b` 中的值互不相同。返回 `Construct(b)` 。#### 示例：**示例 1：****![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107381.png)![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107462.png)** 输入：root &#x3D; [4,1,3,null,null,2], val &#x3D; 5输出：[5,4,null,1,3,null,null,2]解释：a &#x3D; [1,4,2,3], b &#x3D; [1,4,2,3,5] 1234**示例 2：![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107437.png)![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107497.png)** 输入：root &#x3D; [5,2,4,null,1], val &#x3D; 3输出：[5,2,4,null,1,null,3]解释：a &#x3D; [2,1,5,4], b &#x3D; [2,1,5,4,3] 1234**示例 3：![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107405.png)![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405061107511.png)** 输入：root &#x3D; [5,2,3,null,1], val &#x3D; 4输出：[5,2,4,null,1,3]解释：a &#x3D; [2,1,5,3], b &#x3D; [2,1,5,3,4] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #### **提示：**- 树中节点数目在范围 `[1, 100]` 内- `1 &lt;= Node.val &lt;= 100`- 树中的所有值 **互不相同**- `1 &lt;= val &lt;= 100`#### 题解：##### 遍历右子节点```C++class Solution &#123;public: TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123; TreeNode* newNode = new TreeNode(val); // val值大于根节点值，root直接作为左子树 if (root-&gt;val &lt; val) &#123; newNode-&gt;left = root; return newNode; &#125; // 找到子树分割点，一直往右子树 TreeNode* node = root; while (node-&gt;right) &#123; if (node-&gt;right-&gt;val &lt; val)&#123; break; &#125; node = node-&gt;right; &#125; // 将newNode插入到node右子树，node原左子树作为newNode左子树 newNode-&gt;left = node-&gt;right; node-&gt;right= newNode; return root; &#125;&#125;; 递归法12345678class Solution &#123;public: TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123; if (!root || root-&gt;val &lt; val) return new TreeNode(val, root, nullptr); root-&gt;right = insertIntoMaxTree(root-&gt;right, val); return root; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day39","date":"2024-05-03T16:00:00.000Z","updated":"2024-05-06T02:55:41.400Z","comments":true,"path":"p/leetcode/day39/","permalink":"https://krystencollins.github.io/p/leetcode/day39/","excerpt":"","text":"106. 从中序与后序遍历序列构造二叉树题目描述：给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例：示例 1: 12输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 示例 2: 12输入：inorder = [-1], postorder = [-1]输出：[-1] 提示: 1 &lt;= inorder.length &lt;= 3000 postorder.length == inorder.length -3000 &lt;= inorder[i], postorder[i] &lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 题解：注意：数组中数值各不相同 详细思路 数组大小若为0，为空节点 数组大小若不为0，取后序数组最后一个元素作为”根节点“ 找到后序数组最后一个元素在中序数组中的位置，作为切割点 切割中序数组，切成中序左数组和中序右数组（一定先切割中序数组） 切割后序数组，切成后序左数组和后序右数组 递归处理左区间和右区间 递归法直接切割数组 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int size = postorder.size(); if (size == 0) return NULL; // 后序遍历数组最后一个元素，即当前子树根节点 int rootValue = postorder[size - 1]; TreeNode* root = new TreeNode(rootValue); // 叶子节点 if (size == 1) return root; // 找到中序遍历的切割点 int delimiterIndex = 0; for (; delimiterIndex &lt; inorder.size(); ++delimiterIndex) &#123; if (inorder[delimiterIndex] == rootValue) break; &#125; // 切割中序数组 // 左闭右开区间：[0, delimiterIndex), [delimiterIndex + 1, end) vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterIndex); vector&lt;int&gt; rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end()); // 舍弃postorder末尾元素 postorder.resize(size - 1); // 切割后序数组 // 左闭右开区间，使用中序子数组大小作为切割点：[0, leftInorder.size()), [leftInorder.size(), end) vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size()); vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end()); // 递归左右区间 root-&gt;left = buildTree(leftInorder, leftPostorder); root-&gt;right = buildTree(rightInorder, rightPostorder); return root; &#125;&#125;; 代码优化，切割数组下标索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd) TreeNode* traversal(vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; postorder, int postorderBegin, int postorderEnd) &#123; // 空节点 if (postorderBegin == postorderEnd) return nullptr; // 当前子树根节点值为后序数组最后一个元素 int rootValue = postorder[postorderEnd - 1]; TreeNode* root = new TreeNode(rootValue); // 叶子节点 if (postorderEnd - postorderBegin == 1) return root; // 寻找中序数组切割点 int delimiterIndex = inorderBegin; for (; delimiterIndex &lt; inorderEnd; ++delimiterIndex) &#123; if (inorder[delimiterIndex] == rootValue) break; &#125; // 切割中序数组 // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd) int leftInorderBegin = inorderBegin; int leftInorderEnd = delimiterIndex; // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd) int rightInorderBegin = delimiterIndex + 1; int rightInorderEnd = inorderEnd; // 切割后序数组 // 左后序数组，左闭右开[leftPostorderBegin, leftPostorderEnd) int leftPostorderBegin = postorderBegin; int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 右后序数组，左闭右开[rightPostorderBegin, rightPostorderEnd) int rightPostorderBegin = postorderBegin + delimiterIndex - inorderBegin; int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，子树根节点 root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd); root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd); return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size()); &#125;&#125;; 迭代法 hold on! 12345678910111213141516171819202122```### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)#### 题目描述：给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。#### 示例：**示例 1:**![img](https://typora-picgo-01.oss-cn-qingdao.aliyuncs.com/202405051105917.jpeg) 输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 123**示例 2:** 输入: preorder &#x3D; [-1], inorder &#x3D; [-1]输出: [-1] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 #### **提示:**- `1 &lt;= preorder.length &lt;= 3000`- `inorder.length == preorder.length`- `-3000 &lt;= preorder[i], inorder[i] &lt;= 3000`- `preorder` 和 `inorder` 均 **无重复** 元素- `inorder` 均出现在 `preorder`- `preorder` **保证** 为二叉树的前序遍历序列- `inorder` **保证** 为二叉树的中序遍历序列#### 题解：##### 递归法切割数组下标索引```C++class Solution &#123;public: // 前序区间：[preorderBegin, preorderEnd)，中序区间：[inorderBegin, inorderEnd) TreeNode* traversal(vector&lt;int&gt;&amp; preorder, int preorderBegin, int preorderEnd, vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd) &#123; // 空节点 if (preorderBegin == preorderEnd) return nullptr; // 当前子树根节点为前序数组第一个元素 int rootValue = preorder[preorderBegin]; TreeNode* root = new TreeNode(rootValue); // 叶子节点 if (preorderEnd - preorderBegin == 1) return root; // 寻找中序数组切割点 int delimiterIndex = inorderBegin; for (; delimiterIndex &lt; inorderEnd; ++delimiterIndex) &#123; if (inorder[delimiterIndex] == rootValue) break; &#125; // 切割中序数组 // 左中序区间，左闭右开 int leftInorderBegin = inorderBegin; int leftInorderEnd = delimiterIndex; // 右中序数组， int rightInorderBegin = delimiterIndex + 1; int rightInorderEnd = inorderEnd; // 切割前序数组，左前序数组 int leftPreorderBegin = preorderBegin + 1; int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 右前序数组 int rightPreorderBegin = preorderBegin + 1 + delimiterIndex - inorderBegin; int rightPreorderEnd = preorderEnd; root-&gt;left = traversal(preorder, leftPreorderBegin, leftPreorderEnd, inorder, leftInorderBegin, leftInorderEnd); root-&gt;right = traversal(preorder, rightPreorderBegin, rightPreorderEnd, inorder, rightInorderBegin, rightInorderEnd); return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return traversal(preorder, 0, preorder.size(), inorder, 0, preorder.size()); &#125;&#125;; 迭代法 hond on! 1","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day38","date":"2024-05-02T16:00:00.000Z","updated":"2024-05-05T02:55:25.834Z","comments":true,"path":"p/leetcode/day38/","permalink":"https://krystencollins.github.io/p/leetcode/day38/","excerpt":"","text":"404. 左叶子之和题目描述：给定二叉树的根节点 root ，返回所有左叶子之和。 示例：示例 1： 123输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 12输入: root = [1]输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法，广度优先遍历层次遍历 123456789101112131415161718class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; int result = 0; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; TreeNode* node = que.front(); que.pop(); // 左孩子存在，并且左孩子为叶子节点，累加左叶子数值 if (node-&gt;left &amp;&amp; node-&gt;left-&gt;left == nullptr &amp;&amp; node-&gt;left-&gt;right == nullptr) &#123; result += node-&gt;left-&gt;val; &#125; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; return result; &#125;&#125;; 递归法，深度优先遍历前序遍历 1234567891011121314151617class Solution &#123;public: void leftLeaves(TreeNode* node, int&amp; result) &#123; // 中 if (node-&gt;left &amp;&amp; node-&gt;left-&gt;left == nullptr &amp;&amp; node-&gt;left-&gt;right == nullptr) &#123; result += node-&gt;left-&gt;val; &#125; if (node-&gt;left) leftLeaves(node-&gt;left, result); // 左 if (node-&gt;right) leftLeaves(node-&gt;right, result); // 右 &#125; int sumOfLeftLeaves(TreeNode* root) &#123; int result = 0; leftLeaves(root, result); return result; &#125;&#125;; 897. 递增顺序搜索树题目描述：给你一棵二叉搜索树的 root ，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。 示例：示例 1： 12输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 示例 2： 12输入：root = [5,1,7]输出：[1,null,5,null,7] 提示： 树中节点数的取值范围是 [1, 100] 0 &lt;= Node.val &lt;= 1000 题解：统一迭代法，中序遍历123456789101112131415161718192021222324252627282930class Solution &#123;public: TreeNode* increasingBST(TreeNode* root) &#123; TreeNode* result = nullptr; TreeNode* cur = result; stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 stk.push(node); // 中 stk.push(nullptr); if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; else &#123; node = stk.top(); stk.pop(); node-&gt;left = nullptr; // 节点左孩子置空 // result指向根节点，cur指向当前结果树 叶节点 if (result == nullptr) &#123; result = node; cur = result; &#125; else &#123; cur-&gt;right = node; cur = cur-&gt;right; &#125; &#125; &#125; return result; &#125;&#125;; 递归法，中序遍历1234567891011121314151617181920212223class Solution &#123;private: // 设置result为“全局变量”便于修改，若设置为 指针的引用 行不通？ TreeNode* result; public: void inOrder(TreeNode* node) &#123; if (node == nullptr) return; inOrder(node-&gt;left); // 左 // 中，中序遍历过程中修改节点指向 result-&gt;right = node; node-&gt;left = nullptr; // 节点左孩子置空 result = node; inOrder(node-&gt;right); // 右 &#125; TreeNode* increasingBST(TreeNode* root) &#123; TreeNode* dummyNode = new TreeNode(-1); result = dummyNode; inOrder(root); return dummyNode-&gt;right; &#125;&#125;; 513. 找树左下角的值题目描述：给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例：示例 1: 12输入: root = [2,1,3]输出: 1 示例 2: 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 &lt;= Node.val &lt;= 231 - 1 题解：迭代法，层次遍历123456789101112131415161718class Solution &#123;public: int findBottomLeftValue(TreeNode* root) &#123; int result = root-&gt;val; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; int size = que.size(); result = que.front()-&gt;val; // 更新每层最左边节点的值 for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return result; &#125;&#125;; 递归法，前序遍历123456789101112131415161718class Solution &#123;public: void levelOrder(TreeNode* node, int depth, int&amp; maxDepth, int&amp; result) &#123; if (node == nullptr) return; // 最大深度的最左边节点的值：即第一次遇到下一层叶子节点时修改maxDepth, result if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr &amp;&amp; depth &gt; maxDepth) &#123; maxDepth = depth; result = node-&gt;val; &#125; levelOrder(node-&gt;left, depth + 1, maxDepth, result); // 隐藏回溯 levelOrder(node-&gt;right, depth + 1, maxDepth, result); &#125; int findBottomLeftValue(TreeNode* root) &#123; int depth = 0, maxDepth = 0, result = root-&gt;val; levelOrder(root, depth, maxDepth, result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"Hello World","slug":"p/hello-world","date":"2024-05-02T14:06:09.325Z","updated":"2024-05-02T14:06:09.326Z","comments":true,"path":"p/hello-world/","permalink":"https://krystencollins.github.io/p/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day37","date":"2024-05-01T16:00:00.000Z","updated":"2024-05-03T02:55:32.632Z","comments":true,"path":"p/leetcode/day37/","permalink":"https://krystencollins.github.io/p/leetcode/day37/","excerpt":"","text":"113. 路径总和 II题目描述：给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例：示例 1： 12输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]] 示例 2： 12输入：root = [1,2,3], targetSum = 5输出：[] 示例 3： 12输入：root = [1,2], targetSum = 0输出：[] 提示： 树中节点总数在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 题解：递归法，回溯123456789101112131415161718192021222324252627class Solution &#123;public: void traversal(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; vec) &#123; vec.push_back(node-&gt;val); int sum = accumulate(vec.begin(), vec.end(), 0); if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; result.push_back(vec); return; &#125; if (node-&gt;left) &#123; traversal(node-&gt;left, targetSum, result, vec); vec.pop_back(); &#125; if (node-&gt;right) &#123; traversal(node-&gt;right, targetSum, result, vec); vec.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (root == nullptr) return result; vector&lt;int&gt; vec; traversal(root, targetSum, result, vec); return result; &#125;&#125;; 代码优化 1234567891011121314151617181920212223242526272829class Solution &#123;public: void traversal(TreeNode* node, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; vec) &#123; vec.push_back(node-&gt;val); // 中 // int sum = accumulate(vec.begin(), vec.end(), 0); targetSum -= node-&gt;val; // 遇到叶子节点 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123; result.push_back(vec); return; &#125; if (node-&gt;left) &#123; // 左 traversal(node-&gt;left, targetSum, result, vec); vec.pop_back(); // 回溯 &#125; if (node-&gt;right) &#123; // 右 traversal(node-&gt;right, targetSum, result, vec); vec.pop_back(); // 回溯 &#125; &#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123; vector&lt;vector&lt;int&gt;&gt; result; if (root == nullptr) return result; vector&lt;int&gt; vec; traversal(root, targetSum, result, vec); return result; &#125;&#125;; 129. 求根节点到叶节点数字之和题目描述：给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字： 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。 叶节点 是指没有子节点的节点。 示例：示例 1： 123456输入：root = [1,2,3]输出：25解释：从根到叶子节点路径 1-&gt;2 代表数字 12从根到叶子节点路径 1-&gt;3 代表数字 13因此，数字总和 = 12 + 13 = 25 示例 2： 1234567输入：root = [4,9,0,5,1]输出：1026解释：从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491从根到叶子节点路径 4-&gt;0 代表数字 40因此，数字总和 = 495 + 491 + 40 = 1026 提示： 树中节点的数目在范围 [1, 1000] 内 0 &lt;= Node.val &lt;= 9 树的深度不超过 10 题解：迭代法，广度优先遍历1234567891011121314151617181920212223242526class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que_node; // 存储遍历节点 queue&lt;int&gt; que_val; // 存储路径和 int result = 0; que_node.push(root); que_val.push(root-&gt;val); while (!que_node.empty()) &#123; TreeNode* node = que_node.front(); que_node.pop(); int sum = que_val.front(); que_val.pop(); if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result += sum; &#125; if (node-&gt;left) &#123; que_node.push(node-&gt;left); que_val.push(node-&gt;left-&gt;val + sum * 10); &#125; if (node-&gt;right) &#123; que_node.push(node-&gt;right); que_val.push(node-&gt;right-&gt;val + sum * 10); &#125; &#125; return result; &#125;&#125;; 递归法，深度优先遍历前序遍历 12345678910111213141516171819202122232425class Solution &#123;public: void traversal(TreeNode* node, int&amp; sum, int&amp; result) &#123; sum = sum * 10 + node-&gt;val; // 中 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result += sum; return; &#125; if (node-&gt;left) &#123; // 左 traversal(node-&gt;left, sum, result); sum /= 10; // 回溯 &#125; if (node-&gt;right) &#123; // 右 traversal(node-&gt;right, sum, result); sum /= 10; // 回溯 &#125; &#125; int sumNumbers(TreeNode* root) &#123; int result = 0; int sum = 0; traversal(root, sum, result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day35","date":"2024-05-01T08:47:20.690Z","updated":"2024-05-02T06:55:52.504Z","comments":true,"path":"p/leetcode/day35/","permalink":"https://krystencollins.github.io/p/leetcode/day35/","excerpt":"","text":"110. 平衡二叉树题目描述：给定一个二叉树，判断它是否是 平衡二叉树 平衡二叉树：指该树所有节点的左右子树的深度相差不超过1 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：true 示例 2： 12输入：root = [1,2,2,3,3,null,null,4,4]输出：false 示例 3： 12输入：root = []输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -10^4 &lt;= Node.val &lt;= 10^4 题解： 二叉树深度：从根节点到该节点的最长简单路径边的条数 二叉树高度：从该节点到叶子节点的最长简单路径边的条数 leetcode中强调深度和高度按照节点来计算： 求深度：前序遍历（中左右），从上到下查 求高度：后序遍历（左右中），从下到上查 递归法，前序遍历求高度12345678910111213141516171819class Solution &#123;public: int getDepth(TreeNode* node) &#123; if (node == nullptr) return 0; int leftDepth = getDepth(node-&gt;left); // 左 if (leftDepth == -1) return -1; int rightDepth = getDepth(node-&gt;right); // 右 if (rightDepth == -1) return -1; if (abs(leftDepth - rightDepth) &gt; 1) &#123; // 中 return -1; &#125; return 1 + max(leftDepth, rightDepth); // 以当前节点为根节点的树的最大高度 &#125; bool isBalanced(TreeNode* root) &#123; return getDepth(root) == -1 ? false : true; &#125;&#125;; 代码优化： 1234567891011121314151617class Solution &#123;public: // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树则返回-1 int getDepth(TreeNode* node) &#123; if (node == nullptr) return 0; int leftDepth = getDepth(node-&gt;left); // 左 if (leftDepth == -1) return -1; int rightDepth = getDepth(node-&gt;right); // 右 if (rightDepth == -1) return -1; return abs(leftDepth - rightDepth) &gt; 1 ? -1 : 1 + max(leftDepth, rightDepth); &#125; bool isBalanced(TreeNode* root) &#123; return getDepth(root) == -1 ? false : true; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day36","date":"2024-04-30T16:00:00.000Z","updated":"2024-05-03T02:48:38.009Z","comments":true,"path":"p/leetcode/day36/","permalink":"https://krystencollins.github.io/p/leetcode/day36/","excerpt":"","text":"257. 二叉树的所有路径题目描述：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例：示例 1： 12输入：root = [1,2,3,null,5]输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;] 示例 2： 12输入：root = [1]输出：[&quot;1&quot;] 提示： 树中节点的数目在范围 [1, 100] 内 -100 &lt;= Node.val &lt;= 100 题解：迭代法前序遍历 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; // 保存最终路径集合 stack&lt;TreeNode*&gt; treeSt; // 保存树的遍历节点 stack&lt;string&gt; pathSt; // 保存遍历路径的节点 if (root == nullptr) return result; treeSt.push(root); pathSt.push(to_string(root-&gt;val)); while (!treeSt.empty()) &#123; TreeNode* node = treeSt.top(); treeSt.pop(); // 中：取出节点 string path = pathSt.top(); pathSt.pop(); // 取出该节点对应的路径 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; // 遇到叶子节点 result.push_back(path); &#125; if (node-&gt;right) &#123; // 右 treeSt.push(node-&gt;right); pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;right-&gt;val)); &#125; if (node-&gt;left) &#123; // 左 treeSt.push(node-&gt;left); pathSt.push(path + &quot;-&gt;&quot; + to_string(node-&gt;left-&gt;val)); &#125; &#125; return result; &#125;&#125;; 递归法，回溯版本一，vector记录中间结果容易做回溯 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void traversal(TreeNode* node, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; result) &#123; path.push_back(node-&gt;val); // 中 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; // 叶子节点 string sPath; int size = path.size(); for (int i = 0; i &lt; size - 1; ++i) &#123; sPath += to_string(path[i]); sPath += &quot;-&gt;&quot;; &#125; sPath += to_string(path[size - 1]); result.push_back(sPath); return; &#125; if (node-&gt;left) &#123; // 左 traversal(node-&gt;left, path, result); path.pop_back(); // 回溯 &#125; if (node-&gt;right) &#123; // 右 traversal(node-&gt;right, path, result); path.pop_back(); // 回溯 &#125; &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; if (root == nullptr) return result; vector&lt;int&gt; path; traversal(root, path, result); return result; &#125;&#125;; 版本二 1234567891011121314151617181920class Solution &#123;public: void traversal(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123; path += to_string(node-&gt;val); // 中 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result.push_back(path); return; &#125; if (node-&gt;left) traversal(node-&gt;left, path + &quot;-&gt;&quot;, result); // 左 if (node-&gt;right) traversal(node-&gt;right, path + &quot;-&gt;&quot;, result); // 右 &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; if (root == nullptr) return result; string path; traversal(root, path, result); return result; &#125;&#125;; 回溯过程 123456789101112131415161718192021222324252627282930class Solution &#123;public: void traversal(TreeNode* node, string path, vector&lt;string&gt;&amp; result) &#123; path += to_string(node-&gt;val); // 中，不需要回溯，因为path不是引用类型 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123; result.push_back(path); return; &#125; if (node-&gt;left) &#123; path += &quot;-&gt;&quot;; traversal(node-&gt;left, path, result); // 左 path.pop_back(); // 回溯&quot;&gt;&quot; path.pop_back(); // 回溯&quot;-&quot; &#125; if (node-&gt;right) &#123; path += &quot;-&gt;&quot;; traversal(node-&gt;right, path, result); // 右 path.pop_back(); // 回溯&quot;&gt;&quot; path.pop_back(); // 回溯&quot;-&quot; &#125; &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; if (root == nullptr) return result; string path; traversal(root, path, result); return result; &#125;&#125;; 112. 路径总和题目描述：给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例：示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 题解：迭代法，广度优先遍历123456789101112131415161718192021222324252627class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if (root == nullptr) return false; queue&lt;TreeNode*&gt; que_node; // 存储节点 queue&lt;int&gt; que_val; // 存储路径和 que_node.push(root); que_val.push(root-&gt;val); while (!que_node.empty()) &#123; TreeNode* node = que_node.front(); que_node.pop(); int sum = que_val.front(); que_val.pop(); // 遇到叶子节点，并且路径和等于targetSum if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr &amp;&amp; sum == targetSum) &#123; return true; &#125; if (node-&gt;left) &#123; que_node.push(node-&gt;left); que_val.push(node-&gt;left-&gt;val + sum); &#125; if (node-&gt;right) &#123; que_node.push(node-&gt;right); que_val.push(node-&gt;right-&gt;val + sum); &#125; &#125; return false; &#125;&#125;; 递归法，深度优先遍历1234567891011121314151617181920class Solution &#123;public: void traversal(TreeNode* node, int targetSum, bool&amp; result) &#123; targetSum -= node-&gt;val; // 目标和每次减去节点值 // 遇到叶子节点，并且目标和为0时，得到一个结果 if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123; result = true; return; &#125; if (node-&gt;left) traversal(node-&gt;left, targetSum, result); if (node-&gt;right) traversal(node-&gt;right, targetSum, result); &#125; bool hasPathSum(TreeNode* root, int targetSum) &#123; bool result = false; if (root == nullptr) return result; traversal(root, targetSum, result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day34","date":"2024-04-29T15:33:52.423Z","updated":"2024-05-01T12:13:52.521Z","comments":true,"path":"p/leetcode/day34/","permalink":"https://krystencollins.github.io/p/leetcode/day34/","excerpt":"","text":"222. 完全二叉树的节点个数题目描述：你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例：示例 1： 12输入：root = [1,2,3,4,5,6]输出：6 示例 2： 12输入：root = []输出：0 示例 3： 12输入：root = [1]输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 &lt;= Node.val &lt;= 5 * 104 题目数据保证输入的树是 完全二叉树 进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ 题解：层序遍历，迭代法12345678910111213141516171819class Solution &#123;public: int countNodes(TreeNode* root) &#123; int count = 0; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); count += size; for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return count; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 后序遍历，递归法12345678910111213class Solution &#123;public: int getCountNodes(TreeNode* node) &#123; if (node == nullptr) return 0; int leftNums = getCountNodes(node-&gt;left); // 左 int rightNums = getCountNodes(node-&gt;right); // 右 return 1 + leftNums + rightNums; // 中 &#125; int countNodes(TreeNode* root) &#123; return getCountNodes(root); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(log \\ n)$ 公式计算 12345678910111213141516171819202122class Solution &#123;public: int countNodes(TreeNode* root) &#123; if (root == nullptr) return 0; // 根据左深度和右深度是否相同来判断该子树是不是 满二叉树 int leftDepth = 0, rightDepth = 0; TreeNode* left = root-&gt;left; TreeNode* right = root-&gt;right; while (left) &#123; // 求左深度 left = left-&gt;left; ++leftDepth; &#125; while (right) &#123; // 求右深度 right = right-&gt;right; ++rightDepth; &#125; if (leftDepth == rightDepth) &#123; return (2 &lt;&lt; leftDepth) - 1; // (2&lt;&lt;1)相当于2^2，所以leftDepth初始化为0 &#125; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125;&#125;; 时间复杂度：$O(log\\ n * log \\ n)$ 空间复杂度：$O(log)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day33","date":"2024-04-28T06:38:18.298Z","updated":"2024-05-01T14:23:27.057Z","comments":true,"path":"p/leetcode/day33/","permalink":"https://krystencollins.github.io/p/leetcode/day33/","excerpt":"","text":"100. 相同的树题目描述：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例：示例 1： 12输入：p = [1,2,3], q = [1,2,3]输出：true 示例 2： 12输入：p = [1,2], q = [1,null,2]输出：false 示例 3： 12输入：p = [1,2,1], q = [1,1,2]输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 &lt;= Node.val &lt;= 104 题解：递归法12345678910class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) return true; else if (p != nullptr &amp;&amp; q == nullptr) return false; else if (p == nullptr &amp;&amp; q != nullptr) return false; else if (p-&gt;val != q-&gt;val) return false; else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; 优化： 12345678class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) return true; else if (!p || !q || p-&gt;val != q-&gt;val) return false; else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; 迭代法12345678910111213141516171819class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; stack&lt;TreeNode*&gt; stk; stk.push(p); stk.push(q); while (!stk.empty()) &#123; TreeNode* p1 = stk.top(); stk.pop(); TreeNode* q1 = stk.top(); stk.pop(); if (p1 == nullptr &amp;&amp; q1 == nullptr) continue; if (!p1 || !q1 || p1-&gt;val != q1-&gt;val) return false; stk.push(p1-&gt;left); stk.push(q1-&gt;left); stk.push(p1-&gt;right); stk.push(q1-&gt;right); &#125; return true; &#125;&#125;; 101. 对称二叉树题目描述：给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例：示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 题解：迭代法内侧外侧成对遍历，栈或队列都可 12345678910111213141516171819202122class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) return true; queue&lt;TreeNode*&gt; que; que.push(root-&gt;left); que.push(root-&gt;right); while (!que.empty()) &#123; TreeNode* leftNode = que.front(); que.pop(); TreeNode* rightNode = que.front(); que.pop(); // 左右节点都为空，说明对称 if (!leftNode &amp;&amp; !rightNode) continue; // 左右一个节点不为空，或者都不为空，但数值不相同 if (!leftNode || !rightNode || leftNode-&gt;val != rightNode-&gt;val) return false; que.push(leftNode-&gt;left); // 左节点左孩子 que.push(rightNode-&gt;right); // 右节点右孩子 que.push(leftNode-&gt;right); // 左节点右孩子 que.push(rightNode-&gt;left); // 右节点左孩子 &#125; return true; &#125;&#125;; 递归法判断左右子树是否互为翻转 1234567891011121314151617181920212223class Solution &#123;public: bool compare(TreeNode* left, TreeNode* right) &#123; // 首先排除空节点的情况 if (left == nullptr &amp;&amp; right == nullptr) return true; else if (left != nullptr &amp;&amp; right == nullptr) return false; else if (left == nullptr &amp;&amp; right != nullptr) return false; // 再排除数值不相同的情况 else if (left-&gt;val != right-&gt;val) return false; // 剩下：左右节点都不为空，且数值相等的情况 bool outside = compare(left-&gt;left, right-&gt;right); // 外侧：左子树：左，右子树：右 bool inside = compare(left-&gt;right, right-&gt;left); // 内侧：左子树：右，左子树：左 bool isSame = outside &amp;&amp; inside; // 左子树：中，右子树：中 return isSame; &#125; bool isSymmetric(TreeNode* root) &#123; if (root == nullptr) return true; return compare(root-&gt;left, root-&gt;right); &#125;&#125;; 572. 另一棵树的子树题目描述：给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。 示例：示例 1： 12输入：root = [3,4,5,1,2], subRoot = [4,1,2]输出：true 示例 2： 12输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出：false 提示： root 树上的节点数量范围是 [1, 2000] subRoot 树上的节点数量范围是 [1, 1000] -104 &lt;= root.val &lt;= 104 -104 &lt;= subRoot.val &lt;= 104 题解：12345678910111213141516171819202122232425class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (p == nullptr &amp;&amp; q == nullptr) return true; else if (!p || !q || p-&gt;val != q-&gt;val) return false; else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125; bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); bool flag = isSameTree(node, subRoot); if (flag) return true; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return false; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day32","date":"2024-04-28T06:37:24.908Z","updated":"2024-05-01T14:13:31.973Z","comments":true,"path":"p/leetcode/day32/","permalink":"https://krystencollins.github.io/p/leetcode/day32/","excerpt":"","text":"116. 填充每个节点的下一个右侧节点指针题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例：示例 1： 123输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#x27;#&#x27; 标志着每一层的结束。 示例 2: 12输入：root = []输出：[] 提示： 树中节点的数量在 [0, 212 - 1] 范围内 -1000 &lt;= node.val &lt;= 1000 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 题解：广度优先搜索层次遍历 12345678910111213141516171819class Solution &#123;public: Node* connect(Node* root) &#123; if (!root) return root; queue&lt;Node*&gt; que; que.push(root); while(!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; Node* node = que.front(); que.pop(); if (i != size - 1) node-&gt;next = que.front(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 利用已组织的next指针 123456789101112131415161718192021222324class Solution &#123;public: Node* connect(Node* root) &#123; if (!root) return root; // 从根节点出发 Node* leftmost = root; while (leftmost-&gt;left != nullptr) &#123; // 遍历本层已组织的链表，为下一层节点跟新next指针 Node* head = leftmost; while (head) &#123; head-&gt;left-&gt;next = head-&gt;right; if (head-&gt;next) &#123; head-&gt;right-&gt;next = head-&gt;next-&gt;left; &#125; // 指针向后移动 head = head-&gt;next; &#125; leftmost = leftmost-&gt;left; &#125; return root; &#125;&#125;; 深度优先搜索123456789101112131415class Solution &#123;public: Node* connect(Node* root) &#123; if (!root || !root-&gt;left || !root-&gt;right) return root; // 左孩子的next指针直接指向右孩子 root-&gt;left-&gt;next = root-&gt;right ; // 右孩子的next指针指向左边第一个兄弟节点（若存在，即当前next指针所指）的左孩子（一定存在，因为是满二叉树） if (root-&gt;next) &#123; root-&gt;right-&gt;next = root-&gt;next-&gt;left; &#125; connect(root-&gt;left); connect(root-&gt;right); return root; &#125;&#125;; 117. 填充每个节点的下一个右侧节点指针 II题目描述：给定一个二叉树： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。 初始状态下，所有 next 指针都被设置为 NULL 。 示例：示例 1： 123输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#x27;#&#x27; 表示每层的末尾。 示例 2： 12输入：root = []输出：[] 提示： 树中的节点数在范围 [0, 6000] 内 -100 &lt;= Node.val &lt;= 100 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。 题解：广度优先搜索123456789101112131415161718192021222324252627class Solution &#123;public: void handle(Node* &amp;last, Node* &amp;p, Node* &amp;nextStart) &#123; if (last) last-&gt;next = p; if (!nextStart) nextStart = p; last = p; &#125; Node* connect(Node* root) &#123; if (!root) return root; // 从根节点出发(每一层最左边节点) Node* start = root; while (start) &#123; // 遍历本层已组织的链表，为下一层节点跟新next指针 Node* last = nullptr; // 指向本层当前节点 前一个 节点 Node* nextStart = nullptr; // 指向本层当前节点 后一个节点 for (Node* p = start; p != nullptr; p = p-&gt;next) &#123; if (p-&gt;left) handle(last, p-&gt;left, nextStart); if (p-&gt;right) handle(last, p-&gt;right, nextStart); &#125; start = nextStart; &#125; return root; &#125;&#125;; 层次遍历1234567891011121314151617181920class Solution &#123;public: Node* connect(Node* root) &#123; if (root == nullptr) return root; queue&lt;Node*&gt; que; que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; Node* node = que.front(); que.pop(); if (i != size - 1) node-&gt;next = que.front(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 226. 翻转二叉树题目描述：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例：示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 示例 2： 12输入：root = [2,1,3]输出：[2,3,1] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题解：层次遍历1234567891011121314151617181920class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0 ; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); TreeNode* tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 递归法，前序遍历123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (root == nullptr) return root; TreeNode* tmp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; 迭代法，前序遍历123456789101112131415class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); swap(node-&gt;left, node-&gt;right); // 中 if (node-&gt;right) stk.push(node-&gt;right); // 右 if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; return root; &#125;&#125;; 统一迭代法，前序遍历1234567891011121314151617181920212223class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 if (node-&gt;left) stk.push(node-&gt;left); // 左 stk.push(node); // 中 stk.push(nullptr); &#125; else &#123; node = stk.top(); stk.pop(); swap(node-&gt;left, node-&gt;right); // 节点翻转逻辑 &#125; &#125; return root; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day31","date":"2024-04-26T01:05:38.902Z","updated":"2024-05-01T08:44:11.081Z","comments":true,"path":"p/leetcode/day31/","permalink":"https://krystencollins.github.io/p/leetcode/day31/","excerpt":"","text":"199. 二叉树的右视图题目描述：给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例：示例 1: 12输入: [1,2,3,null,5,null,4]输出: [1,3,4] 示例 2: 12输入: [1,null,3]输出: [1,3] 示例 3: 12输入: []输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 &lt;= Node.val &lt;= 100 题解：广度优先搜索1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; // 层次遍历每层最右边一个节点值 vector&lt;int&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); if (i == size - 1) result.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return result; &#125;&#125;; 深度优先搜索1234567891011121314151617181920class Solution &#123;public: void order(TreeNode* node, vector&lt;vector&lt;int&gt;&gt;&amp; vec, int depth) &#123; if (node == nullptr) return; if (vec.size() == depth) vec.push_back(vector&lt;int&gt;()); vec[depth].push_back(node-&gt;val); order(node-&gt;left, vec, depth + 1); order(node-&gt;right, vec, depth + 1); &#125; vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; vec; vector&lt;int&gt; result; order(root, vec, 0); for (auto v : vec) &#123; result.push_back(v.back()); &#125; return result; &#125;&#125;; 637. 二叉树的层平均值题目描述：给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。 示例：示例 1： 1234输入：root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。 示例 2: 12输入：root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000] 提示： 树中节点数量在 [1, 104] 范围内 -231 &lt;= Node.val &lt;= 231 - 1 题解：广度优先搜索123456789101112131415161718192021class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; vector&lt;double&gt; result; queue&lt;TreeNode*&gt; que; if (root) que.push(root); while (!que.empty()) &#123; int size = que.size(); double sum = 0; // 求和过程中直接转换为double类型，否则int越界 for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); sum += node-&gt;val; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(sum / size); &#125; return result; &#125;&#125;; 深度优先搜索accumulate();函数对vector数组求和，第三个参数 0 对应int型vector，0.0对应double型vector 空间复杂度过高 123456789101112131415161718192021class Solution &#123;public: void order(TreeNode* node, vector&lt;vector&lt;double&gt;&gt;&amp; vec, int depth) &#123; if (node == nullptr) return; if (vec.size() == depth) vec.push_back(vector&lt;double&gt;()); vec[depth].push_back((double)node-&gt;val); order(node-&gt;left, vec, depth + 1); order(node-&gt;right, vec, depth + 1); &#125; vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; vector&lt;vector&lt;double&gt;&gt; vec; vector&lt;double&gt; result; order(root, vec, 0); for (auto v : vec) &#123; double s = accumulate(v.begin(), v.end(), 0.0); result.push_back(s / v.size()); &#125; return result; &#125;&#125;; 429. N 叉树的层序遍历题目描述：给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 示例：示例 1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]] 示例 2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 提示： 树的高度不会超过 1000 树的节点总数在 [0, 10^4] 之间 题解：广度优先搜索12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; queue&lt;Node*&gt; que; if (root != nullptr) que.push(root); while(!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; for (int i = 0; i &lt; size; ++i) &#123; Node* node = que.front(); que.pop(); vec.push_back(node-&gt;val); for (int j = 0; j &lt; node-&gt;children.size(); ++j) &#123; que.push(node-&gt;children[j]); &#125; &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 深度优先搜索123456789101112131415161718class Solution &#123;public: void order(Node* node, int depth, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(node-&gt;val); for (auto child : node-&gt;children) &#123; order(child, depth + 1, result); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, depth, result); return result; &#125;&#125;; 515. 在每个树行中找最大值题目描述：给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 示例：示例1： 12输入: root = [1,3,2,5,3,null,9]输出: [1,3,9] 示例2： 12输入: root = [1,2,3]输出: [1,3] 提示： 二叉树的节点个数的范围是 [0,104] -231 &lt;= Node.val &lt;= 231 - 1 题解：广度优先遍历123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); int max = INT_MIN; for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); max = node-&gt;val &gt; max ? node-&gt;val : max; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(max); &#125; return result; &#125;&#125;; 深度优先搜索123456789101112131415161718class Solution &#123;public: void dfs(TreeNode* node, int depth, vector&lt;int&gt;&amp; result) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(node-&gt;val); // depth标记遍历到当前节点的高度，当遍历到depth高度的节点就判断是否更新该层最大值 result[depth] = max(result[depth], node-&gt;val); dfs(node-&gt;left, depth + 1, result); dfs(node-&gt;right, depth + 1, result); &#125; vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; result; int depth = 0; dfs(root, depth, result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day30","date":"2024-04-25T08:56:34.044Z","updated":"2024-05-01T08:42:21.845Z","comments":true,"path":"p/leetcode/day30/","permalink":"https://krystencollins.github.io/p/leetcode/day30/","excerpt":"","text":"102. 二叉树的层序遍历题目描述：给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法广度优先遍历 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 一定使用固定的size，因为que的size一直在变化 for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 时间复杂度：$O(n)$，每个节点进队出队各一次，渐近时间复杂度为$O(n)$ 空间复杂度：$O(n)$，队列种元素个数不超过n个 递归法深度优先搜索 1234567891011121314151617class Solution &#123;public: void order(TreeNode* node, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(node-&gt;val); order(node-&gt;left, result, depth + 1); order(node-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, result, depth); return result; &#125;&#125;; 107. 二叉树的层序遍历 II题目描述：给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法广度优先搜索，翻转结果数组 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 递归法翻转结果数组 123456789101112131415161718class Solution &#123;public: void orderBottom(TreeNode* node, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(node-&gt;val); orderBottom(node-&gt;left, result, depth + 1); orderBottom(node-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; orderBottom(root, result, depth); reverse(result.begin(), result.end()); return result; &#125;&#125;; 104. 二叉树的最大深度题目描述：给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：3 示例 2： 12输入：root = [1,null,2]输出：2 提示： 树中节点的数量在 [0, 104] 区间内。 -100 &lt;= Node.val &lt;= 100 题解：层次遍历12345678910111213141516171819class Solution &#123;public: int maxDepth(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); int depth = 0; while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; ++depth; &#125; return depth; &#125;&#125;; 前序遍历12345678910111213141516171819class Solution &#123;public: void order(TreeNode* node, int depth, int&amp; maxD) &#123; if (node == nullptr) return; // 若遇到叶子节点，判断当前深度是否大于 记录的最大深度 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; maxD = depth &gt; maxD ? depth : maxD; &#125; order(node-&gt;left, depth + 1, maxD); order(node-&gt;right, depth + 1, maxD); &#125; int maxDepth(TreeNode* root) &#123; int depth = 1; // 根节点深度为1 int maxD = 0; // 初始化最大深度为0 order(root, depth, maxD); return maxD; &#125;&#125;; 后序遍历先求左子树深度，再求右子树深度，最后取左右深度最大的数值 再加1（算上当前节点）， 123456789101112131415class Solution &#123;public: int getDepth(TreeNode* node) &#123; if (node == nullptr) return 0; int leftdepth = getDepth(node-&gt;left); // 左 int rightdepth = getDepth(node-&gt;right); // 右 int depth = 1 + max(leftdepth, rightdepth); // 中 return depth; &#125; int maxDepth(TreeNode* root) &#123; return getDepth(root); &#125;&#125;; 代码简洁版： 1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == nullptr) return 0; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;; 相似题目： 559. N 叉树的最大深度 111. 二叉树的最小深度题目描述：给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：2 示例 2： 12输入：root = [2,null,3,null,4,null,5,null,6]输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法层次遍历，广度优先搜索 1234567891011121314151617181920212223242526class Solution &#123;public: int minDepth(TreeNode* root) &#123; // 根节点为空，最小深度为0 if (root == nullptr) return 0; // 根节点不空，最小深度从1开始 int minD = 1; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); // 层次遍历，第一次遇到叶子节点时，即最小深度，直接返回，退出循环。 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; return minD; &#125; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; ++minD; &#125; return minD; &#125;&#125;; 前序遍历12345678910111213141516171819202122class Solution &#123;public: void order(TreeNode* node, int depth, int&amp; minD) &#123; if (node == nullptr) return; // 中：遇到叶子节点，判断当前深度是否小于 记录的最小深度 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; minD = depth &lt; minD ? depth : minD; &#125; order(node-&gt;left, depth + 1, minD); // 左 order(node-&gt;right, depth + 1, minD); // 右 &#125; int minDepth(TreeNode* root) &#123; // 根节点为空，最小深度为0 if (root == nullptr) return 0; int minD = INT_MAX; // 初始化最小深度 int depth = 1; // 根节点深度为1 // 递归层次遍历 order(root, depth, minD); return minD; &#125;&#125;; 后序遍历12345678910111213141516171819class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == nullptr) return 0; int leftDepth = minDepth(root-&gt;left); // 左 int rightDepth = minDepth(root-&gt;right); // 右 // 中 // 当左子树为空，右子树不为空，此时不是最低点 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; return 1 + rightDepth; &#125; // 当左子树不为空，右子树为空，此时不是最低点 if (root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return 1 + leftDepth; &#125; // 左右字数都为空（即叶子节点）或都不为空 return 1 + min(leftDepth, rightDepth); &#125;&#125;; 代码简洁版： 12345678910111213class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == nullptr) return 0; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; return 1 + minDepth(root-&gt;right); &#125; if (root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return 1 + minDepth(root-&gt;left); &#125; return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right)); &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day29","date":"2024-04-24T05:52:37.592Z","updated":"2024-04-25T08:56:02.037Z","comments":true,"path":"p/leetcode/day29/","permalink":"https://krystencollins.github.io/p/leetcode/day29/","excerpt":"","text":"递归三要素 确定递归函数的参数和返回值 确定哪些参数是递归过程中需要处理的，就这递归函数里加上这个参数，并明确每次递归的返回值是什么进而确定递归函数的返回类型 确定终止条件 确定单层递归逻辑 确定每层递归需要处理的信息，即递归的主体：重复调用自己来实现递归过程。 144. 二叉树的前序遍历题目描述：示例：示例 1： 12输入：root = [1,null,2,3]输出：[1,2,3] 示例 2： 12输入：root = []输出：[] 示例 3： 12输入：root = [1]输出：[1] 示例 4： 12输入：root = [1,2]输出：[1,2] 示例 5： 12输入：root = [1,null,2]输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 题解：递归法123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123; if (cur == nullptr) return; vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; traversal(root, result); return result; &#125;&#125;; 迭代法1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stk; vector&lt;int&gt; result; if (root == nullptr) return result; stk.push(root); while (!stk.empty()) &#123; TreeNode* cur = stk.top(); // 中 stk.pop(); result.push_back(cur-&gt;val); if (cur-&gt;right) stk.push(cur-&gt;right); // 右（空节点不入栈） if (cur-&gt;left) stk.push(cur-&gt;left); // 左（空节点不入栈） &#125; return result; &#125;&#125;; 统一迭代法1234567891011121314151617181920212223class Solution &#123; public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; if (node-&gt;right) stk.push(node-&gt;right); // 右 if (node-&gt;left) stk.push(node-&gt;left); // 左 stk.push(node); // 中 stk.push(nullptr); &#125; else &#123; node = stk.top(); stk.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;; 94. 二叉树的中序遍历题解：递归法：123456789101112131415class Solution &#123;public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123; if (cur == nullptr) return; traversal(cur-&gt;left, vec); // 左 vec.push_back(cur-&gt;val); // 中 traversal(cur-&gt;right, vec); // 右 &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; traversal(root, result); return result; &#125;&#125;; 迭代法：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; stk; TreeNode* cur = root; while (cur != nullptr || !stk.empty()) &#123; if (cur != nullptr) &#123; // 指针访问节点，访问到左子树最底层（不断往左） stk.push(cur); // 访问过的节点入栈 cur = cur-&gt;left; // 左 &#125; else &#123; // 栈不空 cur = stk.top(); // 弹出栈顶节点，表示要处理的节点（放入结果数组） stk.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 &#125; &#125; return result; &#125;&#125;; 统一迭代法：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); // 取出当前栈顶节点 stk.pop(); if (node != nullptr) &#123; // 若当前栈顶节点不为空 if (node-&gt;right) stk.push(node-&gt;right); // 右节点入栈（空节点不入栈） stk.push(node); // 中节点入栈 stk.push(nullptr); // 中节点访问过，但是还没处理，加入空节点作为标记 if (node-&gt;left) stk.push(node-&gt;left); // 左节点入栈（空节点不入栈） &#125; else &#123; // 若当前栈顶节点为空，说明下一个节点为之前访问过的 中节点 node = stk.top(); // 取出 “中节点”，加入结果数组 stk.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;; 145. 二叉树的后序遍历题解：递归法：123456789101112131415class Solution &#123;public: void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) &#123; if (cur == nullptr) return; traversal(cur-&gt;left, vec); // 左 traversal(cur-&gt;right, vec); // 右 vec.push_back(cur-&gt;val); // 中 &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; traversal(root, result); return result; &#125;&#125;; 迭代法：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; stk; vector&lt;int&gt; result; if (root == nullptr) return result; stk.push(root); while (!stk.empty()) &#123; TreeNode* cur = stk.top(); // 中 stk.pop(); result.push_back(cur-&gt;val); if (cur-&gt;left) stk.push(cur-&gt;left); // 左 if (cur-&gt;right) stk.push(cur-&gt;right); // 右 &#125; // 前序：中左右-&gt; 中右左 翻转-&gt; 左右中 // 后序：左右中 reverse(result.begin(), result.end()); return result; &#125;&#125;; 统一迭代法：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; stk; if (root != nullptr) stk.push(root); while (!stk.empty()) &#123; TreeNode* node = stk.top(); stk.pop(); if (node != nullptr) &#123; stk.push(node); // 中 stk.push(nullptr); if (node-&gt;right) stk.push(node-&gt;right); // 右 if (node-&gt;left) stk.push(node-&gt;left); // 左 &#125; else &#123; node = stk.top(); stk.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day28","date":"2024-04-23T06:11:31.924Z","updated":"2024-04-24T08:25:54.421Z","comments":true,"path":"p/leetcode/day28/","permalink":"https://krystencollins.github.io/p/leetcode/day28/","excerpt":"","text":"347. 前 K 个高频元素题目描述：给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例：示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 提示： 1 &lt;= nums.length &lt;= 105 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 题解：方法一：堆 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: // 仿函数，从大到小排序 class mycomparison &#123; public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123; return lhs.second &gt; rhs.second; &#125; &#125;; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;num[i], 对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); ++i) &#123; ++map[nums[i]]; &#125; // 对频率排序 // 使用优先级队列priority_queue, 定义一个小根堆，大小为k priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 遍历所有频率的数组，建立固定大小为k的小根堆 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); ++it) &#123; // 往堆插入元素时，在二叉树末尾插入，（优先级队列会不断调整，保证仍然是一个小根堆，即堆顶元素仍然是最小值） pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 若堆的大小大于k，则弹出堆顶的最小值，保证堆的大小为k pri_que.pop(); &#125; &#125; // 找出前k个高频元素，即当前堆里剩下的所有元素 vector&lt;int&gt; ans; for (int i = 0; i &lt; k; ++i) &#123; ans.push_back(pri_que.top().first); pri_que.pop(); &#125; return ans; &#125;&#125;; 时间复杂度：$O(nlog \\ k)$ 空间复杂度：$O(n)$ 1249. 移除无效的括号题目描述：给你一个由 &#39;(&#39;、&#39;)&#39; 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 &#39;(&#39; 或者 &#39;)&#39; （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例：示例 1： 123输入：s = &quot;lee(t(c)o)de)&quot;输出：&quot;lee(t(c)o)de&quot;解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。 示例 2： 12输入：s = &quot;a)b(c)d&quot;输出：&quot;ab(c)d&quot; 示例 3： 123输入：s = &quot;))((&quot;输出：&quot;&quot;解释：空字符串也是有效的 提示： 1 &lt;= s.length &lt;= 105 s[i] 可能是 &#39;(&#39;、&#39;)&#39; 或英文小写字母 题解：方法一：栈遍历s，遇到‘（’，将他的位置入栈； 遇到‘）’有两种可能，栈里有“（”，就出栈，没有‘（’即栈为空直接删除当前符号，此时s长度和下标需要–； 遍历完后如果栈不为空，说明存在‘（’没有匹配，故依次pop栈顶元素，逐个删除。 1234567891011121314151617181920212223242526class Solution &#123;public: string minRemoveToMakeValid(string s) &#123; stack&lt;int&gt; stk; int sLen = s.size(); for (int i = 0; i &lt; sLen; ++i) &#123; if (s[i] == &#x27;(&#x27; || s[i] == &#x27;)&#x27;) &#123; if (s[i] == &#x27;(&#x27;) &#123; // 遇到左括号 的位置 直接进栈 stk.push(i); &#125; else if (stk.empty()) &#123; // 遇到右括号，但是栈为空，说明没有与其匹配的左括号，则直接删除，且sLen--，i-- s.erase(i, 1); --sLen; --i; &#125; else &#123; // 遇到右括号且栈不为空，说明栈内有与其匹配的左括号，则将左括号出栈 stk.pop(); &#125; &#125; &#125; // 最后若栈不空，说明还剩余左括号（多余的“前置”左括号，则依次删除） while (!stk.empty()) &#123; s.erase(stk.top(), 1); stk.pop(); &#125; return s; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 方法二：统计右括号个数先统计右括号的总个数right，再遍历整个字符串： 若为‘(’，如果字符串右边还剩余‘)’，则ans保留’(‘，同时left++，right–； 若为’)’，如果前面已经保留了‘(’，则ans也需要保留该’)’，且left–表示消耗了一个‘(’。如果left&#x3D;&#x3D;0，则表示现在的这个’)’是多余的，ans不保留，且right–； 若为字母，则ans保留该字母。 123456789101112131415161718192021222324252627class Solution &#123;public: string minRemoveToMakeValid(string s) &#123; int left = 0; int right = count(begin(s), end(s), &#x27;)&#x27;); string ans = &quot;&quot;; for (auto&amp; ch : s) &#123; if (ch == &#x27;(&#x27;) &#123; if (right &gt; 0) &#123; ans += ch; ++left; --right; &#125; &#125; else if (ch == &#x27;)&#x27;) &#123; if (left &gt; 0) &#123; ans += ch; --left; &#125; else &#123; --right; &#125; &#125; else &#123; ans += ch; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day27","date":"2024-04-22T13:39:58.612Z","updated":"2024-04-23T07:04:14.907Z","comments":true,"path":"p/leetcode/day27/","permalink":"https://krystencollins.github.io/p/leetcode/day27/","excerpt":"","text":"155. 最小栈题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例：示例 1: 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： -231 &lt;= val &lt;= 231 - 1 pop、top 和 getMin 操作总是在 非空栈 上调用 push, pop, top, and getMin最多被调用 3 * 104 次 题解：方法一：辅助栈可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。 当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中； 当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出； 在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。 12345678910111213141516171819202122232425262728class MinStack &#123;public: stack&lt;int&gt; x_stk; stack&lt;int&gt; min_stk;public: MinStack() &#123; min_stk.push(INT_MAX); &#125; void push(int val) &#123; x_stk.push(val); min_stk.push(min(min_stk.top(), val)); &#125; void pop() &#123; x_stk.pop(); min_stk.pop(); &#125; int top() &#123; return x_stk.top(); &#125; int getMin() &#123; return min_stk.top(); &#125;&#125;; 时间复杂度：$O(1)$ 空间复杂度：$O(n)$ 方法二：对组12345678910111213141516171819202122232425262728293031class MinStack &#123;public: stack&lt;pair&lt;int, int&gt;&gt; stk; MinStack() &#123; &#125; void push(int val) &#123; int minCur; if (stk.empty()) &#123; minCur = val; &#125; else &#123; minCur = val &lt; stk.top().second ? val : stk.top().second; &#125; pair&lt;int, int&gt; p1(val, minCur); stk.push(p1); &#125; void pop() &#123; stk.pop(); &#125; int top() &#123; return stk.top().first; &#125; int getMin() &#123; return stk.top().second; &#125;&#125;; 时间复杂度：$O(1)$ 空间复杂度：$O(n)$ 方法三：保存差值12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack &#123;public: // stk存储差值：当前元素值 和 之前所有元素最小值 之间的差值 stack&lt;long long&gt; stk; long long min_val; // 记录当前元素之前（包含当前元素）所有元素的最小值public: MinStack() &#123; // min_val = INT_MAX; &#125; void push(int val) &#123; if (stk.empty()) &#123; stk.push(0); min_val = val; &#125; else &#123; stk.push(val - min_val); // 如果当前差值小于0，说明当前值小于保存的min_val，需要更新 min_val = val &lt; min_val ? val : min_val; &#125; &#125; void pop() &#123; long long diff = stk.top(); stk.pop(); // 如果diff小于0，说明之前push此元素更新了之前min_val,现在pop之后需要更新回上一个min_val min_val = diff &lt; 0 ? min_val - diff : min_val; &#125; int top() &#123; long long diff = stk.top(); // 若diff小于0，说明之前push此元素更新了min_val，“栈顶”的元素就等于min_val if (diff &lt; 0) &#123; return min_val; &#125; else &#123;// 否则，未更新min_val，val = min_val + diff return min_val + diff; &#125; &#125; int getMin() &#123; return min_val; &#125;&#125;; 时间复杂度：$O(1)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day26","date":"2024-04-21T04:00:02.651Z","updated":"2024-04-22T13:29:46.065Z","comments":true,"path":"p/leetcode/day26/","permalink":"https://krystencollins.github.io/p/leetcode/day26/","excerpt":"","text":"239. 滑动窗口最大值题目描述：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例：示例 1： 1234567891011输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2： 12输入：nums = [1], k = 1输出：[1] 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 1 &lt;= k &lt;= nums.length 题解：方法一：单调队列1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;private: class MyQueue &#123; // 单调队列（从大到小） public: deque&lt;int&gt; que; // 使用deque实现单调队列 // 每次弹出滑动窗口元素时，比较当前要弹出元素是否等于队列出口元素，如果相等则弹出 // 同时pop之前判断队列是否为空 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); &#125; &#125; // 如果push的元素大于队列入口元素，则将队列后端（入口处）元素弹出，直到push的元素小于等于队列入口处元素为止 // 保证队列里元素始终单调递减 void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; // 队列出口出元素始终为当前最大值 int front() &#123; return que.front(); &#125; &#125;;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; MyQueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; ++i) &#123; // 初始化滑动窗口内元素 que.push(nums[i]); &#125; result.push_back(que.front()); // 初始化滑动窗口最大值 for (int i = k; i &lt; nums.size(); ++i) &#123; que.pop(nums[i - k]); // 移除滑动窗口最前面元素 que.push(nums[i]); // 加入新元素到滑动窗口最后面 result.push_back(que.front()); // 记录当前滑动窗口最大值 &#125; return result; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(k)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day25","date":"2024-04-20T01:38:58.293Z","updated":"2024-04-21T03:59:34.852Z","comments":true,"path":"p/leetcode/day25/","permalink":"https://krystencollins.github.io/p/leetcode/day25/","excerpt":"","text":"1003. 检查替换后的词是否有效题目描述：给你一个字符串 s ，请你判断它是否 有效 。 字符串 s 有效 需要满足：假设开始有一个空字符串 t = &quot;&quot; ，你可以执行 任意次 下述操作将 t 转换为 s ： 将字符串 &quot;abc&quot; 插入到 t 中的任意位置。形式上，t 变为 tleft + &quot;abc&quot; + tright，其中 t == tleft + tright 。注意，tleft 和 tright 可能为 空 。 如果字符串 s 有效，则返回 true；否则，返回 false。 示例：示例 1： 12345输入：s = &quot;aabcbc&quot;输出：true解释：&quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;aabcbc&quot;因此，&quot;aabcbc&quot; 有效。 示例 2： 12345输入：s = &quot;abcabcababcc&quot;输出：true解释：&quot;&quot; -&gt; &quot;abc&quot; -&gt; &quot;abcabc&quot; -&gt; &quot;abcabcabc&quot; -&gt; &quot;abcabcababcc&quot;因此，&quot;abcabcababcc&quot; 有效。 示例 3： 123输入：s = &quot;abccba&quot;输出：false解释：执行操作无法得到 &quot;abccba&quot; 。 提示： 1 &lt;= s.length &lt;= 2 * 104 s 由字母 &#39;a&#39;、&#39;b&#39; 和 &#39;c&#39; 组成 题解：遍历字符串 s，将当前访问到的字符 c 压入栈 stk 中，如果栈元素数目大于等于 3且栈顶的 3个元素依次等于 ‘a’, ‘b’, ‘c’，那么将这三个元素出栈。如果最后栈为空，则字符串 s 有效。 12345678910111213class Solution &#123;public: bool isValid(string s) &#123; string stk; for (char ch : s) &#123; stk.push_back(ch); if (stk.size() &gt;= 3 &amp;&amp; stk.substr(stk.size() - 3, 3) == &quot;abc&quot;) &#123; stk.erase(stk.end()-3, stk.end()); &#125; &#125; return stk.empty(); &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: bool isValid(string s) &#123; // 若s的长度不是3的倍数，则字符串s一定不符合 if (s.size() % 3 != 0) return false; string stk; for (char ch : s) &#123; // 遍历到&#x27;a&#x27;或&#x27;b&#x27;时，直接入栈 if (ch == &#x27;a&#x27; || ch == &#x27;b&#x27;) &#123; stk.push_back(ch); &#125; else &#123; // 遍历到&#x27;c&#x27;，则弹出栈顶两个元素，且依次为&#x27;b&#x27;,&#x27;a&#x27;,说明匹配到一个“abc”，否则不匹配，字符串s无效 if (!stk.empty() &amp;&amp; stk.back() == &#x27;b&#x27;) &#123; stk.pop_back(); if (!stk.empty() &amp;&amp; stk.back() == &#x27;a&#x27;) &#123; stk.pop_back(); &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; &#125; return stk.empty(); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$o(n)$ 150. 逆波兰表达式求值题目描述：给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 &#39;+&#39;、&#39;-&#39;、&#39;*&#39; 和 &#39;/&#39; 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 示例：示例 1： 123输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 123输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3： 12345678910输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]输出：22解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 提示： 1 &lt;= tokens.length &lt;= 104 tokens[i] 是一个算符（&quot;+&quot;、&quot;-&quot;、&quot;*&quot; 或 &quot;/&quot;），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 题解：C++stoi、stol、stoll 函数用法 123456789101112131415161718192021class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; stk; for (int i = 0; i &lt; tokens.size(); ++i) &#123; if (tokens[i] == &quot;+&quot; || tokens[i] == &quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;) &#123; int num1 = stk.top(); stk.pop(); int num2 = stk.top(); stk.pop(); if (tokens[i] == &quot;+&quot;) stk.push(num2 + num1); if (tokens[i] == &quot;-&quot;) stk.push(num2 - num1); if (tokens[i] == &quot;*&quot;) stk.push(num2 * num1); if (tokens[i] == &quot;/&quot;) stk.push(num2 / num1); &#125; else &#123; stk.push(stoi(tokens[i])); &#125; &#125; return stk.top(); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day24","date":"2024-04-19T02:09:56.769Z","updated":"2024-04-20T02:21:07.368Z","comments":true,"path":"p/leetcode/day24/","permalink":"https://krystencollins.github.io/p/leetcode/day24/","excerpt":"","text":"28. 找出字符串中第一个匹配项的下标题目描述：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例：示例 1： 1234输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;输出：0解释：&quot;sad&quot; 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。 示例 2： 123输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;输出：-1解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。 提示： 1 &lt;= haystack.length, needle.length &lt;= 104 haystack 和 needle 仅由小写英文字符组成 题解：方法一：暴力枚举1234567891011121314151617181920class Solution &#123;public: int strStr(string haystack, string needle) &#123; int hLen = haystack.size(); int nLen = needle.size(); if (hLen &lt; nLen) return -1; for (int i = 0; i &lt; hLen - nLen + 1; ++i) &#123; int j = 0; for (int k = i; k &lt; hLen &amp;&amp; j &lt; nLen; ++k, ++j) &#123; if (haystack[k] != needle[j]) &#123; break; &#125; &#125; if (j == nLen) &#123; return i; &#125; &#125; return -1; &#125;&#125;; 时间复杂度：$O(nm)$ 空间复杂度：$O(1)$ 方法二：模式匹配(KMP)$Knuth-Morris-Pratt$ 12345678910111213141516171819202122232425262728```### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)#### 题目描述：给定一个只包括 `&#x27;(&#x27;`，`&#x27;)&#x27;`，`&#x27;&#123;&#x27;`，`&#x27;&#125;&#x27;`，`&#x27;[&#x27;`，`&#x27;]&#x27;` 的字符串 `s` ，判断字符串是否有效。有效字符串需满足：1. 左括号必须用相同类型的右括号闭合。2. 左括号必须以正确的顺序闭合。3. 每个右括号都有一个对应的相同类型的左括号。#### 示例：**示例 1：** 输入：s &#x3D; “()”输出：true 123**示例 2：** 输入：s &#x3D; “()[]{}”输出：true 123**示例 3：** 输入：s &#x3D; “(]”输出：false 1234567891011121314151617181920212223242526272829303132333435363738394041 #### **提示：**- `1 &lt;= s.length &lt;= 104`- `s` 仅由括号 `&#x27;()[]&#123;&#125;&#x27;` 组成#### 题解：```C++class Solution &#123;public: bool isValid(string s) &#123; int n = s.size(); // 若s长度为奇数，一定不匹配 if (n % 2 != 0) return false; string stk; for (char ch : s) &#123; if (!stk.empty()) &#123; // 若栈不空，并且栈顶元素与ch的右括号匹配，则栈顶元素出栈 if (stk.back() == &#x27;(&#x27; &amp;&amp; ch == &#x27;)&#x27; || stk.back() == &#x27;[&#x27; &amp;&amp; ch == &#x27;]&#x27; || stk.back() == &#x27;&#123;&#x27; &amp;&amp; ch == &#x27;&#125;&#x27;) &#123; stk.pop_back(); &#125; else if (ch == &#x27;)&#x27; || ch == &#x27; ]&#x27; || ch == &#x27;&#125;&#x27;) &#123; // 若栈顶元素与ch不匹配，且ch为右括号，则直接返回false，因为栈内始终为左括号 return false; &#125; else &#123; stk.push_back(ch); &#125; &#125; else &#123; stk.push_back(ch); &#125; &#125; return stk.empty(); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 1047. 删除字符串中的所有相邻重复项题目描述：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例：示例： 1234输入：&quot;abbaca&quot;输出：&quot;ca&quot;解释：例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 题解：123456789101112131415class Solution &#123;public: string removeDuplicates(string s) &#123; string stk; for (char ch : s) &#123; // 若栈不空且栈顶元素等于ch，找到相邻重复项，则栈顶元素出栈 if (!stk.empty() &amp;&amp; stk.back() == ch) &#123; stk.pop_back(); &#125; else &#123; stk.push_back(ch); &#125; &#125; return stk; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day23","date":"2024-04-19T02:09:42.042Z","updated":"2024-04-19T02:57:19.615Z","comments":true,"path":"p/leetcode/day23/","permalink":"https://krystencollins.github.io/p/leetcode/day23/","excerpt":"","text":"151. 反转字符串中的单词题目描述：给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例：示例 1： 12输入：s = &quot;the sky is blue&quot;输出：&quot;blue is sky the&quot; 示例 2： 123输入：s = &quot; hello world &quot;输出：&quot;world hello&quot;解释：反转后的字符串中不能存在前导空格和尾随空格。 示例 3： 123输入：s = &quot;a good example&quot;输出：&quot;example good a&quot;解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 &lt;= s.length &lt;= 104 s 包含英文大小写字母、数字和空格 &#39; &#39; s 中 至少存在一个 单词 进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 题解：123456789101112131415161718192021222324252627282930class Solution &#123;public: string reverseWords(string s) &#123; // 双指针移除字符串中多余的空格：前导空格，尾随空格，单词间多个空格 int pos = 0; for (int cur = 0; cur &lt; s.size(); ++cur) &#123; if (s[cur] != &#x27; &#x27;) &#123; s[pos++] = s[cur]; &#125; else if (s[cur] == &#x27; &#x27; &amp;&amp; pos &gt; 0 &amp;&amp; s[pos-1] != &#x27; &#x27;) &#123; s[pos++] = s[cur]; &#125; &#125; // 重新设置字符串大小 if (pos - 1 &gt; 0 &amp;&amp; s[pos - 1] == &#x27; &#x27;) &#123; // 去掉字符串末尾的空格 s.resize(pos - 1); &#125; else &#123; s.resize(pos); &#125; // 翻转整个字符串 reverse(s.begin(), s.end()); // 再逐个单词翻转 for (int i = 0, j = 0; j &lt;= s.size(); ++j) &#123; if (s[j] == &#x27; &#x27; || j == s.size()) &#123; reverse(s.begin() + i, s.begin() + j); i = j + 1; &#125; &#125; return s; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 232. 用栈实现队列题目描述：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例：示例 1： 12345678910111213输入：[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 提示： 1 &lt;= x &lt;= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */class MyQueue &#123;public: MyQueue() &#123; &#125; void push(int x) &#123; inStack.push(x); &#125; int pop() &#123; int ret = peek(); outStack.pop(); return ret; &#125; int peek() &#123; int ret; if (!outStack.empty()) &#123; ret = outStack.top(); &#125; else &#123; while(!inStack.empty()) &#123; outStack.push(inStack.top()); inStack.pop(); &#125; if (!outStack.empty()) &#123; ret = outStack.top(); &#125; &#125; return ret; &#125; bool empty() &#123; return isStack.empty() &amp;&amp; outStack.empty(); &#125;public: stack&lt;int&gt; inStack; // 输入栈 stack&lt;int&gt; outStack; // 输出栈&#125;; 时间复杂度：$O(1)$，push和empty为$O(1)$，pop和peek为均摊$O(1)$ 空间复杂度：$O(n)$，对于有n次push操作的情况，队列中有n个元素 225. 用队列实现栈题目描述：请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的标准操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例：示例： 12345678910111213输入：[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False 提示： 1 &lt;= x &lt;= 9 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 进阶：你能否仅用一个队列来实现栈。 题解：方法一：两个队列queue1用于存储栈内的元素，queue2作为入栈操作的辅助队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyStack &#123;public: deque&lt;int&gt; queue1; deque&lt;int&gt; queue2; MyStack() &#123; &#125; void push(int x) &#123; queue1.push_back(x); &#125; int pop() &#123; int ret; while (!queue1.empty()) &#123; ret = queue1.front(); queue1.pop_front(); if (!queue1.empty())&#123; queue2.push_back(ret); &#125; &#125; while (!queue2.empty()) &#123; queue1.push_back(queue2.front()); queue2.pop_front(); &#125; return ret; &#125; int top() &#123; return queue1.back(); &#125; bool empty() &#123; return queue1.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 方法二：一个队列入栈操作时，首先获得入栈前的元素个数n，然后将新元素入队到队列，再将队列中前n个元素（即除了新入栈的元素除外的全部元素）依次出队并入队到队列，此时队列的前端元素即为新入栈的元素，且队列前端和后端分别对应栈顶和栈底，并且一直保持这个关系 12345678910111213141516171819202122232425262728293031class MyStack &#123;public: queue&lt;int&gt; q; MyStack() &#123; &#125; void push(int x) &#123; int n = q.size(); q.push(x); for (int i = 0; i &lt; n; ++i) &#123; q.push(q.front()); q.pop(); &#125; &#125; int pop() &#123; int ret = q.front(); q.pop(); return ret; &#125; int top() &#123; return q.front(); &#125; bool empty() &#123; return q.empty(); &#125;&#125;; 时间复杂度：入栈操作$O(n)$，其余操作$O(1)$ 空间复杂度：$O(n)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day22","date":"2024-04-17T09:19:15.191Z","updated":"2024-04-19T02:15:45.506Z","comments":true,"path":"p/leetcode/day22/","permalink":"https://krystencollins.github.io/p/leetcode/day22/","excerpt":"","text":"541. 反转字符串 II题目描述：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例：示例 1： 12输入：s = &quot;abcdefg&quot;, k = 2输出：&quot;bacdfeg&quot; 示例 2： 12输入：s = &quot;abcd&quot;, k = 2输出：&quot;bacd&quot; 提示： 1 &lt;= s.length &lt;= 104 s 仅由小写英文组成 1 &lt;= k &lt;= 104 题解：12345678910class Solution &#123;public: string reverseStr(string s, int k) &#123; int n = s.size(); for (int i = 0; i &lt; s.size(); i += 2 * k) &#123; reverse(s.begin() + i, s.begin() + min(i + k, n)); &#125; return s; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 123456789101112131415161718192021class Solution &#123;public: void reverseString(string&amp; s, int left, int right) &#123; for (int i = left, j = right; i &lt; left+(right - left+1)/2; ++i, --j) &#123; swap(s[i], s[j]); &#125; &#125; string reverseStr(string s, int k) &#123; for (int i = 0; i &lt; s.size();) &#123; if (i + 2*k-1 &lt; s.size() || s.size()-i &gt;= k) &#123; reverseString(s, i, i+k-1); i += 2*k; &#125; else if (s.size()-i &lt; k) &#123; reverseString(s, i, s.size()-1); break; &#125; &#125; return s; &#125;&#125;; 557. 反转字符串中的单词 III题目描述：给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例：示例 1： 12输入：s = &quot;Let&#x27;s take LeetCode contest&quot;输出：&quot;s&#x27;teL ekat edoCteeL tsetnoc&quot; 示例 2: 12输入： s = &quot;Mr Ding&quot;输出：&quot;rM gniD&quot; 提示： 1 &lt;= s.length &lt;= 5 * 104 s 包含可打印的 ASCII 字符。 s 不包含任何开头或结尾空格。 s 里 至少 有一个词。 s 中的所有单词都用一个空格隔开。 题解：123456789101112class Solution &#123;public: string reverseWords(string s) &#123; for (int i = 0, j = 0; j &lt;= s.size(); ++j) &#123; if (s[j] == &#x27; &#x27; || j == s.size()) &#123; reverse(s.begin() + i, s.begin() + j); i = j + 1; &#125; &#125; return s; &#125;&#125;; 54. 替换数字题目描述：题目描述给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。 输入描述输入一个字符串 s,s 仅包含小写字母和数字字符。 输出描述打印一个新的字符串，其中每个数字字符都被替换为了number 输入示例1a1b2c3 输出示例1anumberbnumbercnumber 提示信息数据范围：1 &lt;&#x3D; s.length &lt; 10000。 题解：方法一1234567891011121314151617181920#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; // cout &lt;&lt; s &lt;&lt; endl; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; cout &lt;&lt; &quot;number&quot;; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; return 0;&#125; 方法二：双指针12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; string s; while(cin &gt;&gt; s) &#123; int count = 0; int sOldIndex = s.size() - 1; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; ++count; &#125; &#125; s.resize(s.size() + count * 5); int sNewIndex = s.size() - 1; while (sOldIndex &gt;= 0) &#123; if(s[sOldIndex] &gt;= &#x27;0&#x27; &amp;&amp; s[sOldIndex] &lt;= &#x27;9&#x27;) &#123; s[sNewIndex--] = &#x27;r&#x27;; s[sNewIndex--] = &#x27;e&#x27;; s[sNewIndex--] = &#x27;b&#x27;; s[sNewIndex--] = &#x27;m&#x27;; s[sNewIndex--] = &#x27;u&#x27;; s[sNewIndex--] = &#x27;n&#x27;; &#125; else &#123; s[sNewIndex--] = s[sOldIndex]; &#125; --sOldIndex; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day21","date":"2024-04-16T06:22:02.854Z","updated":"2024-04-17T09:19:00.236Z","comments":true,"path":"p/leetcode/day21/","permalink":"https://krystencollins.github.io/p/leetcode/day21/","excerpt":"","text":"344. 反转字符串题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 O(1) 的额外空间解决这一问题。 示例：示例 1： 12输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 提示： 1 &lt;= s.length &lt;= 105 s[i] 都是 ASCII 码表中的可打印字符 题解：12345678class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; for (int i = 0, j = s.size() - 1; i &lt; s.size() / 2; ++i, --j) &#123; swap(s[i], s[j]); &#125; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day20","date":"2024-04-15T02:17:49.402Z","updated":"2024-04-16T07:24:10.250Z","comments":true,"path":"p/leetcode/day20/","permalink":"https://krystencollins.github.io/p/leetcode/day20/","excerpt":"","text":"454. 四数相加 II题目描述：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例：示例 1： 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 &lt;= n &lt;= 200 -2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28 题解：分组+哈希表 12345678910111213141516171819202122class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; umap; // key: a+b的数值，value：a+b数值出现次数 // 遍历nums1和nums2，统计两个数组元素之和，和出现的次数， for (int a : nums1) &#123; for (int b : nums2) &#123; ++umap[a + b]; &#125; &#125; int ans = 0; // 统计a+b+c+d=0出现的次数 // 遍历nums3和nums4，判断0-(c+d)是否在umap出现过，并统计次数 for (int c : nums3) &#123; for (int d : nums4) &#123; if (umap.find(0 - (c + d)) != umap.end()) &#123; ans += umap[0 - (c + d)]; &#125; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$，哈希表映射所需空间，最坏情况下nums1和nums2的值各不相同，和的个数为 $n^2$ 15. 三数之和题目描述：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例：示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 题解：方法一：排序+哈希表123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出a+b+c=0 // a = nums[i], b = nums[j], c = 0-(a+b) for (int i = 0; i &lt; nums.size(); ++i) &#123; // 排序之后如果第一个元素已经大于零，那么不可能组成三元组 if (nums[i] &gt; 0) &#123; break; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // 三元组a元素的去重 continue; &#125; unordered_set&lt;int&gt; set; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (j &gt; i + 2 &amp;&amp; nums[j] == nums[j-1] &amp;&amp; nums[j-1] == nums[j-2]) &#123; // 三元组b元素的去重 continue; &#125; int c = 0 - (nums[i] + nums[j]); if (set.find(c) != set.end()) &#123; result.push_back(&#123;nums[i], nums[j], c&#125;); set.erase(c); // 三元组c元素去重 &#125; else &#123; set.insert(nums[j]); &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 方法二：排序+双指针1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出 a+b+c=0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] &gt; 0) &#123; break; &#125; // 错误去重a的方法 // if (nums[i] == nums[i+1]) &#123; // continue; // &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; // 去重的逻辑如果放在这，(0,0,0)这种情况可能直接导致right&lt;=left, // while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; // while left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; if (nums[i] + nums[left] + nums[right] &gt; 0) &#123; --right; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123; ++left; &#125; else &#123; result.push_back(&#123;nums[i], nums[left], nums[right]&#125;); // 去重的逻辑应该放在找到第一个三元组之后，对b和c去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; // 找到答案时，双指针同时收缩 --right; ++left; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(log \\ n)$ 18. 四数之和题目描述：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例：示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 题解：方法一： 排序+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k &lt; nums.size(); ++k) &#123; // 剪枝操作 if (nums[k] &gt; target &amp;&amp; nums[k] &gt;= 0) &#123; break; // 这里使用break，统一通过最后的return返回 &#125; // 对nums[k]去重 if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) &#123; continue; &#125; for (int i = k + 1; i &lt; nums.size(); ++i) &#123; // 2级剪枝 if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) &#123; break; &#125; // 对nums[i]去重 if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; // nums[k] + nums[i] + nums[left] + nums[right] &gt; target会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123; --right; &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right] &lt; target) &#123; ++left; &#125; else &#123; result.push_back(&#123;nums[k], nums[i], nums[left], nums[right]&#125;); // 对nums[left]和nums[right]去重 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; // 找到答案，同时收缩双指针 --right; ++left; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^3)$ 空间复杂度：$O(log \\ n)$ 16. 最接近的三数之和题目描述：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例：示例 1： 123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 示例 2： 12输入：nums = [0,0,0], target = 1输出：0 提示： 3 &lt;= nums.length &lt;= 1000 -1000 &lt;= nums[i] &lt;= 1000 -104 &lt;= target &lt;= 104 题解：排序+双指针 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int ans = 0; int d = INT_MAX; int sum = 0; sort(nums.begin(), nums.end()); // 找出 a+b+c尽可能接近target // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); ++i) &#123; // 错误去重a的方法 // if (nums[i] == nums[i+1]) &#123; // continue; // &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; sum = nums[i] + nums[left] + nums[right]; if (sum &gt; target) &#123; --right; &#125; else if (sum &lt; target) &#123; ++left; &#125; else &#123; return sum; &#125; if (d &gt; abs(target - sum)) &#123; d = abs(target - sum); ans = sum; &#125; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(log \\ n)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day19","date":"2024-04-15T01:38:00.039Z","updated":"2024-04-15T02:17:05.155Z","comments":true,"path":"p/leetcode/day19/","permalink":"https://krystencollins.github.io/p/leetcode/day19/","excerpt":"","text":"202. 快乐数题目描述：编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例：示例 1： 1234567输入：n = 19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 示例 2： 12输入：n = 2输出：false 提示： 1 &lt;= n &lt;= 2^31 - 1 题解：方法一：哈希表1234567891011121314151617181920212223242526class Solution &#123;public: bool isHappy(int n) &#123; unordered_set&lt;int&gt; hash_table; while (true) &#123; // 取数值各个位上的单数之和 int sum = 0; while (n) &#123; int i = n % 10; n = n / 10; sum += i * i; &#125; if (sum == 1) &#123; return true; &#125; // 如果这个sum曾经出现过，说明已经陷入无限循环，立刻返回false if (hash_table.count(sum)) &#123; return false; &#125; else &#123; hash_table.insert(sum); &#125; n = sum; &#125; return false; &#125;&#125;; 时间复杂度：$O(log \\ n)$ 空间复杂度：$O(long \\ n)$ 方法二：快慢指针（略） 258. 各位相加题目描述：给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果 示例：示例 1: 123456输入: num = 38输出: 2 解释: 各位相加的过程为：38 --&gt; 3 + 8 --&gt; 1111 --&gt; 1 + 1 --&gt; 2由于 2 是一位数，所以返回 2。 示例 2: 12输入: num = 0输出: 0 提示： 0 &lt;= num &lt;= 2^31 - 1 进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？ 题解：1234567891011121314class Solution &#123;public: int addDigits(int num) &#123; while (num &gt;= 10) &#123; int sum = 0; while (num) &#123; sum += num % 10; num /= 10; &#125; num = sum; &#125; return num; &#125;&#125;; 时间复杂度：$O(num)$ 空间复杂度：$O(1)$ 1. 两数之和题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例：示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 题解：方法一：暴力枚举12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (nums[i] + nums[j] == target) &#123; return &#123;i, j&#125;; &#125; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二：哈希表1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_table; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash_table.count(target - nums[i])) &#123; return &#123;i, hash_table[target - nums[i]]&#125;; &#125; else &#123; hash_table[nums[i]] = i; &#125; &#125; return &#123;&#125;; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash_table; for (int i = 0; i &lt; nums.size(); ++i) &#123; auto it = hash_table.find(target - nums[i]); if (it != hash_table.end()) &#123; return &#123;i, it-&gt;second&#125;; &#125; else &#123; // hash_table[nums[i]] = i; hash_table.insert(pair&lt;int, int&gt;(nums[i], i)); &#125; &#125; return &#123;&#125;; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day18","date":"2024-04-13T01:42:52.213Z","updated":"2024-04-13T15:04:13.729Z","comments":true,"path":"p/leetcode/day18/","permalink":"https://krystencollins.github.io/p/leetcode/day18/","excerpt":"","text":"349. 两个数组的交集题目描述：给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例：示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 示例 2： 123输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 题解：方法一：排序+双指针123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); vector&lt;int&gt; ans; for (int i = 0, j = 0; i &lt; nums1.size() &amp;&amp; j &lt; nums2.size(); ) &#123; if (nums1[i] == nums2[j]) &#123; // 保证加入元素的唯一性 if (!ans.size() || ans.back() != nums1[i]) &#123; ans.push_back(nums1[i]); &#125; ++i; ++j; &#125; else if (nums1[i] &lt; nums2[j]) &#123; ++i; &#125; else if (nums1[i] &gt; nums2[j]) &#123; ++j; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(mlog \\ m + nlog \\ n)$，m和n分别是两个数组的长度。快排时间复杂度为$O(mlog \\ m)和O(nlog \\ n)$，双指针寻找交集元素时间复杂度为$O(m + n)$ 空间复杂度：$O(log \\ m + log \\ n)$，快排所需栈空间 方法二：两个集合1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; result_set; // 存放结果，用set为了给结果去重 unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end()); for (int num : nums2) &#123; // 发现nums2的元素在nums1中存在相同的 if (nums_set.find(num) != nums_set.end()) &#123; result_set.insert(num); &#125; &#125; return vector&lt;int&gt;(result_set.begin(), result_set.end()); &#125;&#125;; 时间复杂度：$O(m + n)$，m和n分别是两个数组的长度。 空间复杂度：$O(n)$， 方法三：哈希表1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; hash_table; vector&lt;int&gt; ans; // 建立数组nums1的哈希表 for (int i = 0; i &lt; nums1.size(); ++i) &#123; if (!hash_table.count(nums1[i])) &#123; hash_table.insert(nums1[i]); &#125; &#125; for (int i = 0; i &lt; nums2.size(); ++i) &#123; if (hash_table.count(nums2[i])) &#123; // 哈希表中存在相同元素，即交集 ans.push_back(nums2[i]); hash_table.erase(nums2[i]); // 在哈希表中删除已出现的相同元素 &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(m + n)$，m和n分别是两个数组的长度。 空间复杂度：$O(n)$， 350. 两个数组的交集 II题目描述：给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例：示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 1000 进阶： 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 题解：方法一：排序+双指针12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); vector&lt;int&gt; ans; for (int i = 0, j = 0; i &lt; nums1.size() &amp;&amp; j &lt; nums2.size(); ) &#123; if (nums1[i] == nums2[j]) &#123; // 不需要保证加入元素的唯一性 ans.push_back(nums1[i]); ++i; ++j; &#125; else if (nums1[i] &lt; nums2[j]) &#123; ++i; &#125; else if (nums1[i] &gt; nums2[j]) &#123; ++j; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(mlog \\ m + nlog \\ n)$，m和n分别是两个数组的长度。快排时间复杂度为$O(mlog \\ m)和O(nlog \\ n)$，双指针寻找交集元素时间复杂度为$O(m + n)$ 空间复杂度：$O(log \\ m + log \\ n)$，快排所需栈空间 方法二：哈希表为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及出现的次数，然后遍历较长数组得到交集 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; if (nums1.size() &gt; nums2.size()) &#123; return intersect(nums2, nums1); &#125; unordered_map&lt;int, int&gt; nums_map; // 记录nums1出现相同元素的次数 vector&lt;int&gt; ans; for (int num : nums1) &#123; if (!nums_map.count(num)) &#123; nums_map[num] = 1; &#125; else &#123; ++nums_map[num]; &#125; &#125; for (int num : nums2) &#123; // nums2存在相同元素，并且出现次数小于等于nums1 if (nums_map.count(num) &amp;&amp; nums_map[num] &gt; 0) &#123; ans.push_back(num); --nums_map[num]; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(m + n)$，m和n分别是两个数组的长度。 空间复杂度：$O(min(n, m))$， 如果nums2的元素存储在磁盘上，磁盘内存是有限的并且不能一次加载所有的元素到内存中。因此无法高效对nums2排序，只推荐使用方法二而不是方法一。在方法二中，nums2只关系到查询操作，因此每次读取nums2中的一部分数据，并进行处理即可。","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day17","date":"2024-04-12T15:15:16.703Z","updated":"2024-04-15T12:46:22.856Z","comments":true,"path":"p/leetcode/day17/","permalink":"https://krystencollins.github.io/p/leetcode/day17/","excerpt":"","text":"242. 有效的字母异位词题目描述：给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 注意：若 *s* 和 *t* 中每个字符出现的次数都相同，则称 *s* 和 *t* 互为字母异位词。 示例：示例 1: 12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2: 12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 提示: 1 &lt;= s.length, t.length &lt;= 5 * 104 s 和 t 仅包含小写字母 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题解：12345678910111213141516171819class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) &#123; return false; &#125; vector&lt;int&gt; hash_table(26, 0); for (auto&amp; ch: s) &#123; ++hash_table[ch - &#x27;a&#x27;]; &#125; for (auto&amp; ch: t) &#123; --hash_table[ch - &#x27;a&#x27;]; if (hash_table[ch - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(S)$，字符集大小S&#x3D;26 383. 赎金信题目描述：给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例：示例 1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例 2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例 3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 10^5 ransomNote 和 magazine 由小写英文字母组成 题解：方法一：暴力枚举12345678910111213141516171819class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; for (int i = 0; i &lt; magazine.size(); ++i) &#123; for (int j = 0; j &lt; ransomNote.size(); ++j) &#123; // 在ransomNote中找到和magazine相同的字符 if (magazine[i] == ransomNote[j]) &#123; ransomNote.erase(ransomNote.begin() + j); // ransomNote删除这个字符 break; &#125; &#125; &#125; // 如果ransomNote为空，则说明magazine的字符可以组成ransomNote if (ransomNote.size() == 0) &#123; return true; &#125; return false; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二：哈希表1234567891011121314151617181920212223class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.length() &gt; magazine.length()) &#123; return false; &#125; vector&lt;int&gt; hash_table(26, 0); for (auto&amp; ch: magazine) &#123; // 通过hash_table记录magazine里各个字符出现的次数 ++hash_table[ch - &#x27;a&#x27;]; &#125; for (auto&amp; ch: ransomNote)&#123; // 遍历ransomNote，在hash_table里对应字符个数作--操作 --hash_table[ch - &#x27;a&#x27;]; // 如果小于零说明ransomNote里出现的字符，magazine没出现或者出现个数不足 if (hash_table[ch - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(S)$，字符集大小S&#x3D;26 438. 找到字符串中所有字母异位词题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例：示例 1: 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 示例 2: 123456输入: s = &quot;abab&quot;, p = &quot;ab&quot;输出: [0,1,2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。 提示: 1 &lt;= s.length, p.length &lt;= 3 * 104 s 和 p 仅包含小写字母 题解：方法一：滑动窗口12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int sLen = s.length(); int pLen = p.length(); if (sLen &lt; pLen) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; ans; // 建立两个数组存放字符串中字母出现的词频 vector&lt;int&gt; sCount(26, 0); vector&lt;int&gt; pCount(26, 0); // 初始化滑动窗口，当滑动窗口位于s[0]时 for (int i = 0; i &lt; pLen; ++i) &#123; ++sCount[s[i] - &#x27;a&#x27;]; // 记录s中前pLen个字母的词频 ++pCount[p[i] - &#x27;a&#x27;]; // 记录要寻找的p字符串的每个字母词频（只统计一次） &#125; if (sCount == pCount) &#123; // 判断初始滑动窗口是否是异位词 ans.push_back(0); &#125; for (int i = 1; i &lt;= sLen - pLen; ++i) &#123; // 滑动窗口开始滑动，从s的下标1开始 --sCount[s[i - 1] - &#x27;a&#x27;]; // 将滑动窗口前一位字母的词频减去 ++sCount[s[i - 1 + pLen] - &#x27;a&#x27;]; // 增加滑动窗口新加入最后一位字母的词频 if (sCount == pCount) &#123; // 判断当前滑动窗口是否是异位词 ans.push_back(i); &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(m+(n-m)×S)$，n为字符串s的长度，m为字符串p的长度，S为所有可能的字符数，S&#x3D;26 空间复杂度：$O(S)$， 567. 字符串的排列题目描述：给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。 换句话说，s1 的排列之一是 s2 的 子串 。 示例：示例 1： 123输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出：true解释：s2 包含 s1 的排列之一 (&quot;ba&quot;). 示例 2： 12输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出：false 提示： 1 &lt;= s1.length, s2.length &lt;= 104 s1 和 s2 仅包含小写字母 题解：方法一：滑动窗口123456789101112131415161718192021222324252627282930class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int len1 = s1.size(), len2 = s2.size(); if (len1 &gt; len2) &#123; return false; &#125; vector&lt;int&gt; hash1(26, 0); vector&lt;int&gt; hash2(26, 0); for (int i = 0; i &lt; len1; ++i) &#123; ++hash1[s1[i] - &#x27;a&#x27;]; ++hash2[s2[i] - &#x27;a&#x27;]; &#125; if (hash1 == hash2) &#123; return true; &#125; for (int i = 1; i &lt;= len2 - len1; ++i) &#123; --hash2[s2[i - 1] - &#x27;a&#x27;]; ++hash2[s2[i - 1 + len1] - &#x27;a&#x27;]; if (hash1 == hash2) &#123; return true; &#125; &#125; return false; &#125;&#125;; 时间复杂度：$O(m+(n-m)×S)$，n为字符串s的长度，m为字符串p的长度，S为所有可能的字符数，S&#x3D;26 空间复杂度：$O(S)$，","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day16","date":"2024-04-11T01:46:47.524Z","updated":"2024-04-11T15:01:19.680Z","comments":true,"path":"p/leetcode/day16/","permalink":"https://krystencollins.github.io/p/leetcode/day16/","excerpt":"","text":"61. 旋转链表题目描述：给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。 示例：示例 1： 12输入：head = [1,2,3,4,5], k = 2输出：[4,5,1,2,3] 示例 2： 12输入：head = [0,1,2], k = 4输出：[2,0,1] 提示： 链表中节点的数目在范围 [0, 500] 内 -100 &lt;= Node.val &lt;= 100 0 &lt;= k &lt;= 2 * 109 题解：1234567891011121314151617181920212223class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if (head == nullptr || head-&gt;next == nullptr || k == 0) return head; int len = 1; // 统计链表长度 ListNode* tail = head; // 记录链表最后一个节点 while (tail-&gt;next) &#123; ++len; tail = tail-&gt;next; &#125; if (k % len == 0) return head; // 当向右移动个数为0时不需要截断！！！ int m = len - k % len; // 取模，实际向右移动节点个数(k%len) ListNode* pre = head; // 找到倒数第（k%len）个节点前一个位置 while (--m) &#123; pre = pre-&gt;next; &#125; ListNode* dummy = pre-&gt;next; pre-&gt;next = nullptr; tail-&gt;next = head; return dummy; &#125;&#125;; 时间复杂度：$O(n)$ 最坏情况下，需要遍历链表两次 空间复杂度：$O(1)$ 2. 两数相加题目描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：示例 1： 123输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807. 示例 2： 12输入：l1 = [0], l2 = [0]输出：[0] 示例 3： 12输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 &lt;= Node.val &lt;= 9 题目数据保证列表表示的数字不含前导零 题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(0, nullptr); ListNode* p1 = l1; ListNode* p2 = l2; ListNode* tail = dummy; int carry = 0; while (l1 &amp;&amp; l2) &#123; int sum = l1-&gt;val + l2-&gt;val + carry; // 计算本位和 if (sum &gt;= 10) &#123; // 是否有进位 carry = 1; &#125; else &#123; carry = 0; &#125; // 无论是否进位都 mod 10 ListNode* tmp = new ListNode(sum % 10, nullptr); tail-&gt;next = tmp; tail = tail-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; // 继续相加更高位 if (l2 != nullptr) l1 = l2; while (l1) &#123; int sum = l1-&gt;val + carry; if (sum &gt;= 10) &#123; carry = 1; &#125; else &#123; carry = 0; &#125; ListNode* tmp = new ListNode(sum % 10, nullptr); tail-&gt;next = tmp; tail = tail-&gt;next; l1 = l1 -&gt;next; &#125; // 最后一位的进位 if (carry) &#123; ListNode* tmp = new ListNode(carry, nullptr); tail-&gt;next = tmp; &#125; return dummy-&gt;next; &#125;&#125;; 时间复杂度：$O(max(n, m))$，n和m分别为两个链表的长度 空间复杂度：$O(1)$，返回值不计入空间复杂度 123456789101112131415161718192021222324class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* head = nullptr; ListNode* tail = nullptr; int carry = 0; while (l1 || l2) &#123; int v1 = l1 ? l1-&gt;val : 0; int v2 = l2 ? l2-&gt;val : 0; int sum = v1 + v2 + carry; if (!head) &#123; head = tail = new ListNode(sum % 10, nullptr); &#125; else &#123; tail-&gt;next = new ListNode(sum % 10, nullptr); tail = tail-&gt;next; &#125; carry = sum / 10; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; &#125; if (carry) tail-&gt;next = new ListNode(carry, nullptr); return head; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day15","date":"2024-04-10T01:39:33.702Z","updated":"2024-04-10T07:08:00.183Z","comments":true,"path":"p/leetcode/day15/","permalink":"https://krystencollins.github.io/p/leetcode/day15/","excerpt":"","text":"83. 删除排序链表中的重复元素题目描述：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。 示例：示例 1： 12输入：head = [1,1,2]输出：[1,2] 示例 2： 12输入：head = [1,1,2,3,3]输出：[1,2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 题解：12345678910111213141516171819202122class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; // 若链表为空或只有一个节点，则直接返回头节点 if (head == nullptr || head-&gt;next == nullptr) return head; // 从第一个节点处断开，尾插法 ListNode* pre = head; ListNode* cur = head-&gt;next; pre-&gt;next = nullptr; while (cur) &#123; if (cur-&gt;val != pre-&gt;val) &#123; pre-&gt;next = cur; cur = cur-&gt;next; pre = pre-&gt;next; pre-&gt;next = nullptr; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125;; 12345678910111213141516class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == nullptr) return head; ListNode* cur = head; while (cur-&gt;next) &#123; if (cur-&gt;val == cur-&gt;next-&gt;val) &#123; cur-&gt;next = cur-&gt;next-&gt;next; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 82. 删除排序链表中的重复元素 II题目描述：给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。 示例：示例 1： 12输入：head = [1,2,3,3,4,4,5]输出：[1,2,5] 示例 2： 12输入：head = [1,1,1,2,3]输出：[2,3] 提示： 链表中节点数目在范围 [0, 300] 内 -100 &lt;= Node.val &lt;= 100 题目数据保证链表已经按升序 排列 题解：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; // 若链表为空或只有一个节点，则直接返回头节点 if (head == nullptr || head-&gt;next == nullptr) return head; // 尾插法 ListNode* dummy = new ListNode(0, nullptr); ListNode* tail = dummy; // 指向已排序链表 表尾 的前一个节点 ListNode* tmp = head; // 临时指针，用于判断节点是否重复， ListNode* cur = head-&gt;next; bool flag = true; while (cur) &#123; if (tmp-&gt;val == cur-&gt;val) &#123; while(cur &amp;&amp; cur-&gt;val == tmp-&gt;val) &#123; // 找到cur值不等于tmp值为止 cur = cur-&gt;next; &#125;; &#125; else &#123; tail-&gt;next = tmp; tmp-&gt;next = nullptr; tail = tail-&gt;next; &#125; if (cur) &#123; // 更新tmp 和 cur指针， tmp = cur; cur = cur-&gt;next; &#125; else &#123; // 若cur为空只可能来自内部while循环，此时链表尾部出现重复元素 flag = false; &#125; &#125; if (flag) &#123; tail-&gt;next = tmp; tmp-&gt;next = nullptr; &#125; head = dummy-&gt;next; delete dummy; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day14","date":"2024-04-09T05:14:13.496Z","updated":"2024-04-09T08:25:11.376Z","comments":true,"path":"p/leetcode/day14/","permalink":"https://krystencollins.github.io/p/leetcode/day14/","excerpt":"","text":"面试题 02.07. 链表相交题目描述：你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例：示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 题解：方法一：对齐表尾1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; int m = 0; // 链表A的长度 int n = 0; // 链表B的长度 ListNode* pa = headA; ListNode* pb = headB; while (pa) &#123; ++m; pa = pa-&gt;next; &#125; while (pb) &#123; ++n; pb = pb-&gt;next; &#125; // 将链表A和链表B尾节点对齐 pa = headA; pb = headB; if (m &gt; n) &#123; for (int i = 1; i &lt;= m - n; ++i) &#123; pa = pa-&gt;next; &#125; &#125; else &#123; for (int i = 1; i &lt;= n - m; ++i) &#123; pb = pb-&gt;next; &#125; &#125; // 遍历至相交节点，若没有相交节点则遍历至表尾(NULL) while (pa != pb) &#123; pa = pa-&gt;next; pb = pb-&gt;next; &#125; return pa; &#125;&#125;; 时间复杂度：$O(n + m)$ 空间复杂度：$O(1)$ 方法二：双指针 12345678910111213class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA == NULL || headB == NULL) return NULL; ListNode* pa = headA; ListNode* pb = headB; while (pa != pb) &#123; pa = pa == NULL ? headB : pa-&gt;next; pb = pb == NULL ? headA : pb-&gt;next; &#125; return pa; &#125;&#125;; 时间复杂度：$O(n + m)$ 空间复杂度：$O(1)$ 方法三：哈希表 123456789101112131415161718192021class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; unordered_set&lt;ListNode*&gt; visited; ListNode* tmp = headA; // 将链表A所有节点都加入哈希表 while (tmp) &#123; visited.insert(tmp); tmp = tmp-&gt;next; &#125; // 遍历链表B查看节点是否已加入哈希表 tmp = headB; while (tmp) &#123; if (visited.count(tmp)) &#123; return tmp; &#125; tmp = tmp-&gt;next; &#125; return NULL; &#125;&#125;; 时间复杂度：$O(m + n)$ 空间复杂度：$O(m)$，m尾链表A的长度 141. 环形链表题目描述：给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例：示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 题解：方法一：哈希表123456789101112131415class Solution &#123;public: bool hasCycle(ListNode *head) &#123; unordered_set&lt;ListNode*&gt; visited; ListNode* tmp = head; while (tmp) &#123; if(visited.count(tmp)) &#123; return true; &#125; visited.insert(tmp); tmp = tmp-&gt;next; &#125; return false; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 方法二：快慢指针慢指针走一步，快指针走两步 12345678910111213class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return true; &#125; return false; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 142. 环形链表 II题目描述：给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例：示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 &lt;= Node.val &lt;= 105 pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ 题解：方法一 ：哈希表123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; unordered_set&lt;ListNode*&gt; visited; ListNode* tmp = head; while (tmp) &#123; if (visited.count(tmp)) &#123; return tmp; &#125; visited.insert(tmp); tmp = tmp-&gt;next; &#125; return NULL; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 方法二：快慢指针详细思路 123456789101112131415161718192021class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; // 当快慢指针相遇时，同时从head 和 相遇点开始查找 入环节点 if (slow == fast) &#123; ListNode* tmp = head; while (slow != tmp) &#123; slow = slow-&gt;next; tmp = tmp-&gt;next; &#125; return tmp; // 返回入环节点 &#125; &#125; return NULL; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 287. 寻找重复数题目描述：给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。 示例：示例 1： 12输入：nums = [1,3,4,2,2]输出：2 示例 2： 12输入：nums = [3,1,3,4,2]输出：3 示例 3 : 12输入：nums = [3,3,3,3,3]输出：3 提示： 1 &lt;= n &lt;= 105 nums.length == n + 1 1 &lt;= nums[i] &lt;= n nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 进阶： 如何证明 nums 中至少存在一个重复的数字? 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？ 题解：方法一：快慢指针 12345678910111213141516171819202122class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int slow = 0; int fast = 0; slow = nums[slow]; // slow = slow-&gt;next; fast = nums[nums[fast]]; // fast = fast-&gt;next-&gt;next; // 寻找重复元素 while (fast != slow) &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; // 寻找环入口 int index1 = 0; int index2 = slow; while (index1 != index2) &#123; index1 = nums[index1]; index2 = nums[index2]; &#125; return index1; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法二：二分查找（难理解）详细思路 1234567891011121314151617181920212223242526class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // 在[1,n]查找nums中重复元素 int left = 1; int right = len - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); // nums中小于等于mid的元素个数 int count = 0; for (int i = 0; i &lt; len; ++i) &#123; if (nums[i] &lt;= mid) &#123; ++count; &#125; &#125; if (count &gt; mid) &#123; right = mid; // 下一轮搜索[left, mid] &#125; else &#123; left = mid + 1; // 下一轮搜索[mid+1, right] &#125; &#125; return left; &#125;&#125;; 时间复杂度：$O(nlog \\ n)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day13","date":"2024-04-08T03:32:36.328Z","updated":"2024-04-09T04:52:42.871Z","comments":true,"path":"p/leetcode/day13/","permalink":"https://krystencollins.github.io/p/leetcode/day13/","excerpt":"","text":"19. 删除链表的倒数第 N 个结点题目描述：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例：示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 题解：方法一：计算链表长度123456789101112131415161718192021222324252627class Solution &#123;public: int getLength(ListNode* head) &#123; int length = 0; while (head) &#123; ++length; head = head-&gt;next; &#125; return length; &#125; ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(0, head); // 虚拟头节点 int length = getLength(head); // 获取链表长度 ListNode* cur = dummy; // 遍历到倒数第n个节点的前驱节点 for (int i = 1; i &lt;= length - n; ++i) &#123; cur = cur-&gt;next; &#125; ListNode* tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; delete tmp; head = dummy-&gt;next; delete dummy; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法二：栈1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(0, head); // 虚拟头节点 stack&lt;ListNode*&gt; stk; ListNode* cur = dummy; // 所有节点进栈 while (cur) &#123; stk.push(cur); cur = cur-&gt;next; &#125; // 倒数n个节点全部出栈后，栈顶元素即倒数第n个节点的前驱节点 for (int i = 1; i &lt;= n; ++i) &#123; stk.pop(); &#125; ListNode* pre = stk.top(); ListNode* tmp = pre-&gt;next; pre-&gt;next = tmp-&gt;next; delete tmp; head = dummy-&gt;next; delete dummy; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 方法三：双指针12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummyHead = new ListNode(0, head); // 虚拟头节点 ListNode* slow = dummyHead; ListNode* fast = dummyHead; // 快慢指针，快指针比慢指针快n个节点 for (int i = 1; i &lt;= n; ++i) &#123; fast = fast-&gt;next; &#125; // 同时后移快慢指针，当快指针指向尾节点时，慢指针指向倒数第n个节点前一个节点 while (fast-&gt;next != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; // 删除第n个节点 ListNode* tmp = slow-&gt;next; slow-&gt;next = tmp-&gt;next; delete tmp; // 回收虚拟头节点 head = dummyHead-&gt;next; delete dummyHead; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$","categories":[],"tags":[]},{"title":"两两交换链表中的节点","slug":"p/leetcode/day12","date":"2024-04-06T16:00:00.000Z","updated":"2024-07-03T03:19:55.401Z","comments":true,"path":"p/leetcode/day12/","permalink":"https://krystencollins.github.io/p/leetcode/day12/","excerpt":"","text":"24. 两两交换链表中的节点题目描述：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例：示例 1： 12输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 12输入：head = []输出：[] 示例 3： 12输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 题解：方法一：迭代123456789101112131415161718class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummyHead = new ListNode(0, head); ListNode* pre = dummyHead; ListNode* cur = head; while(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next) &#123; pre-&gt;next = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; pre-&gt;next-&gt;next = cur; pre = cur; cur = cur-&gt;next; &#125; head = dummyHead-&gt;next; delete dummyHead; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法二：递归12345678910111213class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* one = head; ListNode* two = one-&gt;next; ListNode* three = two-&gt;next; one-&gt;next = swapPairs(three); two-&gt;next = one; return two; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"回文链表","slug":"p/leetcode/day11","date":"2024-04-05T16:00:00.000Z","updated":"2024-07-03T03:18:31.508Z","comments":true,"path":"p/leetcode/day11/","permalink":"https://krystencollins.github.io/p/leetcode/day11/","excerpt":"","text":"234. 回文链表题目描述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 示例：示例 1： 12输入：head = [1,2,2,1]输出：true 示例 2： 12输入：head = [1,2]输出：false 提示： 链表中节点数目在范围[1, 105] 内 0 &lt;= Node.val &lt;= 9 题解：方法一： 栈1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; vector&lt;int&gt; st; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; st.push_back(slow-&gt;val); // 进栈 slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; if (fast) slow = slow-&gt;next; // 链表长度为奇数的情况 for (int i = st.size() - 1; i &gt;= 0; --i) &#123; if (st[i] != slow-&gt;val) return false; slow = slow-&gt;next; &#125; return true; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 方法二：快慢指针，反转后还原12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: ListNode* reverseList(ListNode* head, ListNode* start, ListNode* end) &#123; ListNode* pre = start; ListNode* cur = head; ListNode* tmp; while (cur != end) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125; bool isPalindrome(ListNode* head) &#123; // 快慢指针寻找中间节点 ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; // 反转链表前半部分 ListNode* firstHalfStart = reverseList(head, nullptr, slow); // 判断是否回文 bool ans = true; ListNode* p = firstHalfStart; if (fast) slow = slow-&gt;next; // 链表长度为奇数的情况 while (slow) &#123; if (slow-&gt;val != p-&gt;val) &#123; ans = false; break; &#125; slow = slow-&gt;next; p = p-&gt;next; &#125; // 还原链表并返回结果 head = reverseList(firstHalfStart, slow, nullptr); return ans; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法三：递归（难理解）123456789101112131415161718192021class Solution &#123; ListNode* frontPointer;public: bool recursivelyCheck(ListNode* currentNode) &#123; if (currentNode != nullptr) &#123; if (!recursivelyCheck(currentNode-&gt;next)) &#123; return false; &#125; if (currentNode-&gt;val != frontPointer-&gt;val) &#123; return false; &#125; frontPointer = frontPointer-&gt;next; &#125; return true; &#125; bool isPalindrome(ListNode* head) &#123; frontPointer = head; return recursivelyCheck(head); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$ 92. 反转链表 II题目描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 示例：示例 1： 12输入：head = [1,2,3,4,5], left = 2, right = 4输出：[1,4,3,2,5] 示例 2： 12输入：head = [5], left = 1, right = 1输出：[5] 提示： 链表中节点数目为 n 1 &lt;= n &lt;= 500 -500 &lt;= Node.val &lt;= 500 1 &lt;= left &lt;= right &lt;= n 题解：方法一：穿针引线12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverseList(ListNode* head, ListNode* start, ListNode* end) &#123; ListNode* pre = start; ListNode* cur = head; ListNode* tmp; while (cur != end) &#123; tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125; ListNode* reverseBetween(ListNode* head, int left, int right) &#123; if (left == right) return head; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = head; ListNode* start = dummyHead; ListNode* end = nullptr; ListNode* p = head; for (int i = 1; i &lt;= right &amp;&amp; p; ++i) &#123; if (i == left - 1) start = p; if (i == right) end = p; p = p-&gt;next; &#125; start-&gt;next = reverseList(start-&gt;next, end-&gt;next, end-&gt;next); head = dummyHead-&gt;next; delete dummyHead; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$(1)$ 方法二：头插法（只遍历一遍）123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int left, int right) &#123; ListNode* dummyHead = new ListNode(0, head); // 虚拟头节点 ListNode* pre = dummyHead; // 指向需要反转开始位置的前一个位置 for (int i = 1; i &lt; left; ++i) &#123; pre = pre-&gt;next; &#125; ListNode* cur = pre-&gt;next; for (int i = 1; i &lt;= right - left; ++i) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; tmp-&gt;next = pre-&gt;next; pre-&gt;next = tmp; &#125; head = dummyHead-&gt;next; delete dummyHead; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$(1)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"反转链表","slug":"p/leetcode/day10","date":"2024-04-04T16:00:00.000Z","updated":"2024-07-03T03:17:50.455Z","comments":true,"path":"p/leetcode/day10/","permalink":"https://krystencollins.github.io/p/leetcode/day10/","excerpt":"","text":"206. 反转链表题目描述：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例：示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 题解：方法一：迭代(头插法)123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* dummyHead = new ListNode(0); dummyHead-&gt;next = nullptr; ListNode* cur = head; while (cur) &#123; ListNode* tmp = cur; cur = cur-&gt;next; tmp-&gt;next = dummyHead-&gt;next; dummyHead-&gt;next = tmp; &#125; return dummyHead-&gt;next; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法二：双指针123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* tmp; // 保存cur的下一个节点 ListNode* cur = head; ListNode* pre = nullptr; while (cur) &#123; tmp = cur-&gt;next; // 保存cur的下一个节点，因为接下来要改变cur-&gt;next cur-&gt;next = pre; // 反转操作 pre = cur; // 更新pre和cur cur = tmp; &#125; return pre; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法三：递归（从前往后反转）12345678910111213141516171819class Solution &#123;public: ListNode* reverse(ListNode* pre, ListNode* cur) &#123; if (cur == NULL) return pre; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; // 反转操作 // 递归的做法与双指针的一致 // pre = cur; // cur = tmp; return reverse(cur, tmp); &#125; ListNode* reverseList(ListNode* head) &#123; // 和双指针法初始化一样的逻辑 // ListNode* cur = head; // ListNode* pre = nullpter; return reverse(NULL, head); &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$，递归调用了n层栈空间 方法四：递归（从后往前反转）1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head) return nullptr; if (!head-&gt;next) return head; // 递归调用，反转第二个节点开始往后的链表 ListNode* last = reverseList(head-&gt;next); // 反转头节点与第二个节点的指向 head-&gt;next-&gt;next = head; // 此时的head节点为尾节点，next需要指向nullptr head-&gt;next = nullptr; return last; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$，递归调用了n层栈空间","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"设计链表","slug":"p/leetcode/day9","date":"2024-04-03T16:00:00.000Z","updated":"2024-07-03T03:16:28.321Z","comments":true,"path":"p/leetcode/day9/","permalink":"https://krystencollins.github.io/p/leetcode/day9/","excerpt":"","text":"707. 设计链表题目描述：你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针&#x2F;引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例：示例： 1234567891011121314输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class MyLinkedList &#123;public: struct ListNode &#123; int val; // 当前节点的值 ListNode* next; // 指向下一个节点的指针 ListNode(int x) : val(x), next(nullptr) &#123;&#125; &#125;; MyLinkedList() &#123; // 构造函数 _size = 0; _dummyHead = new ListNode(0); // 虚拟头节点 &#125; int get(int index) &#123; // 获取链表中下标为index的节点的值 if (index &gt;= this-&gt;_size || index &lt; 0) return -1; ListNode* p = this-&gt;_dummyHead; for (int i = 0; i &lt;= index; ++i) &#123; p = p-&gt;next; &#125; return p-&gt;val; &#125; void addAtHead(int val) &#123; // 将值为val的节点插入到表头 /*ListNode* newNode = new ListNode(val); newNode-&gt;next = this-&gt;_dummyHead-&gt;next; this-&gt;_dummyHead-&gt;next = newNode; ++(this-&gt;_size);*/ addAtIndex(0, val); &#125; void addAtTail(int val) &#123; // 将值为val的节点插入到表尾 /*ListNode* newNode = new ListNode(val); ListNode* cur = this-&gt;_dummyHead; while (cur-&gt;next) &#123; cur = cur-&gt;next; &#125; cur-&gt;next = newNode; ++(this-&gt;_size);*/ addAtIndex(this-&gt;_size, val); &#125; void addAtIndex(int index, int val) &#123; // 将值为val的节点插入到下标为index的节点之前 if (index &gt; this-&gt;_size || index &lt; 0) return; // 如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。 ListNode* newNode = new ListNode(val); ListNode* pre = this-&gt;_dummyHead; for (int i = 0; i &lt; index; ++i) &#123; pre = pre-&gt;next; &#125; newNode-&gt;next = pre-&gt;next; pre-&gt;next = newNode; ++(this-&gt;_size); &#125; void deleteAtIndex(int index) &#123; // 删除下标为index的节点 if (index &gt;= this-&gt;_size || index &lt; 0) return; ListNode* pre = this-&gt;_dummyHead; for (int i = 0; i &lt; index; ++i) &#123; pre = pre-&gt;next; &#125; ListNode* tmp = pre-&gt;next; pre-&gt;next = tmp-&gt;next; delete tmp; tmp = nullptr; --(this-&gt;_size); &#125;private: int _size; ListNode* _dummyHead;&#125;; 时间复杂度：涉及index的相关操作为$O(index)$，其余为$O(1)$ 空间复杂度：$O(n)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"移除链表元素","slug":"p/leetcode/day8","date":"2024-04-02T16:00:00.000Z","updated":"2024-07-03T03:15:38.080Z","comments":true,"path":"p/leetcode/day8/","permalink":"https://krystencollins.github.io/p/leetcode/day8/","excerpt":"","text":"203. 移除链表元素题目描述：给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例：示例 1： 12输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 12输入：head = [], val = 1输出：[] 示例 3： 12输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 题解：方法一：递归12345678class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; if (head == nullptr) return head; head-&gt;next = removeElements(head-&gt;next, val); return head-&gt;val == val ? head-&gt;next : head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(n)$，n是链表长度，空间复杂度取决于递归调用栈，最多不会超过n层 方法二：遍历迭代养成手动清理内存的习惯！！！ 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点 dummyHead-&gt;next = head; ListNode* cur = dummyHead; while (cur-&gt;next != NULL) &#123; if (cur-&gt;next-&gt;val == val) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; head = dummyHead-&gt;next; delete dummyHead; return head; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 237. 删除链表中的节点题目描述：有一个单链表的 head，我们想删除它其中的一个节点 node。 给你一个需要删除的节点 node 。你将 无法访问 第一个节点 head。 链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。 删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是： 给定节点的值不应该存在于链表中。 链表中的节点数应该减少 1。 node 前面的所有值顺序相同。 node 后面的所有值顺序相同。 示例：示例 1： 123输入：head = [4,5,1,9], node = 5输出：[4,1,9]解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9 示例 2： 123输入：head = [4,5,1,9], node = 1输出：[4,5,9]解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9 提示： 链表中节点的数目范围是 [2, 1000] -1000 &lt;= Node.val &lt;= 1000 链表中每个节点的值都是 唯一 的 需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点 题解：123456789class Solution &#123;public: void deleteNode(ListNode* node) &#123; ListNode* tmp = node-&gt;next; node-&gt;val = tmp-&gt;val; node-&gt;next = tmp-&gt;next; delete tmp; &#125;&#125;; 时间复杂度：$O(1)$ 空间复杂度：$O(1)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"合并两个有序数组","slug":"p/leetcode/day7","date":"2024-04-01T16:00:00.000Z","updated":"2024-07-03T03:14:47.364Z","comments":true,"path":"p/leetcode/day7/","permalink":"https://krystencollins.github.io/p/leetcode/day7/","excerpt":"","text":"88. 合并两个有序数组题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例：示例 1： 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 1234输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 12345输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 题解：方法一：合并后排序先将数组nums2放进数组nums1的尾部，然后直接对整个数组进行排序 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for (int i = 0; i != n; ++i) &#123; nums1[m + i] = nums2[i]; &#125; sort(nums1.begin(), nums1.end()); &#125;&#125;; 时间复杂度：$O((m+n)log(m+n))$ 空间复杂度：$O(log(m+n))$ 方法二：逆向双指针12345678910111213141516171819class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int k = m + n - 1; // 从大到小归并排序，k指向结果数组下一个待填入位置 int j = n - 1; // 指向nums2待排序第一个元素位置 for (int i = m - 1; i &gt;= 0 &amp;&amp; j &gt;= 0;) &#123; if (nums1[i] &gt;= nums2[j]) &#123; nums1[k--] = nums1[i--]; &#125; else &#123; nums1[k--] = nums2[j--]; &#125; &#125; // 若m &lt;= n,nums2还有元素未排序，直接填入结果数组剩下位置 while (j &gt;= 0) &#123; nums1[k--] = nums2[j--]; &#125; // 若m &gt; n,nums1还有元素未排序则不需要处理，因为结果数组存储在nums1中 &#125;&#125;; 时间复杂度：$O(m+n)$ 空间复杂度：$O(1)$ 80. 删除有序数组中的重复项 II题目描述：给你一个有序数组 nums ，请你** 原地** 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例：示例 1： 123输入：nums = [1,1,1,2,2,3]输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,1,2,3,3]输出：7, nums = [0,0,1,1,2,3,3]解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 104 -104 &lt;= nums[i] &lt;= 104 nums 已按升序排列 题解：因为给定数组是有序的，所以相同元素必然连续。双指针遍历数组每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。 1234567891011121314151617class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int flag = 1; int slowIdx = 0; // 指向已确定数组最后一个位置 for (int fastIdx = 1; fastIdx &lt; nums.size(); ++fastIdx) &#123; if (nums[slowIdx] == nums[fastIdx] &amp;&amp; flag &lt; 2) &#123; nums[++slowIdx] = nums[fastIdx]; ++flag; &#125; else if (nums[slowIdx] != nums[fastIdx]) &#123; nums[++slowIdx] = nums[fastIdx]; flag = 1; &#125; &#125; return ++slowIdx; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 定义两个指针slowIdx和fastIdx分别为慢指针和快指针， 慢指针表示已处理出的数组的长度，nums[slow-1]指向上一个应该被保留的元素所移动到的位置 快指针表示已经检查过的数组的长度，即nums[fastIdx]指向待检查的第一个元素， 因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 nums[slow−2]是否和当前待检查元素 nums[fast]相同。当且仅当 nums[slow−2]=nums[fast]时，当前待检查元素 nums[fast]不应该被保留 **（因为此时必然有 nums[slow−2]=nums[slow−1]=nums[fast]）。 最后，slow 即为处理好的数组的长度。 特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。 1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 2) return n; int slowIdx = 2; for (int fastIdx = 2; fastIdx &lt; n; ++fastIdx) &#123; if (nums[slowIdx - 2] != nums[fastIdx]) &#123; nums[slowIdx++] = nums[fastIdx]; &#125; &#125; return slowIdx; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"水果成篮","slug":"p/leetcode/day6","date":"2024-03-31T16:00:00.000Z","updated":"2024-07-03T08:25:22.897Z","comments":true,"path":"p/leetcode/day6/","permalink":"https://krystencollins.github.io/p/leetcode/day6/","excerpt":"","text":"904. 水果成篮题目描述：你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。 示例：示例 1： 123输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。 示例 2： 1234输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 1234输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 123输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示： 1 &lt;= fruits.length &lt;= 105 0 &lt;= fruits[i] &lt; fruits.length 题解：1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"长度最小的子数组","slug":"p/leetcode/day5","date":"2024-03-30T16:00:00.000Z","updated":"2024-07-03T03:12:01.186Z","comments":true,"path":"p/leetcode/day5/","permalink":"https://krystencollins.github.io/p/leetcode/day5/","excerpt":"","text":"209. 长度最小的子数组题目描述：给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例：示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 12输入：target = 4, nums = [1,4,4]输出：1 示例 3： 12输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 题解：方法一：暴力解法两重循环，会超出时间限制！ 12345678910111213141516171819class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int minLen = INT32_MAX; // 最终结果 int sum = 0; // 子序列数值之和 for (int i = 0; i &lt; nums.size(); ++i) &#123; // 子序列起始起点i sum = 0; for (int j = i; j &lt; nums.size(); ++j) &#123; // 子序列终止起点j sum += nums[j]; if (sum &gt;= target) &#123; // 一旦发现子序列和超过target，更新minLen int subLen = j - i + 1; minLen = minLen &lt; subLen ? minLen : subLen; break; // 因为要找符合条件的 最短子序列，所以一旦符合条件就break &#125; &#125; &#125; return minLen == INT32_MAX ? 0 : minLen; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二：滑动窗口所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。 那么滑动窗口如何用一个for循环来完成这个操作呢。 首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。 如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？ 此时难免再次陷入 暴力解法的怪圈。 所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。 那么问题来了， 滑动窗口的起始位置如何移动呢？ 在本题中实现滑动窗口，主要确定如下三点： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。 123456789101112131415161718class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int minLen = INT32_MAX; // 最终结果 int sum = 0; // 滑动窗口数值之和 int slowIdx = 0; // 滑动窗口起始位置 for (int fastIdx = 0; fastIdx &lt; nums.size();++fastIdx) &#123; sum += nums[fastIdx]; while (sum &gt;= target) &#123; // 每次更新起始位置，并不断比较滑动窗口内是否符合条件 int subLen = fastIdx - slowIdx + 1; // 当前滑动窗口长度 minLen = minLen &lt; subLen ? minLen : subLen; sum -= nums[slowIdx++]; &#125; &#125; // 如果minLen没有被赋值，说明没有符合条件的子序列 return minLen == INT32_MAX ? 0: minLen; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法三：前缀和 + 二分查找12345678910111213141516171819202122232425262728class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; sums(n + 1, 0); // 存储nums的前缀和，sums[i]表示从nums[0]到nums[i-1]的元素和 for (int i = 1; i &lt;= n; ++i) &#123; sums[i] = sums[i - 1] + nums[i - 1]; &#125; if (sums[n] &lt; target) return 0; int minLen = INT32_MAX; for (int i = 0; i &lt;= n; ++i) &#123; int f = sums[i] + target; if (f &gt; sums[n]) break; int left = i; int right = n; while (left &lt;= right) &#123; // 二分查找sums数组中大于等于f的最小下标 int mid = left + ((right - left) &gt;&gt; 1); // 防止溢出，等同于(left + right) / 2 if (sums[mid] &gt;= f) &#123; // 第一个大于等于f在左区间，所以[left, mid - 1] right = mid - 1; &#125; else if (sums[mid] &lt; f) &#123; // 第一个大于等于f在右区间，所以[mid + 1, right] left = mid + 1; &#125; &#125; minLen = minLen &lt; left - i ? minLen : left - i; &#125; return minLen == INT32_MAX ? 0 : minLen; &#125;&#125;; 时间复杂度：$O(nlog \\ n)$ 空间复杂度：$O(1)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"比较含退格的字符串","slug":"p/leetcode/day4","date":"2024-03-29T16:00:00.000Z","updated":"2024-07-03T03:11:10.038Z","comments":true,"path":"p/leetcode/day4/","permalink":"https://krystencollins.github.io/p/leetcode/day4/","excerpt":"","text":"844. 比较含退格的字符串题目描述：给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例：示例 1： 123输入：s = &quot;ab#c&quot;, t = &quot;ad#c&quot;输出：true解释：s 和 t 都会变成 &quot;ac&quot;。 示例 2： 123输入：s = &quot;ab##&quot;, t = &quot;c#d#&quot;输出：true解释：s 和 t 都会变成 &quot;&quot;。 示例 3： 123输入：s = &quot;a#c&quot;, t = &quot;b&quot;输出：false解释：s 会变成 &quot;c&quot;，但 t 仍然是 &quot;b&quot;。 提示： 1 &lt;= s.length, t.length &lt;= 200 s 和 t 只含有小写字母以及字符 &#39;#&#39; 题解：方法一：双指针123456789101112131415161718class Solution &#123;public: string noBackspace(string str) &#123; int slowIdx = 0; // 指向已处理的 无退格字符子串的最后一个字符下一个位置 for (int fastIdx = 0; fastIdx &lt; str.size(); ++fastIdx) &#123; if (str[fastIdx] != &#x27;#&#x27;) &#123; str[slowIdx++] = str[fastIdx]; &#125; else if (slowIdx &gt; 0) &#123; --slowIdx; &#125; &#125; return str.substr(0, slowIdx); &#125; bool backspaceCompare(string s, string t) &#123; return noBackspace(s) == noBackspace(t); &#125;&#125;; 时间复杂度：$O(n + m)$ 空间复杂度：$O(1)$ 方法二：重构字符串（栈）用栈处理遍历过程，每次我们遍历到一个字符： 如果它是退格符，那么我们将栈顶弹出； 如果它是普通字符，那么我们将其压入栈中。 123456789101112131415161718class Solution &#123;public: bool backspaceCompare(string s, string t) &#123; return build(s) == build(t); &#125; string build(string str) &#123; string ret; for (char ch : str) &#123; if (ch != &#x27;#&#x27;) &#123; ret.push_back(ch); &#125; else if (!ret.empty()) &#123; ret.pop_back(); &#125; &#125; return ret; &#125;&#125;; 时间复杂度：$O(n+m)$ 空间复杂度：$O(n + m)$ 977. 有序数组的平方题目描述：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例：示例 1： 1234输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 12输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 题解：方法一：直接排序最直接的做法就是将数组nums中的元素平方后直接排序 12345678910class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; for (int i= 0; i &lt; nums.size(); ++i) &#123; nums[i] *= nums[i]; &#125; sort(nums.begin(), nums.end()); // 快速排序 return nums; &#125;&#125;; 时间复杂度：$O(nlong \\ n)$ 空间复杂度：$O(log \\ n)$ 方法二：双指针使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况， 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int k = nums.size() - 1; vector&lt;int&gt; ans(nums.size(), 0); for (int i = 0, j = k; i &lt;= j;) &#123; if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123; ans[k--] = nums[j] * nums[j]; --j; &#125; else &#123; ans[k--] = nums[i] * nums[i]; ++i; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$o(n)$ 空间复杂度：$O(n)$ 方法三：类归并排序方法一没有利用「数组$nums$已经按照升序排序」这个条件。显然，如果数组 $nums$中的所有数都是非负数，那么将每个数平方后，数组仍然保持升序；如果数组中的所有数都是负数，那么将每个数平方后，数组会保持降序。 这样一来，如果我们能够找到数组 $nums$ 中负数与非负数的分界线，那么就可以用类似「归并排序」的方法了。具体地，我们设 $neg$ 为数组 $nums$ 中负数与非负数的分界线，也就是说，$nums[0]$ 到 $nums[neg]$ 均为负数，而 $nums[neg+1]$ 到 $nums[n−1]$均为非负数。当我们将数组 $nums$中的数平方后，那么 $nums[0]$ 到 $nums[neg]$单调递减，$nums[neg+1]$到 $nums[n−1]$单调递增。 由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置$ neg$和 $neg+1$，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int negative = -1; for (int i = 0; i &lt; n; ++i) &#123; if (nums[i] &lt; 0) &#123; negative = i; &#125; else &#123; break; &#125; &#125; vector&lt;int&gt; ans; int i = negative, j = negative + 1; while (i &gt;= 0 || j &lt; n) &#123; if (i &lt; 0) &#123; ans.push_back(nums[j] * nums[j]); ++j; &#125; else if (j == n) &#123; ans.push_back(nums[i] * nums[i]); --i; &#125; else if (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123; ans.push_back(nums[i] * nums[i]); --i; &#125; else &#123; ans.push_back(nums[j] * nums[j]); ++j; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$o(n)$ 空间复杂度：$O(n)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"x的平方根","slug":"p/leetcode/day3","date":"2024-03-28T16:00:00.000Z","updated":"2024-07-02T14:57:03.350Z","comments":true,"path":"p/leetcode/day3/","permalink":"https://krystencollins.github.io/p/leetcode/day3/","excerpt":"","text":"69. x 的平方根 题目描述：给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例：示例 1： 12输入：x = 4输出：2 示例 2： 123输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示： 0 &lt;= x &lt;= 231 - 1 题解：由于$ x $平方根的整数部分 $ans$ 是满足$ k^2 \\leq x $的最大 $k$ 值，因此我们可以对 $k$ 进行二分查找，从而得到答案。 二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 middle 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1了。 123456789101112131415161718class Solution &#123;public: int mySqrt(int x) &#123; int left = 0; // 二分查找下界 int right = x; // 二分查找上界 while (left &lt;= right) &#123; long middle = left + ((right - left) &gt;&gt; 1); // 防止溢出 if (middle * middle &lt; x) &#123; left = middle + 1; &#125; else if (middle * middle &gt; x) &#123; right = middle - 1; &#125; else &#123; return middle; &#125; &#125; return right; &#125;&#125;; 时间复杂度：$O(log x)$ 空间复杂度：$O(1)$ 367. 有效的完全平方数题目描述：给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。 不能使用任何内置的库函数，如 sqrt 。 示例：示例 1： 123输入：num = 16输出：true解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 示例 2： 123输入：num = 14输出：false解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 提示： 1 &lt;= num &lt;= 231 - 1 题解：考虑使用二分查找来优化方法二中的搜索过程。因为 $num$ 是正整数，所以若正整数 $x $满足 $x×x&#x3D;num$，则 $xx$ 一定满足 $1≤x≤num$。于是我们可以将 1 和$ num$作为二分查找搜索区间的初始边界。 123456789101112131415161718class Solution &#123;public: bool isPerfectSquare(int num) &#123; int left = 0; // 下界 int right = num; // 上界 while (left &lt;= right) &#123; long middle = left + ((right - left) &gt;&gt; 1); // 防止溢出 if (middle * middle &gt; num) &#123; // 在左区间 right = middle - 1; &#125; else if (middle * middle &lt; num) &#123; // 在右区间 left = middle + 1; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125;; 时间复杂度：$O(log n)$ 空间复杂度：$O(1)$ 27. 移除元素题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例：示例 1： 123输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 123输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 题解：方法一：暴力解法12345678910111213141516class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int size = nums.size(); for (int i = 0; i &lt; size; ++i) &#123; if (nums[i] == val) &#123; // 发现需要移除的元素，将数组后半段集体前向移动一位 for (int j = i + 1; j &lt; size; ++j) &#123; nums[j - 1] = nums[j]; &#125; --i; // 因为下标i以后的数组都向前移动了一位，所以i也向前移动一位 --size; // 此时数组大小-1 &#125; &#125; return size; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二：快慢指针123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int slowIdx = 0; for (int fastIdx = 0; fastIdx &lt; nums.size(); ++fastIdx) &#123; if (val != nums[fastIdx]) &#123; nums[slowIdx++] = nums[fastIdx]; &#125; &#125; return slowIdx; &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法三：相向双指针12345678910111213141516171819class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int left = 0; int right = nums.size() - 1; while (left &lt;= right) &#123; while (left &lt;= right &amp;&amp; nums[right] == val) &#123; // 找右边不等于val的元素 --right; &#125; while (left &lt;= right &amp;&amp; nums[left] != val) &#123; // 找左边等于val的元素 ++left; &#125; if (left &lt; right) &#123; // 将右边不等于val的元素覆盖左边等于val的元素 nums[left++] = nums[right--]; &#125; &#125; return left; // left一定指向了最终数组末尾的下一个元素 &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 26. 删除有序数组中的重复项题目描述：给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 示例：示例 1： 123输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 123输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示： 1 &lt;= nums.length &lt;= 3 * 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 nums 已按 非严格递增 排列 题解：快慢指针：slowIdx指向没有重复元素的最后一个位置，fastIdx指向未遍历的第一个元素 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int slowIdx = 0; for (int fastIdx = 0; fastIdx &lt; nums.size(); ++fastIdx) &#123; if (nums[slowIdx] &lt; nums[fastIdx]) &#123; nums[++slowIdx] = nums[fastIdx]; &#125; &#125; return ++slowIdx; &#125;&#125;; 283. 移动零题目描述：给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例：示例 1: 12输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0] 示例 2: 12输入: nums = [0]输出: [0] 提示: 1 &lt;= nums.length &lt;= 104 -231 &lt;= nums[i] &lt;= 231 - 1 题解：快慢指针：快指针不断向右移动，每次快指针指向非零数，则将快慢指针对应的数交换，同时慢指针右移。 123456789101112class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int slowIdx = 0; for (int fastIdx = 0; fastIdx &lt; nums.size(); ++fastIdx) &#123; if (nums[fastIdx]) &#123; swap(nums[slowIdx], nums[fastIdx]); ++slowIdx; &#125; &#125; &#125;&#125;;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"在排序数组中查找元素的第一个和最后一个位置","slug":"p/leetcode/day2","date":"2024-03-27T16:00:00.000Z","updated":"2024-07-02T14:55:37.404Z","comments":true,"path":"p/leetcode/day2/","permalink":"https://krystencollins.github.io/p/leetcode/day2/","excerpt":"","text":"34. 在排序数组中查找元素的第一个和最后一个位置题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例：示例 1： 12输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4] 示例 2： 12输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1] 示例 3： 12输入：nums = [], target = 0输出：[-1,-1] 提示： 0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 nums 是一个非递减数组 -10^9 &lt;= target &lt;= 10^9 题解：寻找target在数组里的左右边界，有如下三种情况： 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1} 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1} 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1} 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int leftBorder = searchBorder(nums, target); int rightBorder = searchBorder(nums, target + 1); if (leftBorder == rightBorder) return &#123;-1, -1&#125;; // 说明数组中不存在target return &#123;leftBorder, rightBorder - 1&#125;; &#125;private: int searchBorder(vector&lt;int&gt;&amp; nums, int target) &#123; // 寻找第一个大于等于target的位置 int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效，所以&lt;= int middle = left + ((right - left) &gt;&gt; 1); // 防止溢出，等同于(left + right) / 2 if (nums[middle] &gt;= target) &#123; right = middle - 1; // 第一个大于等于target在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // 第一个大于等于target在右区间，所以[middle + 1, right] &#125; &#125; // 此时left &gt; right return right + 1; &#125;&#125;; 时间复杂度：$O(log n)$ 空间复杂度：$O(1)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"二分查找","slug":"p/leetcode/day1","date":"2024-03-26T16:00:00.000Z","updated":"2024-07-02T14:54:44.173Z","comments":true,"path":"p/leetcode/day1/","permalink":"https://krystencollins.github.io/p/leetcode/day1/","excerpt":"","text":"704. 二分查找题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例：示例 1: 123输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 123输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 题解：二分查找前提条件：1）有序数组，2）数组中无重复元素 方法一：左闭右闭 while (left &lt;&#x3D; right) 要使用&lt;&#x3D;，因为left&#x3D;&#x3D;right是有意义的， if (nums[middle] &gt; target) right要赋值为middle - 1，因为当前这个nums[middle]一定不是target， 12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // 定义target在左闭右闭区间内，[left, right] while (left &lt;= right) &#123; // 当left==right，区间依然有效，所以用&lt;= int middle = left + ((right - left) / 2); // 防止溢出，等同于(right + left) / 2 if (nums[middle] &gt; target) &#123; right = middle - 1; // target在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target在右区间，所以[middle + 1, right] &#125; else &#123; //nums[middle] == target return middle; // 找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 时间复杂度：$O(log n)$ 空间复杂度：$O(1)$ 方法二：左闭右开 while (left &lt; right)，这里使用&lt;，因为left&#x3D;&#x3D;right在区间[left, right)是没有意义的 if (nums[middle] &gt; target) right更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻早区间是左闭右开区间，所以更新为middle，即**下一个查询区间不会去比较nums[middle] 12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size(); // 定义target在左闭右开区间里，即[left, right) while (left &lt; right) &#123; // 因为left==right的时候，在[left, right)是无效的空间，所以&lt; int middle = left + ((right - left) &gt;&gt; 1); // &gt;&gt; 右移，相当于/2 if (nums[middle] &gt; target) &#123; right = middle; // target在左区间，在[left, middle)中 &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target在右区间，[middle+1, right) &#125; else &#123; // nums[middle] == target return middle; // 数组中找到目标值，直接返回下标 &#125; &#125; // 未找到目标值 return -1; &#125;&#125;; 时间复杂度：$O(log n)$ 空间复杂度：$O(1)$ 35. 搜索插入位置题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例：示例 1: 12输入: nums = [1,3,5,6], target = 5输出: 2 示例 2: 12输入: nums = [1,3,5,6], target = 2输出: 1 示例 3: 12输入: nums = [1,3,5,6], target = 7输出: 4 提示: 1 &lt;= nums.length &lt;= 10^4 -10^4 &lt;= nums[i] &lt;= 10^4 nums 为 无重复元素 的 升序 排列数组 -10^4 &lt;= target &lt;= 10^4 题解：要在数组中插入目标值，无非是这四种情况： 目标值在数组所有元素之前 目标值等于数组中某一个元素 目标值插入数组中的位置 目标值在数组所有元素之后 方法一：暴力解法12345678910111213141516class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); ++i) &#123; // 分别处理如下三种情况 // 目标值在数组所有元素之前 // 目标值等于数组中某一个元素 // 目标值插入数组中的位置 if (nums[i] &gt;= target) &#123; // 一旦发现大于或等于target的nums[i]，那么i就是我们要的结果 return i; &#125; &#125; // 目标值在数组所有元素之后 return nums.size(); // 如果target是最大的，或者nums为空，则返回nums的长度 &#125;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 方法二：二分查找1234567891011121314151617181920212223class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0; int right = n - 1; // 定义target在左闭右闭区间内，[left, right] while (left &lt;= right) &#123; // 当left==right，区间[left, right]依然有效 int middle = left + ((right - left) &gt;&gt; 1); // 防止溢出 if (nums[middle] &gt; target) &#123; right = middle - 1; // target在左区间，所以[left, middle - 1] &#125; else if (nums[middle] &lt; target) &#123; left = middle + 1; // target在右区间，所以[middle + 1, left] &#125; else &#123; // nums[middle] == target return middle; &#125; &#125; // 分别处理如下三种情况，此时left &gt; right // 目标值在数组所有元素之前，[0,-1]，此时right=-1，因此return right + 1 // 目标值插入数组中的位置，right=left-1, 因此return right + 1 // 目标值在数组所有元素之后，因为是右闭区间，所以return right + 1 return right + 1; &#125;&#125;; 时间复杂度：$O(log n)$ 空间复杂度：$O(1)$","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"},{"name":"leetcod","slug":"leetcod","permalink":"https://krystencollins.github.io/categories/leetcod/"}],"tags":[]}