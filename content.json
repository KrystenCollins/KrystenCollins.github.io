{"meta":{"title":"Collins's Blog","subtitle":"碎梦拾荒者","description":"且行且珍惜","author":"Krysten· Collins","url":"https://krystencollins.github.io","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"p/hello-world","date":"2024-05-02T14:06:09.325Z","updated":"2024-05-02T14:06:09.326Z","comments":true,"path":"p/hello-world/","permalink":"https://krystencollins.github.io/p/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"二叉树层序遍历","slug":"p/Day30","date":"2024-04-24T16:00:00.000Z","updated":"2024-05-03T14:53:54.178Z","comments":true,"path":"p/Day30/","permalink":"https://krystencollins.github.io/p/Day30/","excerpt":"","text":"102. 二叉树的层序遍历题目描述：给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法广度优先遍历 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 一定使用固定的size，因为que的size一直在变化 for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 时间复杂度：$O(n)$，每个节点进队出队各一次，渐近时间复杂度为$O(n)$ 空间复杂度：$O(n)$，队列种元素个数不超过n个 递归法深度优先搜索 1234567891011121314151617class Solution &#123;public: void order(TreeNode* node, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(node-&gt;val); order(node-&gt;left, result, depth + 1); order(node-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; order(root, result, depth); return result; &#125;&#125;; 107. 二叉树的层序遍历 II题目描述：给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]] 示例 2： 12输入：root = [1]输出：[[1]] 示例 3： 12输入：root = []输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法广度优先搜索，翻转结果数组 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; reverse(result.begin(), result.end()); return result; &#125;&#125;; 递归法翻转结果数组 123456789101112131415161718class Solution &#123;public: void orderBottom(TreeNode* node, vector&lt;vector&lt;int&gt;&gt;&amp; result, int depth) &#123; if (node == nullptr) return; if (result.size() == depth) result.push_back(vector&lt;int&gt;()); result[depth].push_back(node-&gt;val); orderBottom(node-&gt;left, result, depth + 1); orderBottom(node-&gt;right, result, depth + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; result; int depth = 0; orderBottom(root, result, depth); reverse(result.begin(), result.end()); return result; &#125;&#125;; 104. 二叉树的最大深度题目描述：给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：3 示例 2： 12输入：root = [1,null,2]输出：2 提示： 树中节点的数量在 [0, 104] 区间内。 -100 &lt;= Node.val &lt;= 100 题解：层次遍历12345678910111213141516171819class Solution &#123;public: int maxDepth(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != nullptr) que.push(root); int depth = 0; while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; ++depth; &#125; return depth; &#125;&#125;; 前序遍历12345678910111213141516171819class Solution &#123;public: void order(TreeNode* node, int depth, int&amp; maxD) &#123; if (node == nullptr) return; // 若遇到叶子节点，判断当前深度是否大于 记录的最大深度 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; maxD = depth &gt; maxD ? depth : maxD; &#125; order(node-&gt;left, depth + 1, maxD); order(node-&gt;right, depth + 1, maxD); &#125; int maxDepth(TreeNode* root) &#123; int depth = 1; // 根节点深度为1 int maxD = 0; // 初始化最大深度为0 order(root, depth, maxD); return maxD; &#125;&#125;; 后序遍历先求左子树深度，再求右子树深度，最后取左右深度最大的数值 再加1（算上当前节点）， 123456789101112131415class Solution &#123;public: int getDepth(TreeNode* node) &#123; if (node == nullptr) return 0; int leftdepth = getDepth(node-&gt;left); // 左 int rightdepth = getDepth(node-&gt;right); // 右 int depth = 1 + max(leftdepth, rightdepth); // 中 return depth; &#125; int maxDepth(TreeNode* root) &#123; return getDepth(root); &#125;&#125;; 代码简洁版： 1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (root == nullptr) return 0; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;; 相似题目： 559. N 叉树的最大深度 111. 二叉树的最小深度题目描述：给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 示例：示例 1： 12输入：root = [3,9,20,null,null,15,7]输出：2 示例 2： 12输入：root = [2,null,3,null,4,null,5,null,6]输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 &lt;= Node.val &lt;= 1000 题解：迭代法层次遍历，广度优先搜索 1234567891011121314151617181920212223242526class Solution &#123;public: int minDepth(TreeNode* root) &#123; // 根节点为空，最小深度为0 if (root == nullptr) return 0; // 根节点不空，最小深度从1开始 int minD = 1; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; ++i) &#123; TreeNode* node = que.front(); que.pop(); // 层次遍历，第一次遇到叶子节点时，即最小深度，直接返回，退出循环。 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; return minD; &#125; if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; ++minD; &#125; return minD; &#125;&#125;; 前序遍历12345678910111213141516171819202122class Solution &#123;public: void order(TreeNode* node, int depth, int&amp; minD) &#123; if (node == nullptr) return; // 中：遇到叶子节点，判断当前深度是否小于 记录的最小深度 if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; minD = depth &lt; minD ? depth : minD; &#125; order(node-&gt;left, depth + 1, minD); // 左 order(node-&gt;right, depth + 1, minD); // 右 &#125; int minDepth(TreeNode* root) &#123; // 根节点为空，最小深度为0 if (root == nullptr) return 0; int minD = INT_MAX; // 初始化最小深度 int depth = 1; // 根节点深度为1 // 递归层次遍历 order(root, depth, minD); return minD; &#125;&#125;; 后序遍历12345678910111213141516171819class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == nullptr) return 0; int leftDepth = minDepth(root-&gt;left); // 左 int rightDepth = minDepth(root-&gt;right); // 右 // 中 // 当左子树为空，右子树不为空，此时不是最低点 if (root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; return 1 + rightDepth; &#125; // 当左子树不为空，右子树为空，此时不是最低点 if (root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return 1 + leftDepth; &#125; // 左右字数都为空（即叶子节点）或都不为空 return 1 + min(leftDepth, rightDepth); &#125;&#125;; 代码简洁版： 12345678910111213class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (root == nullptr) return 0; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right != nullptr) &#123; return 1 + minDepth(root-&gt;right); &#125; if (root-&gt;left != nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return 1 + minDepth(root-&gt;left); &#125; return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right)); &#125;&#125;;","categories":[],"tags":[]},{"title":"LeetCode-Day20","slug":"p/Day20","date":"2024-04-15T16:00:00.000Z","updated":"2024-05-03T14:52:15.383Z","comments":true,"path":"p/Day20/","permalink":"https://krystencollins.github.io/p/Day20/","excerpt":"","text":"454. 四数相加 II题目描述：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例：示例 1： 123456输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下：1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 12输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 &lt;= n &lt;= 200 -2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28 题解：分组+哈希表 12345678910111213141516171819202122class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; umap; // key: a+b的数值，value：a+b数值出现次数 // 遍历nums1和nums2，统计两个数组元素之和，和出现的次数， for (int a : nums1) &#123; for (int b : nums2) &#123; ++umap[a + b]; &#125; &#125; int ans = 0; // 统计a+b+c+d=0出现的次数 // 遍历nums3和nums4，判断0-(c+d)是否在umap出现过，并统计次数 for (int c : nums3) &#123; for (int d : nums4) &#123; if (umap.find(0 - (c + d)) != umap.end()) &#123; ans += umap[0 - (c + d)]; &#125; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$，哈希表映射所需空间，最坏情况下nums1和nums2的值各不相同，和的个数为 $n^2$ 15. 三数之和题目描述：给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例：示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 示例 2： 123输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 示例 3： 123输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 提示： 3 &lt;= nums.length &lt;= 3000 -10^5 &lt;= nums[i] &lt;= 10^5 题解：方法一：排序+哈希表123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出a+b+c=0 // a = nums[i], b = nums[j], c = 0-(a+b) for (int i = 0; i &lt; nums.size(); ++i) &#123; // 排序之后如果第一个元素已经大于零，那么不可能组成三元组 if (nums[i] &gt; 0) &#123; break; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // 三元组a元素的去重 continue; &#125; unordered_set&lt;int&gt; set; for (int j = i + 1; j &lt; nums.size(); ++j) &#123; if (j &gt; i + 2 &amp;&amp; nums[j] == nums[j-1] &amp;&amp; nums[j-1] == nums[j-2]) &#123; // 三元组b元素的去重 continue; &#125; int c = 0 - (nums[i] + nums[j]); if (set.find(c) != set.end()) &#123; result.push_back(&#123;nums[i], nums[j], c&#125;); set.erase(c); // 三元组c元素去重 &#125; else &#123; set.insert(nums[j]); &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$ 方法二：排序+双指针1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出 a+b+c=0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] &gt; 0) &#123; break; &#125; // 错误去重a的方法 // if (nums[i] == nums[i+1]) &#123; // continue; // &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; // 去重的逻辑如果放在这，(0,0,0)这种情况可能直接导致right&lt;=left, // while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; // while left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; if (nums[i] + nums[left] + nums[right] &gt; 0) &#123; --right; &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123; ++left; &#125; else &#123; result.push_back(&#123;nums[i], nums[left], nums[right]&#125;); // 去重的逻辑应该放在找到第一个三元组之后，对b和c去重 while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; // 找到答案时，双指针同时收缩 --right; ++left; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(log \\ n)$ 18. 四数之和题目描述：给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例：示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 题解：方法一： 排序+双指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k &lt; nums.size(); ++k) &#123; // 剪枝操作 if (nums[k] &gt; target &amp;&amp; nums[k] &gt;= 0) &#123; break; // 这里使用break，统一通过最后的return返回 &#125; // 对nums[k]去重 if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) &#123; continue; &#125; for (int i = k + 1; i &lt; nums.size(); ++i) &#123; // 2级剪枝 if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) &#123; break; &#125; // 对nums[i]去重 if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; // nums[k] + nums[i] + nums[left] + nums[right] &gt; target会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123; --right; &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right] &lt; target) &#123; ++left; &#125; else &#123; result.push_back(&#123;nums[k], nums[i], nums[left], nums[right]&#125;); // 对nums[left]和nums[right]去重 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right; while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left; // 找到答案，同时收缩双指针 --right; ++left; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 时间复杂度：$O(n^3)$ 空间复杂度：$O(log \\ n)$ 16. 最接近的三数之和题目描述：给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例：示例 1： 123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 示例 2： 12输入：nums = [0,0,0], target = 1输出：0 提示： 3 &lt;= nums.length &lt;= 1000 -1000 &lt;= nums[i] &lt;= 1000 -104 &lt;= target &lt;= 104 题解：排序+双指针 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int ans = 0; int d = INT_MAX; int sum = 0; sort(nums.begin(), nums.end()); // 找出 a+b+c尽可能接近target // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); ++i) &#123; // 错误去重a的方法 // if (nums[i] == nums[i+1]) &#123; // continue; // &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (left &lt; right) &#123; sum = nums[i] + nums[left] + nums[right]; if (sum &gt; target) &#123; --right; &#125; else if (sum &lt; target) &#123; ++left; &#125; else &#123; return sum; &#125; if (d &gt; abs(target - sum)) &#123; d = abs(target - sum); ans = sum; &#125; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：$O(n^2)$ 空间复杂度：$O(log \\ n)$","categories":[],"tags":[]}],"categories":[],"tags":[]}