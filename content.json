{"meta":{"title":"Collins's Blog","subtitle":"碎梦拾荒者","description":"且行且珍惜","author":"Krysten· Collins","url":"https://krystencollins.github.io","root":"/"},"pages":[{"title":"","date":"2024-05-10T09:09:12.515Z","updated":"2024-05-10T09:09:12.499Z","comments":true,"path":"404.html","permalink":"https://krystencollins.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2024-05-10T09:06:51.337Z","updated":"2024-05-10T09:06:51.337Z","comments":true,"path":"about/index.html","permalink":"https://krystencollins.github.io/about/index.html","excerpt":"","text":"Hello, Welcome to Collins’s Blog!!"},{"title":"分类","date":"2024-05-10T09:05:56.537Z","updated":"2024-05-10T09:05:56.537Z","comments":true,"path":"categories/index.html","permalink":"https://krystencollins.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-05-10T09:08:15.534Z","updated":"2024-05-10T09:08:15.523Z","comments":true,"path":"friends/index.html","permalink":"https://krystencollins.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"标签","date":"2024-05-10T09:06:47.641Z","updated":"2024-05-10T09:06:47.641Z","comments":true,"path":"tags/index.html","permalink":"https://krystencollins.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"完全背包","slug":"p/leetcode/day77","date":"2024-07-02T16:00:00.000Z","updated":"2024-07-03T08:16:17.622Z","comments":true,"path":"p/leetcode/day77/","permalink":"https://krystencollins.github.io/p/leetcode/day77/","excerpt":"","text":"完全背包理论基础 携带研究材料题目描述：小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。 小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。 示例：输入描述 第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值 输出描述 输出一个整数，表示最大价值。 输入示例 123454 51 22 43 44 5 输出示例 110 提示信息第一种材料选择五次，可以达到最大值。 数据范围： 1 &lt;&#x3D; N &lt;&#x3D; 10000;1 &lt;&#x3D; V &lt;&#x3D; 10000;1 &lt;&#x3D; wi, vi &lt;&#x3D; 10^9. 题解：动态规划先物品再背包 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/*完全背包：1. dp数组以及下标含义：dp[j]表示容量为j的背包，能装入物品的最大价值2. 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])3. 初始化：dp[j] = 04. 遍历顺序：完全背包问题 滚动数组 先遍历背包容量还是先遍历物品无所谓！ 遍历背包容量需要从小到大，因为物品可以无限取！！5. 举例推导dp数组*/void completePack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int bagWeight) &#123; vector&lt;int&gt; dp(bagWeight + 1, 0); for (int i = 0; i &lt; weight.size(); ++i) &#123; // 遍历物品 for (int j = weight[i]; j &lt;= bagWeight; ++j) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;&#125;int main() &#123; int N, V; cin &gt;&gt; N &gt;&gt; V; vector&lt;int&gt; weight; vector&lt;int&gt; value; for (int i = 0; i &lt; N; ++i) &#123; int w, v; cin &gt;&gt; w &gt;&gt; v; weight.push_back(w); value.push_back(v); &#125; completePack(weight, value, V); return 0;&#125; 时间复杂度：O(N * V) 空间复杂度：O(V) 先背包再物品 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; /*完全背包：1. dp数组以及下标含义：dp[j]表示容量为j的背包，能装入物品的最大价值2. 递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])3. 初始化：dp[j] = 04. 遍历顺序：完全背包问题 滚动数组 先遍历背包容量还是先遍历物品无所谓！ 遍历背包容量需要从小到大，因为物品可以无限取！！5. 举例推导dp数组*/ void completePack(vector&lt;int&gt; weight, vector&lt;int&gt; value, int bagWeight) &#123; vector&lt;int&gt; dp(bagWeight + 1, 0); for (int j = 0; j &lt;= bagWeight; ++j) &#123; // 遍历背包容量 for (int i = 0; i &lt; weight.size(); ++i) &#123; // 遍历物品 if (j &gt;= weight[i]) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;&#125; int main() &#123; int N, V; cin &gt;&gt; N &gt;&gt; V; vector&lt;int&gt; weight; vector&lt;int&gt; value; for (int i = 0; i &lt; N; ++i) &#123; int w, v; cin &gt;&gt; w &gt;&gt; v; weight.push_back(w); value.push_back(v); &#125; completePack(weight, value, V); return 0;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"一和零","slug":"p/leetcode/day76","date":"2024-07-01T16:00:00.000Z","updated":"2024-07-03T08:08:56.365Z","comments":true,"path":"p/leetcode/day76/","permalink":"https://krystencollins.github.io/p/leetcode/day76/","excerpt":"","text":"474. 一和零题目描述：给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例：示例 1： 1234输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 123输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。 提示： 1 &lt;= strs.length &lt;= 600 1 &lt;= strs[i].length &lt;= 100 strs[i] 仅由 &#39;0&#39; 和 &#39;1&#39; 组成 1 &lt;= m, n &lt;= 100 题解：动态规划12345678910111213141516171819202122232425262728class Solution &#123;public: /* 问题转化：物品为strs中的元素，背包容量为m、n两个维度！物品价值为物品的数量 三维数组 */ int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; int l = strs.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(l + 1, vector&lt;vector&lt;int&gt;&gt;(m + 1, vector&lt;int&gt;(n + 1, 0))); for (int i = 1; i &lt;= l; ++i) &#123; int zeroNum = 0; int oneNum = 0; for (char ch : strs[i - 1]) &#123; if (ch == &#x27;0&#x27;) ++zeroNum; else ++oneNum; &#125; for (int j = 0; j &lt;= m; ++j) &#123; for (int k = 0; k &lt;= n; ++k) &#123; dp[i][j][k] = dp[i - 1][j][k]; if (j &gt;= zeroNum &amp;&amp; k &gt;= oneNum) &#123; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - zeroNum][k - oneNum] + 1); &#125; &#125; &#125; &#125; return dp[l][m][n]; &#125;&#125;; 时间复杂度：O(l * m * n + L)，L为所有子串的长度总和 空间复杂度：O(l * m * n) 滚动数组 1234567891011121314151617181920212223242526272829class Solution &#123;public: /* 问题转化：物品为strs中的元素，背包容量为m、n两个维度！物品价值为物品的数量 1. dp数组以及下标含义：dp[i][j]表示最多有i个0和j个1的strs的最大子集的大小 2. 递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)，当前元素放或不放 3. dp数组初始化：dp[i][j] = 0 4. 遍历顺序：外循环物品，内循环背包容量：dp数组两个维度都表示背包容量，倒序遍历！！哪个维度优先无所谓 5. 举例推导dp数组： */ int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1 , 0)); for (string str : strs) &#123; // 遍历物品 int zeroNum = 0; int oneNum = 0; for (char ch : str) &#123; if (ch == &#x27;0&#x27;) ++zeroNum; else ++oneNum; &#125; // 遍历背包容量，从后往前 for (int i = m; i &gt;= zeroNum; --i) &#123; for (int j = n; j &gt;= oneNum; --j) &#123; dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 时间复杂度：O(l* m * n + L) 空间复杂度：O(m * n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"目标和","slug":"p/leetcode/day75","date":"2024-06-17T16:00:00.000Z","updated":"2024-07-02T09:33:59.326Z","comments":true,"path":"p/leetcode/day75/","permalink":"https://krystencollins.github.io/p/leetcode/day75/","excerpt":"","text":"494. 目标和题目描述：给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例：示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 示例 2： 12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 题解：回溯超出内存限制 1234567891011121314151617181920212223242526272829class Solution &#123;public: int result = 0; int sum = 0; void backtracking(vector&lt;int&gt; nums, int target, int startIdx) &#123; if (startIdx == nums.size()) &#123; if (target == sum) ++result; return; &#125; for (int i = 0; i &lt;= 1; ++i) &#123; if (i) &#123; sum += nums[startIdx]; backtracking(nums, target, startIdx + 1); sum -= nums[startIdx]; &#125; else &#123; sum -= nums[startIdx]; backtracking(nums, target, startIdx + 1); sum += nums[startIdx]; &#125; &#125; &#125; int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; backtracking(nums, target, 0); return result; &#125;&#125;; 动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 问题转化：a+b=sum, a-b=target ---&gt; a=(sum+target)/2, b=(sum-target)/2 组合类问题：dp[j] += dp[j - nums[i]] */ int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if ((sum - target) % 2 == 1) return 0; // 不能整除，原问题无解 if (abs(target) &gt; sum) return 0; // target绝对值大于所有非负非负整数和，也无解 int b = (sum - target) / 2; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt; (b + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; int num = nums[i - 1]; for (int j = 0; j &lt;= b; ++j) &#123; dp[i][j] = dp[i - 1][j]; if (j &gt;= num) dp[i][j] += dp[i - 1][j - num]; &#125; &#125; return dp[n][b]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n ^ 2) 滚动数组： 1234567891011121314151617181920212223242526class Solution &#123;public: /* 问题转化：a+b=sum, a-b=target ---&gt; a=(sum+target)/2, b=(sum-target)/2 组合类问题：dp[j] += dp[j - nums[i]] 1. dp数组含义：dp[j]表示装满容量为a的背包有多少种方案 2. 递推公式：dp[j] += dp[j - nums[i]]，每次确定了一个nums[i]的容量，就有dp[j - nums[i]]种方法 3. dp数组初始化：dp[0] = 1,.. 4. 遍历顺序：nums在外循环，target在内循环，内循环倒序 5. 举例推导dp数组： */ int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if ((sum + target) % 2 == 1) return 0; // 不能整除，原问题无解 if (abs(target) &gt; sum) return 0; // target绝对值大于所有非负非负整数和，也无解 int a = (sum + target) / 2; vector&lt;int&gt; dp(a + 1, 0); dp[0] = 1; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = a; j &gt;= nums[i]; --j) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[a]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"分割等和子集","slug":"p/leetcode/day74","date":"2024-06-16T16:00:00.000Z","updated":"2024-07-02T09:17:17.178Z","comments":true,"path":"p/leetcode/day74/","permalink":"https://krystencollins.github.io/p/leetcode/day74/","excerpt":"","text":"416. 分割等和子集题目描述：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例：示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 题解：动态规划1234567891011121314151617181920212223242526class Solution &#123;public: /* 转化问题：任意数组元素是否可以组成和sum/2的序列。背包容量为sum/2, 每个元素重量为nums[i],价值也为nums[i] 1. dp数以及下标含义：dp[i][j]表示从0~i中任意取物品，放进容量为j的背包价值总和最大是多少 2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - nums[i]] + nums[i]) 3. dp数组初始化：dp[i][0] = 0; 当j &gt;= nums[0], dp[0][j] = nums[0], 否则dp[0][j] = 0 4. 遍历顺序：先物品再背包 5. 举例推导dp数组： */ bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; // 总和为奇数一定不可能分割成两个等和的子集 int bagweight = sum / 2; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(bagweight + 1, 0)); for (int j = bagweight; j &gt;= nums[0]; --j) dp[0][j] = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= bagweight; ++j) &#123; if (j &lt; nums[i]) dp[i][j] = dp[i -1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]); &#125; &#125; return dp[n - 1][bagweight] == bagweight; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(n * sum) 空间优化： 123456789101112131415161718class Solution &#123;public: /* 转化问题：任意数组元素是否可以组成和sum/2的序列。背包容量为sum/2, 每个元素重量为nums[i],价值也为nums[i] */ bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum % 2 == 1) return false; int bagweight = sum / 2; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = bagweight; j &gt;= nums[i]; --j) &#123; dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); &#125; &#125; return dp[bagweight] == bagweight; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(sum) 1049. 最后一块石头的重量 II题目描述：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例：示例 1： 1234567输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 12输入：stones = [31,26,33,21,40]输出：5 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 100 题解：动态规划12345678910111213141516171819202122232425class Solution &#123;public: /* 问题转化：尽可能分割石头为重量相等的两个子集，背包重量为sum/2, 每个石头重量为stones[i], 价值也为stones[i] 1. dp数组以及下标含义：dp[i][j]表示从0~i的石头中任意取，放进背包容量为j的价值总和最大是多少 2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i]] + stones[i]) 3. dp数组初始化： 4. 遍历顺序： 5、 举例推导dp数组： */ int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int sum = accumulate(stones.begin(), stones.end(), 0); int bagweight = sum / 2; int n = stones.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(bagweight + 1, 0)); for (int j = bagweight; j &gt;= stones[0]; --j) dp[0][j] = stones[0]; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= bagweight; ++j) &#123; if (j &lt; stones[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[n - 1][bagweight] * 2; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(n * sum) 滚动数组 1234567891011121314class Solution &#123;public: int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123; int sum = accumulate(stones.begin(), stones.end(), 0); int bagweight = sum / 2; vector&lt;int&gt; dp(bagweight + 1, 0); for (int i = 0; i &lt; stones.size(); ++i) &#123; for (int j = bagweight; j &gt;= stones[i]; --j) &#123; dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]); &#125; &#125; return sum - dp[bagweight] * 2; &#125;&#125;; 时间复杂度：O(n * sum) 空间复杂度：O(sum)","categories":[],"tags":[]},{"title":"统计字典序元音字符串的数目","slug":"p/leetcode/day73","date":"2024-06-15T16:00:00.000Z","updated":"2024-07-02T09:06:32.049Z","comments":true,"path":"p/leetcode/day73/","permalink":"https://krystencollins.github.io/p/leetcode/day73/","excerpt":"","text":"1641. 统计字典序元音字符串的数目题目描述：给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。 示例：示例 1： 123输入：n = 1输出：5解释：仅由元音组成的 5 个字典序字符串为 [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;] 示例 2： 12345输入：n = 2输出：15解释：仅由元音组成的 15 个字典序字符串为[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;]注意，&quot;ea&quot; 不是符合题意的字符串，因为 &#x27;e&#x27; 在字母表中的位置比 &#x27;a&#x27; 靠后 示例 3： 12输入：n = 33输出：66045 提示： 1 &lt;= n &lt;= 50 题解：回溯123456789101112131415161718192021222324class Solution &#123;public: int result = 0; vector&lt;string&gt; vowel = &#123;&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;&#125;; string path; void backtracking(int startIdx, int n) &#123; if (path.size() == n) &#123; ++result; return; &#125; for (int i = startIdx; i &lt; vowel.size(); ++i) &#123; path += vowel[i]; backtracking(i, n); path.pop_back(); &#125; &#125; int countVowelStrings(int n) &#123; backtracking(0, n); return result; &#125;&#125;; 动态规划 1234567891011121314151617181920212223class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i][j]表示长度为i+1，以j结尾的仅含元音字典序排序的字符串数量 2. 递推公式：i = 0, dp[i][j] = 1; i &gt; 0, dp[i][j] = sum(dp[i-1][k]), k从0到j 3. dp数组初始化： 4. 遍历顺序： 5. 举例推导dp数组： */ int countVowelStrings(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(5, 0)); for (int j = 0; j &lt; 5; ++j) dp[0][j] = 1; for (int i = 1; i &lt; n; ++i) &#123; dp[i][0] = dp[i -1][0]; for (int j = 1; j &lt; 5; ++j) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; int result = 0; for (int j = 0; j &lt; 5; ++j) result += dp[n - 1][j]; return result; &#125;&#125;; 时间复杂度：O(n * M)， M&#x3D;5 空间复杂度：O(n * M) 空间优化： 123456789101112class Solution &#123;public: int countVowelStrings(int n) &#123; vector&lt;int&gt; dp(5, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; 5; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return accumulate(dp.begin(), dp.end(), 0); &#125;&#125;; 时间复杂度：O(n * M) ，M&#x3D;5 空间复杂度：O(M)","categories":[],"tags":[]},{"title":"0-1背包","slug":"p/leetcode/day72","date":"2024-06-14T16:00:00.000Z","updated":"2024-07-02T09:02:41.771Z","comments":true,"path":"p/leetcode/day72/","permalink":"https://krystencollins.github.io/p/leetcode/day72/","excerpt":"","text":"0-1背包基础理论 有n件物品和一个最多能装重量为w的背包，第i件物品的重量是weight[i]，得到的价值是value[i]，每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 确定dp数组以及下标含义 dp[i][j]表示从下标为0~i的物品里任意取，放进容量为j的背包，价值总和最大是多少 确定递推公式 不放物品i：dp[i][j] = dp[i-1][j]，相当于当物品i重量大于背包剩余重量时，物品无法放进背包中 放物品i：dp[i][j] = dp[i-1][j - weight[i]] + value[i] dp数组初始化：dp[i][0] = 0，dp[0][j] = value[0], 当j &gt;= wight[0]时，否则为0 遍历顺序：二维数组先遍历物品 or 先遍历背包都可以，先遍历物品再遍历背包容易理解 滚动数组 确定dp数组的定义：在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？ dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值， 所以递归公式为： 1dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。 那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了 一维dp数组遍历顺序 代码如下： 123456for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); &#125;&#125; 倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！ 举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15 如果正序遍历 dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15 dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30 此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。 为什么倒序遍历，就可以保证物品只放入一次呢？ 倒序就是先算dp[2] dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0） dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。 那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？ 因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！ 再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？ 不可以！ 因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。 46. 携带研究材料题目描述：小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。 输入描述 第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。 第二行包含 M 个正整数，代表每种研究材料的所占空间。 第三行包含 M 个正整数，代表每种研究材料的价值。 输出描述 输出一个整数，代表小明能够携带的研究材料的最大价值。 示例： 输入示例 1236 12 2 3 1 5 22 3 1 5 4 3 输出示例 15 提示信息小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 数据范围：1 &lt;&#x3D; N &lt;&#x3D; 50001 &lt;&#x3D; M &lt;&#x3D; 5000研究材料占用空间和价值都小于等于 1000 题解：动态规划1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; /*1. dp数组以及下标含义：dp[i][j]从下标0~i的物品中任意取，放进空间为j的背包，价值总和是多少2. 递推公式：dp[i][j] = max(dp[i-1][j], dp[i-1][j - weights[i] + vaules[i]), 放与不放取较大值3. dp数组初始化：dp[0][j] = vaules[0], 当j &gt;= weights[0], 否则dp[0][j]=0 4. 遍历顺序：先遍历物品再遍历背包，或者相反5. 举例推导dp数组：*/ int main() &#123; int M, N; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; weights(M, 0); vector&lt;int&gt; values(M, 0); for (int i = 0; i &lt; M; ++i) cin &gt;&gt; weights[i]; for (int i = 0; i &lt; M; ++i) cin &gt;&gt; values[i]; vector&lt;vector&lt;int&gt;&gt; dp(M, vector&lt;int&gt;(N+1, 0)); for (int j = weights[0]; j &lt;= N; ++j) dp[0][j] = values[0]; for (int i = 1; i &lt; M; ++i) &#123; for (int j = 0; j &lt;= N; ++j) &#123; if (j &lt; weights[i]) dp[i][j] = dp[i-1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i]] + values[i]); &#125; &#125; cout &lt;&lt; dp[M-1][N] &lt;&lt; endl; return 0;&#125; 时间复杂度：O(M * N) 空间复杂度：O(M * N) 滚动数组123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; /*1. dp数组以及下标含义：dp[j]表示空间为j的背包，价值总和是多少2. 递推公式：dp[j] = max(dp[j], dp[j - weights[i] + vaules[i]), 放与不放取较大值3. dp数组初始化：dp[0] = 0,4. 遍历顺序：先遍历物品再遍历背包，（背包倒序遍历！）5. 举例推导dp数组：*/ int main() &#123; int M, N; cin &gt;&gt; M &gt;&gt; N; vector&lt;int&gt; weights(M, 0); vector&lt;int&gt; values(M, 0); for (int i = 0; i &lt; M; ++i) cin &gt;&gt; weights[i]; for (int i = 0; i &lt; M; ++i) cin &gt;&gt; values[i]; vector&lt;int&gt; dp(N+1, 0); for (int i = 0; i &lt; M; ++i) &#123; for (int j = N; j &gt;= weights[i]; --j) &#123; //背包重量只需从N减少到当前研究材料所占空间 dp[j] = max(dp[j], dp[j - weights[i]] + values[i]); &#125; &#125; cout &lt;&lt; dp[N] &lt;&lt; endl; return 0;&#125; 时间复杂度：O(N * M) 空间复杂度：O(N)","categories":[],"tags":[]},{"title":"整数拆分","slug":"p/leetcode/day71","date":"2024-06-13T16:00:00.000Z","updated":"2024-07-02T09:01:36.479Z","comments":true,"path":"p/leetcode/day71/","permalink":"https://krystencollins.github.io/p/leetcode/day71/","excerpt":"","text":"343. 整数拆分题目描述：给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例：示例 1: 123输入: n = 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 123输入: n = 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示: 2 &lt;= n &lt;= 58 题解：动态规划 1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标的含义：dp[i]表示整数i拆分后所得最大乘积 2. 递推公式：dp[i] = max(dp[i], j*(i - j), j*dp[i-j]) , j从1到i-1 3. dp数组初始化：dp[2] = 1 4. 遍历顺序：从前往后 5. 举例推导dp数组： */ int integerBreak(int n) &#123; vector&lt;int&gt; dp(n+1, 0); dp[2] = 1; for (int i = 3; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i - 1; ++j) &#123; dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])); &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 贪心算法每次拆成n个3，如果剩下是4，则保留4，然后相乘，但是这个结论需要数学证明其合理性！ 123456789101112131415class Solution &#123;public: int integerBreak(int n) &#123; if (n == 2) return 1; if (n == 3) return 2; if (n == 4) return 4; int result = 1; while (n &gt; 4) &#123; result *= 3; n -= 3; &#125; result *= n; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 95. 不同的二叉搜索树 II题目描述：给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例：示例 1： 12输入：n = 3输出：5 示例 2： 12输入：n = 1输出：1 提示： 1 &lt;= n &lt;= 19 题解：动态规划12345678910111213141516171819202122class Solution &#123;public: /* 1. dp数组有以及下标含义：dp[i]表示i个节点不同的二叉搜索树有多少种 2. 递推公式：dp[i] = sum(dp[j] * dp[i-j-1]), j: 0~ i-1 3. dp数组初始化：dp[0] = 1, dp[1] = 1 3. 遍历顺序：从前往后 5. 举例推导dp数组： */ int numTrees(int n) &#123; if (n == 1) return n; vector&lt;int&gt; dp(n+1, 0); dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= i - 1; ++j) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n ^ 2) 空间复杂度：O(n) 递归12345678910111213class Solution &#123;public: int result = 0; int numTrees(int n) &#123; if (n == 0) return 1; if (n == 1 || n == 2) return n; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum += numTrees(i - 1) * numTrees(n - i); &#125; return sum; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day70","date":"2024-06-12T16:00:00.000Z","updated":"2024-06-17T02:12:05.739Z","comments":true,"path":"p/leetcode/day70/","permalink":"https://krystencollins.github.io/p/leetcode/day70/","excerpt":"","text":"62. 不同路径题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例：示例 1： 12输入：m = 3, n = 7输出：28 示例 2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例 3： 12输入：m = 7, n = 3输出：28 示例 4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于 2 * 109 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i行j列共有多少条不同路径 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： p[1][j]=dp[i][1]=1, 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 1)); for (int i = 2; i &lt;= m; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n * m) 空间优化： 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; vector&lt;int&gt; dp(n+1, 1); for (int i = 2; i &lt;= m; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; dp[j] = dp[j-1] + dp[j]; &#125; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n * m) 空间复杂度：O(n) 深度优先搜索 &#x3D;&#x3D;超出时间限制&#x3D;&#x3D; 123456789101112class Solution &#123;public: int dfs(int i, int j, int m, int n) &#123; if (i &gt; m || j &gt; n) return 0; // 越界 if (i == m || j == n) return 1; // 找到一种方法，相当于找到叶子节点 return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n); &#125; int uniquePaths(int m, int n) &#123; return dfs(1, 1, m, n); &#125;&#125;; 时间复杂度：O(2 ^ (m+n+1)) 空间复杂度：O(m+n+1) 数论无论怎么走，走到终点都需要m+n-2步，其中一定有m-1步往下走，不用管什么时候往下走 组合问题：$C^{m-1}_{m+n-2}$ 防止两个int相乘溢出 1234567891011121314151617class Solution &#123;public: int uniquePaths(int m, int n) &#123; long long numerator = 1; // 分子 int denominator = m - 1; // 分母 int count = m - 1; int t = m + n - 2; while (count--) &#123; numerator *= (t--); while (denominator != 0 &amp;&amp; numerator % denominator == 0) &#123; numerator /= denominator; // 计算过程中不断除以分母，防止溢出 denominator--; &#125; &#125; return numerator; &#125;&#125;; 时间复杂度：O(m) 空间复杂度：O(1) 63. 不同路径 II题目描述：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例：示例 1： 123456输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]输出：2解释：3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 示例 2： 12输入：obstacleGrid = [[0,1],[0,0]]输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 &lt;= m, n &lt;= 100 obstacleGrid[i][j] 为 0 或 1 题解：动态规划1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i-1行j-1列共有多少条不同路径,i,j从0开始 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： dp[0][j] = ?, dp[i][0] = ? 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if (obstacleGrid[0][0] == 1) return 0; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = 1; // 起始位置一定可达，因为已排除不可达情况 for (int i = 1; i &lt; m; ++i) &#123; // 若当前位置没有障碍物，且上一个位置可达，则当前位置可达 if (obstacleGrid[i][0] == 0 &amp;&amp; dp[i-1][0] != 0) &#123; dp[i][0] = 1; &#125; else dp[i][0] = 0; // 若当前位置有障碍物，或者上一个位置不可达，则当前位置不可达 &#125; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[0][j] == 0 &amp;&amp; dp[0][j-1] != 0) dp[0][j] = 1; else dp[0][j] = 0; // 可省略，已初始化 &#125; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 时间复杂度：O(m * n) 空间复杂度：O(m * n) 简化代码： 123456789101112131415161718192021222324class Solution &#123;public: /* 1. 确定dp数组以及下标的含义：dp[i][j]表示移动到i-1行j-1列共有多少条不同路径,i,j从0开始 2. 递推公式：dp[i][j] = dp[i-1][j] + dp[i][j-1] 3. dp数组初始化： dp[0][j] = ?, dp[i][0] = ? 4. 确定遍历顺序：从左往右，从上往下 5. 举例推导dp数组： */ int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; ++i) dp[i][0] = 1; for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; ++j) dp[0][j] = 1; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 空间优化： 1234567891011121314151617181920class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; dp(n, 0); for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; ++j) dp[j] = 1; for (int i = 1; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (j == 0) &#123; if (obstacleGrid[i][j] == 1) dp[j] = 0; continue; &#125; if (obstacleGrid[i][j] == 1) dp[j] = 0; else dp[j] = dp[j] + dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 时间复杂度：O(m * n) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day69","date":"2024-06-11T16:00:00.000Z","updated":"2024-06-17T01:41:11.607Z","comments":true,"path":"p/leetcode/day69/","permalink":"https://krystencollins.github.io/p/leetcode/day69/","excerpt":"","text":"动态规划步骤： 确定dp数组，以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 递推公式决定了dp数组如何初始化 如何debug？把dp数组打印出来，看看究竟是不是按照自己思路推导的 509. 斐波那契数题目描述：斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 示例：示例 1： 123输入：n = 2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：n = 3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：n = 4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 题解：递归1234567class Solution &#123;public: int fib(int n) &#123; if (n == 0 || n == 1) return n; return fib(n - 1) + fib(n - 2); &#125;&#125;; 时间复杂度：O(2^n) 空间复杂度：O(n) 动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. 确定dp数组以及下标含义：第i个数的斐波那契数值为dp[i] 2. 确定递推公式：dp[i]=dp[i-1]+dp[i-2] 3. dp数组初始化：dp[0]=0, dp[1]=1 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int fib(int n) &#123; if (n &lt;= 1) return n; vector&lt;int&gt; dp(n + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化：只需要维护两个数值即可，不需要记录整个序列 123456789101112131415class Solution &#123;public: int fib(int n) &#123; if (n &lt;= 1) return n; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 70. 爬楼梯题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例：示例 1： 12345输入：n = 2输出：2解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入：n = 3输出：3解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 提示： 1 &lt;= n &lt;= 45 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标含义：dp[i]表示到达i阶有多少种方法 2. 确定递推公式：dp[i] = dp[i-1] + dp[i-2] 3. dp数组初始化：dp[1]=1, dp[2]=2 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int climbStairs(int n) &#123; if (n &lt;= 2) return n; vector&lt;int&gt; dp(n+1); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 123456789101112131415class Solution &#123;public: int climbStairs(int n) &#123; if (n &lt;= 2) return n; int dp[2]; dp[0] = 1; dp[1] = 2; for (int i = 3; i &lt;= n; ++i) &#123; int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 递归超出时间限制 1234567class Solution &#123;public: int climbStairs(int n) &#123; if (n &lt;= 2) return n; return climbStairs(n - 1) + climbStairs(n - 2); &#125;&#125;; 746. 使用最小花费爬楼梯题目描述：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 示例：示例 1： 12345输入：cost = [10,15,20]输出：15解释：你将从下标为 1 的台阶开始。- 支付 15 ，向上爬两个台阶，到达楼梯顶部。总花费为 15 。 示例 2： 12345678910输入：cost = [1,100,1,1,1,100,1,1,100,1]输出：6解释：你将从下标为 0 的台阶开始。- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。- 支付 1 ，向上爬一个台阶，到达楼梯顶部。总花费为 6 。 提示： 2 &lt;= cost.length &lt;= 1000 0 &lt;= cost[i] &lt;= 999 题解：动态规划1234567891011121314151617181920class Solution &#123;public: /* 1. dp数组以及下标的含义：dp[i]表示到达第i阶需要支付的 最小费用 2. 确定递推公式：dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]) 3. dp数组初始化：dp[0] = 0, dp[1]=0 4. 确定遍历顺序：从前往后 5. 举例推导dp数组： */ int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); vector&lt;int&gt; dp(n+1); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); &#125; return dp[n]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 空间优化： 123456789101112131415class Solution &#123;public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123; int n = cost.size(); int dp[2]; dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; int sum = min(dp[1] + cost[i - 1], dp[0] + cost[i - 2]); dp[0] = dp[1]; dp[1] = sum; &#125; return dp[1]; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day68","date":"2024-06-10T16:00:00.000Z","updated":"2024-06-13T01:31:05.255Z","comments":true,"path":"p/leetcode/day68/","permalink":"https://krystencollins.github.io/p/leetcode/day68/","excerpt":"","text":"738. 单调递增的数字题目描述：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 示例：示例 1: 12输入: n = 10输出: 9 示例 2: 12输入: n = 1234输出: 1234 示例 3: 12输入: n = 332输出: 299 提示: 0 &lt;= n &lt;= 10^9 题解：暴力法12345678910111213141516171819202122class Solution &#123;public: // 判断一个数字的各位是否递增 bool isIncreasing(int num) &#123; int max = 10; // 记录上一个数最后一个数字 while (num) &#123; int t = num % 10; // 记录当前最后一个数字 if (max &gt;= t) max = t; // 若不递减则更新 else return false; // 否则返回false num = num / 10; // 取剩下的高位数字 &#125; return true; &#125; int monotoneIncreasingDigits(int n) &#123; // 从大到小遍历 for (int i = n; i &gt; 0; --i) &#123; if (isIncreasing(i)) return i; &#125; return 0; &#125;&#125;; 时间复杂度：O(n * m)，m为数字n的长度 空间复杂度：O(1) 贪心 12345678910111213141516171819class Solution &#123;public: int monotoneIncreasingDigits(int n) &#123; string strNum = to_string(n); int m = strNum.size(); int flag = m; // 标记赋值9从哪开始 // 从后往前遍历，从哪开始出现递减则后面的各位数字都为9 for (int i = m - 1; i &gt; 0; --i) &#123; if (strNum[i - 1] &gt; strNum[i]) &#123; flag = i; strNum[i - 1]--; &#125; &#125; for (int i = flag; i &lt; m; ++i) &#123; strNum[i] = &#x27;9&#x27;; &#125; return stoi(strNum); &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day67","date":"2024-06-09T16:00:00.000Z","updated":"2024-06-11T03:22:23.421Z","comments":true,"path":"p/leetcode/day67/","permalink":"https://krystencollins.github.io/p/leetcode/day67/","excerpt":"","text":"968. 监控二叉树题目描述：给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 示例：示例 1： 123输入：[0,0,null,0,0]输出：1解释：如图所示，一台摄像头足以监控所有节点。 示例 2： 123输入：[0,0,null,0,null,0,null,null,0]输出：2解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。 提示： 给定树的节点数的范围是 [1, 1000]。 每个节点的值都是 0。 题解：贪心从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少；整体最优：全部摄像头摄像头数量所用最少 大致思路：从下往上，先给叶子节点的父节点放一个摄像头，然后每隔两个节点放一个摄像头，直到二叉树的头节点 如何隔两个节点放一个摄像头！！ 状态转移 0：本节点无覆盖 1：本节点有摄像头 2：本节点有覆盖 详细思路 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int result = 0; int postOrder(TreeNode* node) &#123; // 空节点，表示有覆盖 if (node == nullptr) return 2; int left = postOrder(node-&gt;left); int right = postOrder(node-&gt;right); // 1. 左右节点都有覆盖 if (left == 2 &amp;&amp; right == 2) return 0; // 2. 左右节点至少一个无覆盖 // left == 0 &amp;&amp; right == 0 // left == 0 &amp;&amp; right == 1 // left == 0 &amp;&amp; right == 2 // left == 1 &amp;&amp; right == 0 // left == 2 &amp;&amp; right == 0 if (left == 0 || right == 0) &#123; ++result; return 1; &#125; // 3. 左右节点至少有一个有摄像头 // left == 1 &amp;&amp; right == 1 // left == 1 &amp;&amp; right == 2 // left == 2 &amp;&amp; right == 2 // 其他情况以上已经包含 if (left == 1 || right == 1) return 2; // 逻辑不会走到这 return -1; &#125; int minCameraCover(TreeNode* root) &#123; // 若头节点未覆盖，还需要一个摄像头 if (postOrder(root) == 0) &#123; ++result; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 代码简化： 123456789101112131415161718192021class Solution &#123;public: int result = 0; int postOrder(TreeNode* node) &#123; if (node == nullptr) return 2; int left = postOrder(node-&gt;left); int right = postOrder(node-&gt;right); if (left == 2 &amp;&amp; right == 2) return 0; else if (left == 0 || right == 0) &#123; ++result; return 1; &#125; else return 2; &#125; int minCameraCover(TreeNode* root) &#123; if (postOrder(root) == 0) ++result; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day66","date":"2024-06-08T16:00:00.000Z","updated":"2024-06-11T02:39:54.171Z","comments":true,"path":"p/leetcode/day66/","permalink":"https://krystencollins.github.io/p/leetcode/day66/","excerpt":"","text":"2405. 子字符串的最优划分题目描述：给你一个字符串 s ，请你将该字符串划分成一个或多个 子字符串 ，并满足每个子字符串中的字符都是 唯一 的。也就是说，在单个子字符串中，字母的出现次数都不超过 一次 。 满足题目要求的情况下，返回 最少 需要划分多少个子字符串。 注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。 示例：示例 1： 12345输入：s = &quot;abacaba&quot;输出：4解释：两种可行的划分方法分别是 (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) 和 (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;) 。可以证明最少需要划分 4 个子字符串。 示例 2： 1234输入：s = &quot;ssssss&quot;输出：6解释：只存在一种可行的划分方法 (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;) 。 提示： 1 &lt;= s.length &lt;= 105 s 仅由小写英文字母组成 题解：哈希表从头开始遍历字符串，同时哈希表记录出现过的字符，当遇到已经出现的字符，说明找到一个划分，哈希表清空，继续遍历 12345678910111213141516171819class Solution &#123;public: int partitionString(string s) &#123; if (s.size() == 1) return 1; vector&lt;int&gt; hash(26, 0); int result = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (hash[s[i] - &#x27;a&#x27;] == 0) &#123; hash[s[i] - &#x27;a&#x27;] = 1; // 之前未出现，记录到哈希表中 &#125; else &#123; // 出现重复字符，划分数++ ++result; hash = vector&lt;int&gt;(26, 0); // 清空哈希表，这里直接重定义 hash[s[i] - &#x27;a&#x27;] = 1; // 注意：把当前字符加入“新哈希表”中 &#125; &#125; return ++result; // 加上最后一个划分 &#125;&#125;; 时间复杂度：O(n)，n为字符串长度 空间复杂度：O(m)，m&#x3D;26 3. 无重复字符的最长子串题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例：示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 题解：滑动窗口+哈希表代码一： 出现重复字符时，通过left指针 一直移除哈希表中 “重复字符之前的字符”包括 该重复字符 123456789101112131415161718192021222324class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; // 哈希表，记录每个字符是否出现过 unordered_set&lt;char&gt; uset; int maxLen = 0; uset.insert(s[0]); // 首先将第一个字符插入哈希表 // left相当于 起始字符 for (int left = 0, right = 1; left &lt; n; ++left) &#123; // 不断移动右指针，直到出现重复字符，同时插入哈希表 while (right &lt; n &amp;&amp; !uset.count(s[right])) &#123; uset.insert(s[right]); ++right; &#125; // 出现重复字符，记录最长不重复字符串 maxLen = max(maxLen, right - left); // 移除在哈希表中的 left所指字符，相当于从下一个 字符开始 uset.erase(s[left]); &#125; return maxLen; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 代码二： 相同的思路：遇到重复字符时，start指针更新为 之前start 与 出现重复字符位置 的较大值 12345678910111213141516171819202122232425class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; unordered_map&lt;char, int&gt; umap; int maxLen = 0; int curLen = 0; int start = 0; for (int i = 0; i &lt; n; ++i) &#123; if (!umap.count(s[i])) &#123; ++curLen; umap.insert(pair&lt;char, int&gt; (s[i], i)); &#125; else &#123; maxLen = max(maxLen, curLen); start = max(umap[s[i]], start); curLen = i - start; umap[s[i]] = i; &#125; &#125; maxLen = max(maxLen, curLen); return maxLen; &#125;&#125;; 986. 区间列表的交集题目描述：给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。 返回这 两个区间列表的交集 。 形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。 两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。 示例：示例 1： 12输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] 示例 2： 12输入：firstList = [[1,3],[5,9]], secondList = []输出：[] 示例 3： 12输入：firstList = [], secondList = [[4,8],[10,12]]输出：[] 示例 4： 12输入：firstList = [[1,7]], secondList = [[3,10]]输出：[[3,7]] 提示： 0 &lt;= firstList.length, secondList.length &lt;= 1000 firstList.length + secondList.length &gt;= 1 0 &lt;= starti &lt; endi &lt;= 109 endi &lt; starti+1 0 &lt;= startj &lt; endj &lt;= 109 endj &lt; startj+1 题解：双指针123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; firstList, vector&lt;vector&lt;int&gt;&gt;&amp; secondList) &#123; int n = firstList.size(); int m = secondList.size(); if (n == 0) return firstList; if (m == 0) return secondList; vector&lt;vector&lt;int&gt;&gt; result; int start = 0; int end = 0; for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m;) &#123; if (firstList[i][1] &lt; secondList[j][0]) &#123; ++i; &#125; else if (firstList[i][0] &gt; secondList[j][1]) &#123; ++j; &#125; else &#123; start = max(firstList[i][0], secondList[j][0]); if (firstList[i][1] &lt; secondList[j][1]) &#123; end = firstList[i][1]; ++i; &#125; else &#123; end = secondList[j][1]; ++j; &#125; result.push_back(&#123;start, end&#125;); &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(max(n, m)) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day65","date":"2024-06-07T16:00:00.000Z","updated":"2024-06-10T02:53:59.189Z","comments":true,"path":"p/leetcode/day65/","permalink":"https://krystencollins.github.io/p/leetcode/day65/","excerpt":"","text":"435. 无重叠区间题目描述：给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例：示例 1: 123输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 123输入: intervals = [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 123输入: intervals = [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示: 1 &lt;= intervals.length &lt;= 105 intervals[i].length == 2 -5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104 题解：贪心方法一：对终止位置排序， 1）从前往后遍历，以最小右边界判断是否重叠 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; // 需要移除区间数初始化为0 int num = intervals[0][1]; // 记录 当前最小右边界 for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 若 下一个区间左边界 严格小于 当前最小右边界，说明有重叠，result++ if (num &gt; intervals[i][0]) &#123; ++result; &#125; else &#123; // 否则，更新最小右边界 num = intervals[i][1]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 2）从后往前遍历 1234567891011121314151617181920212223242526class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int size = intervals.size(); int num = intervals[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (num &lt; intervals[i][1]) &#123; ++result; num = max(num, intervals[i][0]); // 左边界更新为“最大值”，相等于移除左边界更小的区间 &#125; else &#123; num = intervals[i][0]; &#125; &#125; return result; &#125;&#125;; 方法二：对区间 起始位置排序， 1）从前往后遍历， 遇到重叠时，更新 右边界为“最小值”，相当于移除了右边界更大的区间，因为右边界更大的区间可能与后续其他区间重叠，根据“贪心策略”，需要保证移除的区间数最少， 12例1： [[1,5],[6,7],[7, 8], [7,9],[9, 10]]例2： [[1,10],[2,4],[5, 6], [7,9]] 只需要移除[1,10] 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int num = intervals[0][1]; for (int i = 1; i &lt; intervals.size(); ++i) &#123; if (num &gt; intervals[i][0]) &#123; ++result; num = min(num, intervals[i][1]); // 更新右边界为“最小值” &#125; else &#123; num = intervals[i][1]; &#125; &#125; return result; &#125;&#125;; 2）从后往前遍历，以最大左边界判断是否重叠，遇到重叠时则不需要更新“num“ 12345678910111213141516171819202122232425class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); int result = 0; int size = intervals.size(); int num = intervals[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (num &lt; intervals[i][1]) &#123; ++result; &#125; else &#123; num = intervals[i][0]; &#125; &#125; return result; &#125;&#125;; 763. 划分字母区间题目描述：给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 示例：示例 1： 123456输入：s = &quot;ababcbacadefegdehijhklij&quot;输出：[9,7,8]解释：划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。每个字母最多出现在一个片段中。像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 示例 2： 12输入：s = &quot;eccbbbbdec&quot;输出：[10] 提示： 1 &lt;= s.length &lt;= 500 s 仅由小写英文字母组成 题解：贪心方法一： 统计字符串中所有字符的 起始位置和结束位置，将这些区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠，（即区间为 435. 无重叠区间的输入） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; vector&lt;int&gt; partitionLabels(string s) &#123; // 哈希表记录每个字母出现的区间 vector&lt;vector&lt;int&gt;&gt; letter_hash(26, vector&lt;int&gt;&#123;&#125;); for (int i = 0; i &lt; s.size(); ++i) &#123; int idx = s[i] - &#x27;a&#x27;; if (letter_hash[idx].size() == 0) &#123; letter_hash[idx] = &#123;i, i&#125;; &#125; else &#123; letter_hash[idx][1] = i; &#125; &#125; // 去除字符串中未出现的字母 区间 vector&lt;vector&lt;int&gt;&gt; intervals; for (vector&lt;int&gt; vec : letter_hash) &#123; if (vec.size() != 0) intervals.push_back(vec); &#125; // 按左边界从小到大排序 sort(intervals.begin(), intervals.end(), cmp()); vector&lt;int&gt; result; int start = intervals[0][0]; // 可直接令为 0 int end = intervals[0][1]; // 当前 最大右边界 for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 若下一个区间 起始位置 小于当前最大右边界，说明有重叠，更新最大右边界 if (end &gt; intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; // 否则不再重叠，找到一个片段， result.push_back(end - start + 1); // 将片段长度记录到result start = intervals[i][0]; // 更新左右边界 end = intervals[i][1]; &#125; &#125; result.push_back(end - start + 1); // 将最后一个片段长度记录到result return result; &#125;&#125;; 时间复杂度：O(nlog n) + O(m)，n&#x3D;26，m为字符串长度 空间复杂度：O(log n) 方法二： 局部最优：寻找每个片段可能的最小结束下标，保证每个片段的长度一定符合要求的最短长度；若取更短的片段，一定会出现同一个字母出现在多个片段中 全局最优：每次取得片段都是符合要求的最短片段，得到片段数最多 统计每个字符最后出现的位置， 从头遍历，并更新字符最远出现下标，若找到字符最远出现下标 和当前下标相等，则找到一个分割点 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; partitionLabels(string s) &#123; int hash[26]; for (int i = 0; i &lt; s.size(); ++i) &#123; hash[s[i] - &#x27;a&#x27;] = i; // 统计每个字符最后出现的位置 &#125; vector&lt;int&gt; result; int start = 0; int end = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; end = max(end, hash[s[i] - &#x27;a&#x27;]); // 更新字符最远出现下标 if (end == i) &#123; // 字符最远出现下标与当前下标相等，则为一个分割点 result.push_back(end - start + 1); start = end + 1; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(m)，m为字符串长度 空间复杂度：O(n)，n &#x3D; 26 56. 合并区间题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例：示例 1： 123输入：intervals = [[1,3],[2,6],[8,10],[15,18]]输出：[[1,6],[8,10],[15,18]]解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 123输入：intervals = [[1,4],[4,5]]输出：[[1,5]]解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 104 题解：贪心对起始位置排序，从前往后遍历，发现重叠区间时，更新右边界为较大值，表示合并 1234567891011121314151617181920212223242526272829class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), cmp()); vector&lt;vector&lt;int&gt;&gt; result; int start = intervals[0][0]; int end = intervals[0][1]; for (int i = 1; i &lt; intervals.size(); ++i) &#123; // 发现重叠区间，进行合并：更新右边界为较大值 if (end &gt;= intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; // 不重叠，加入result，更新下一个左右边界 result.push_back(&#123;start, end&#125;); start = intervals[i][0]; end = intervals[i][1]; &#125; &#125; result.push_back(&#123;start, end&#125;); // 加入最后一个区间 return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 57. 插入区间题目描述：给你一个 无重叠的 ，按照区间起始端点排序的区间列表 intervals，其中 intervals[i] = [starti, endi] 表示第 i 个区间的开始和结束，并且 intervals 按照 starti 升序排列。同样给定一个区间 newInterval = [start, end] 表示另一个区间的开始和结束。 在 intervals 中插入区间 newInterval，使得 intervals 依然按照 starti 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。 返回插入之后的 intervals。 注意 你不需要原地修改 intervals。你可以创建一个新数组然后返回它。 示例：示例 1： 12输入：intervals = [[1,3],[6,9]], newInterval = [2,5]输出：[[1,5],[6,9]] 示例 2： 123输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出：[[1,2],[3,10],[12,16]]解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 提示： 0 &lt;= intervals.length &lt;= 104 intervals[i].length == 2 0 &lt;= starti &lt;= endi &lt;= 105 intervals 根据 starti 按 升序 排列 newInterval.length == 2 0 &lt;= start &lt;= end &lt;= 105 题解： 待插入区间 与原区间列表中 任何一个都无交集，可能在 两个区间之间，可能排 在第一个或最后一个 有交集：与 “左区间”重叠；与“右区间”重叠 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; // 寻找插入位置 for (; i &lt; intervals.size(); ++i) &#123; // 若某一个区间右边界 大于等于 待插入区间 的左边界， // 说明找到插入位置，但尚不知哪种情况 if (intervals[i][1] &gt;= newInterval[0]) break; else result.push_back(intervals[i]); &#125; // 若原区间列表没有一个 区间右边界 大于等于 待插入区间左边界 // 说明 插入位置为区间列表尾部，直接加入，并返回 if (i == intervals.size()) &#123; result.push_back(newInterval); return result; &#125; // 记录插入位置 左右边界 int start = intervals[i][0]; int end = intervals[i][1]; // 若插入位置左边界 大于 待插入区间右边界，说明“无交集”，并且 插入位置在右，待插入区间在左 if (newInterval[1] &lt; start) &#123; result.push_back(newInterval); &#125; else &#123; // 否则，出现重叠，直接合并区间：取左边界较小值，取右边界较大值 start = min(start, newInterval[0]); end = max(end, newInterval[1]); &#125; // 继续判断插入后，后续区间是否出现重叠 for (++i; i &lt; intervals.size(); ++i) &#123; if (end &gt;= intervals[i][0]) &#123; end = max(end, intervals[i][1]); &#125; else &#123; result.push_back(&#123;start, end&#125;); start = intervals[i][0]; end = intervals[i][1]; &#125; &#125; // 加入最后一个区间 result.push_back(&#123;start, end&#125;); return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day64","date":"2024-06-06T16:00:00.000Z","updated":"2024-06-09T08:31:42.563Z","comments":true,"path":"p/leetcode/day64/","permalink":"https://krystencollins.github.io/p/leetcode/day64/","excerpt":"","text":"406. 根据身高重建队列题目描述：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 示例：示例 1： 12345678910输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2： 12输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示： 1 &lt;= people.length &lt;= 2000 0 &lt;= hi &lt;= 106 0 &lt;= ki &lt; people.length 题目数据确保队列可以被重建 题解：贪心算法遇到两个维度权衡时，一定要先确定一个维度，再确定另一个维度！ 身高一定从大到小（相同身高K值小的站前面）。前面节点一定比本节点高 局部最优：优先按身高 高的people的k来插入，插入操作过后的people满足队列属性 全局最优：完成所有插入操作，整个队列满足题目队列属性 123456789101112131415161718192021class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; // 优先按升高从大到小排序，若身高相同，k值小的排前面 sort(people.begin(), people.end(), cmp()); vector&lt;vector&lt;int&gt;&gt; result; for (int i = 0; i &lt; people.size(); ++i) &#123; int position = people[i][1]; result.insert(result.begin() + position, people[i]); &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) + O(n^2) 空间复杂度：O(n) 代码优化： vector的插入insert()操作非常耗时，改成list效率更好 123456789101112131415161718192021222324class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &gt; b[0]; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), cmp()); list&lt;vector&lt;int&gt;&gt; result; // list底层是链表实现，插入效率比vector高得多 for (int i = 0; i &lt; people.size(); ++i) &#123; int position = people[i][1]; // 插入到下标为position的位置 list&lt;vector&lt;int&gt;&gt;::iterator it = result.begin(); while (position--) &#123; // 寻找插入位置 ++it; &#125; result.insert(it, people[i]); &#125; return vector&lt;vector&lt;int&gt;&gt; (result.begin(), result.end()); &#125;&#125;; 时间复杂度：O(nlog n) + O(n^2) 空间复杂度：O(n) 452. 用最少数量的箭引爆气球题目描述：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 示例：示例 1： 12345输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：气球可以用2支箭来爆破:-在x = 6处射出箭，击破气球[2,8]和[1,6]。-在x = 11处发射箭，击破气球[10,16]和[7,12]。 示例 2： 123输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3： 12345输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2解释：气球可以用2支箭来爆破:- 在x = 2处发射箭，击破气球[1,2]和[2,3]。- 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示: 1 &lt;= points.length &lt;= 105 points[i].length == 2 -231 &lt;= xstart &lt; xend &lt;= 231 - 1 题解：贪心算法局部最优：当气球出现重叠时，一起射，所用弓箭最少； 全局最优：把所有气球射爆所用弓箭最少 为了让气球尽可能重叠，需要对数组进行排序，按起始位置或按终止位置排序都可以，遍历顺序不同而已 方法一：对终止位置排序后，重叠气球最小右边界 为第一个气球右边界！！ 1234567891011121314151617181920212223242526class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[1] &lt; b[1]; &#125; &#125;; int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; // 对终止位置升序排序 sort(points.begin(), points.end(), cmp()); int result = 1; // points不为空，至少需要一支箭 int num = points[0][1]; // 记录当前最小右边界 for (int i = 1; i &lt; points.size(); ++i) &#123; // 下一个气球左边界 不在当前最小右边界内，说明不重叠 if (points[i][0] &gt; num) &#123; ++result; // 必须要另一支箭 num = points[i][1]; // 更新最小右边界 &#125; // 下一个气球 左边界 在当前最小右边界内，说明有重叠，可以一起射爆，则继续判断下一个 else if (points[i][0] &lt;= num) continue; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(log n) 方法二：对起始位置排序，从后往前遍历 123456789101112131415161718192021222324class Solution &#123;public: class cmp &#123; public: bool operator()(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0]; &#125; &#125;; int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(points.begin(), points.end(), cmp()); int result = 1; int size = points.size(); int num = points[size - 1][0]; for (int i = size - 2; i &gt;= 0; --i) &#123; if (points[i][1] &lt; num) &#123; ++result; num = points[i][0]; &#125; else if (points[i][1] &gt;= num) continue; &#125; return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day63","date":"2024-06-05T16:00:00.000Z","updated":"2024-06-07T02:38:53.038Z","comments":true,"path":"p/leetcode/day63/","permalink":"https://krystencollins.github.io/p/leetcode/day63/","excerpt":"","text":"860. 柠檬水找零题目描述：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 示例：示例 1： 1234567输入：bills = [5,5,5,10,20]输出：true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2： 1234567输入：bills = [5,5,10,10,20]输出：false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示： 1 &lt;= bills.length &lt;= 105 bills[i] 不是 5 就是 10 或是 20 题解：贪心策略局部最优：遇到20美元，优先消耗10美元找零； 全局最优：完成全部账单找零 方法一：长度为3的数组分别记录5美元、10美元、20美元的数量 12345678910111213141516171819202122232425262728class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; if (bills[0] != 5) return false; vector&lt;int&gt; vec(3, 0); for (int i = 0; i &lt; bills.size(); ++i) &#123; if (bills[i] == 5) &#123; vec[0]++; &#125; else if (bills[i] == 10) &#123; if (vec[0] &gt;= 1) &#123; vec[0]--; vec[1]++; &#125; else return false; &#125; else if (bills[i] == 20) &#123; if (vec[1] &gt;= 1 &amp;&amp; vec[0] &gt;= 1) &#123; vec[2]++; vec[1]--; vec[0]--; &#125; else if (vec[0] &gt;= 3) &#123; vec[2]++; vec[0] = vec[0] - 3; &#125; else return false; &#125; &#125; return true; &#125;&#125;; 代码优化：只使用两个变量分别记录5美元、10美元的数量，20美元数没必要记录，因为不使用它来找零 1234567891011121314151617181920212223242526class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; int five = 0; int ten = 0; for (int i = 0; i &lt; bills.size(); ++i) &#123; if (bills[i] == 5) ++five; if (bills[i] == 10) &#123; if (five &gt; 0) &#123; ++ten; --five; &#125; else return false; &#125; if (bills[i] == 20) &#123; if (five &gt; 0 &amp;&amp; ten &gt; 0) &#123; --ten; --five; &#125; else if (five &gt;= 3) five -= 3; else return false; &#125; &#125; return true; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day62","date":"2024-06-04T16:00:00.000Z","updated":"2024-06-06T08:25:25.386Z","comments":true,"path":"p/leetcode/day62/","permalink":"https://krystencollins.github.io/p/leetcode/day62/","excerpt":"","text":"135. 分发糖果题目描述：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例：示例 1： 123输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 1234输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 &lt;= n &lt;= 2 * 104 0 &lt;= ratings[i] &lt;= 2 * 104 题解：贪心算法首先确定一边之后再确定另一边：先比较每一个孩子左边再比较每一个孩子右边，两边一起考虑一定会顾此失彼 右边评分大于左边评分：（从前往后遍历） 局部最优：只要右边评分比左边评分大，右边孩子就比左边多一个糖果 全局最优：相邻孩子中，评分高的右孩子比左边孩子得到更多糖果 左边评分大于左边评分：（一定从后往前遍历，因为确定左边孩子糖果数需要用到右边数据） 局部最优：只要左边评分比右边评分高，并且已经获得糖果数未比右边多，左边孩子就比右边多一个糖果 全局最优：两两相邻孩子评分更高得孩子获得更多糖果 12345678910111213141516171819202122class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); vector&lt;int&gt; candys(size, 1); // 从前往后 for (int i = 1; i &lt; size; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candys[i] = candys[i - 1] + 1; &#125; &#125; // 从后往前 for (int i = size - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1] &amp;&amp; candys[i] &lt;= candys[i + 1]) &#123; candys[i] = candys[i + 1] + 1; &#125; &#125; // 统计结果 int sum = accumulate(candys.begin(), candys.end(), 0); return sum; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n) 常数空间遍历？？？","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day61","date":"2024-06-03T16:00:00.000Z","updated":"2024-06-05T04:16:41.024Z","comments":true,"path":"p/leetcode/day61/","permalink":"https://krystencollins.github.io/p/leetcode/day61/","excerpt":"","text":"134. 加油站题目描述：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例：示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2: 123456789输入: gas = [2,3,4], cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 提示: gas.length == n cost.length == n 1 &lt;= n &lt;= 105 0 &lt;= gas[i], cost[i] &lt;= 104 题解：暴力法思维陷阱：是否“断油” 和 是否绕环路一周 分开判断，若一圈后 油量有剩余，则陷入死循环 必须同时判断是否“断油” 和 绕环路一周 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); for (int i = 0; i &lt; n; ++i) &#123; int rest = gas[i] - cost[i]; // 剩余油量 int index = (i + 1) % n; // 模拟以i为起点行驶一周 while (rest &gt; 0 &amp;&amp; index != i) &#123; rest += gas[index] + -cost[index]; index = (index + 1) % n; &#125; // 绕环路行驶一周后，回到起点 if (rest &gt;= 0 &amp;&amp; index == i) return i; &#125; return -1; &#125;&#125;; 时间复杂度：O(n^2) 空间复杂度：O(1) 贪心算法方法一：全局贪心选择 若gas总和&lt;cost总和，无论从哪出发一定跑不了一圈 每天剩余油量rest[i] &#x3D; gas[i] - cost[i]，若从索引0开始累加每天剩余油量到最后一站，累加过程没有出现负数，说明从0出发，油没有断过，则0为起点 若累加过程中出现的最小值为负数，说明索引0不是起点，则从后往前，看那个节点能把这个负数填平，能把这个负数填平的节点为出发节点（因为从0出发说明初始油量为0，而从0出发会有累加剩余油量为负，即油量不够；从后往前，就是将剩余油量累计都索引0，相当于从0出发时 初始油量 不为0！） 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int curSum = 0; int minSum = INT_MAX; // 从索引0出发，剩余油量累加过程中出现的最小值 for (int i = 0; i &lt; gas.size(); ++i) &#123; curSum += gas[i] - cost[i]; minSum = min(curSum, minSum); &#125; if (curSum &lt; 0) return -1; if (minSum &gt;= 0) return 0; for (int i = gas.size() - 1; i &gt;= 0; --i) &#123; minSum += gas[i] - cost[i]; if (minSum &gt;= 0) return i; &#125; return -1; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 方法二：i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。 局部最优：当前rest[i]累加和curSum一旦小于0，起始位置至少要从 i+1 开始，因为i之前开始一定不行 全局最优：找到可以跑一圈的位置 如果 curSum&lt;0 说明 区间和1 + 区间和2 &lt; 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2&gt;0。 区间和1 + 区间和2 &lt; 0 同时 区间和2&gt;0，只能说明区间和1 &lt; 0， 那么就会从假设的箭头初就开始从新选择其实位置了。 123456789101112131415161718class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int curSum = 0; int totalSum = 0; int start = 0; for (int i = 0; i &lt; gas.size(); ++i) &#123; curSum += gas[i] - cost[i]; totalSum += gas[i] - cost[i]; if (curSum &lt; 0) &#123; // 当前rest[i]累加和 curSum小于0 start = i + 1; // 更新起始位置 curSum = 0; // 重置curSum &#125; &#125; if (totalSum &lt; 0) return -1; return start; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 2099. 找到和最大的长度为 K 的子序列题目描述：给你一个整数数组 nums 和一个整数 k 。你需要找到 nums 中长度为 k 的 子序列 ，且这个子序列的 和最大 。 请你返回 任意 一个长度为 k 的整数子序列。 子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。 示例：示例 1： 1234输入：nums = [2,1,3,3], k = 2输出：[3,3]解释：子序列有最大和：3 + 3 = 6 。 示例 2： 1234输入：nums = [-1,-2,3,4], k = 3输出：[-1,3,4]解释：子序列有最大和：-1 + 3 + 4 = 6 。 示例 3： 12345输入：nums = [3,4,3,3], k = 2输出：[3,4]解释：子序列有最大和：3 + 4 = 7 。另一个可行的子序列为 [4, 3] 。 提示： 1 &lt;= nums.length &lt;= 1000 -105 &lt;= nums[i] &lt;= 105 1 &lt;= k &lt;= nums.length 题解：排序先对数值进行降序排序，再对前K个元素的索引进行升序排序 在维护索引的同时对数组进行排序？ 使用“哈希表”，构造排序仿函数 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: class cmp1 &#123; public: bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.second &gt; b.second; &#125; &#125;; class cmp2 &#123; public: bool operator()(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123; return a.first &lt; b.first; &#125; &#125;; vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;pair&lt;int, int&gt;&gt; vals; for (int i = 0; i &lt; nums.size(); ++i) &#123; vals.push_back(pair&lt;int, int&gt; (i, nums[i])); &#125; // 按照数值降序排序 sort(vals.begin(), vals.end(), cmp1()); // 取前k个元素按照下标升序排序 sort(vals.begin(), vals.begin() + k, cmp2()); vector&lt;int&gt; ans; for (int i = 0; i &lt; k; ++i) &#123; ans.push_back(vals[i].second); &#125; return ans; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day60","date":"2024-06-02T16:00:00.000Z","updated":"2024-06-04T03:10:16.528Z","comments":true,"path":"p/leetcode/day60/","permalink":"https://krystencollins.github.io/p/leetcode/day60/","excerpt":"","text":"1005. K 次取反后最大化的数组和题目描述：给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例：示例 1： 123输入：nums = [4,2,3], k = 1输出：5解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2： 123输入：nums = [3,-1,0,2], k = 3输出：6解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3： 123输入：nums = [2,-3,-1,5,-4], k = 2输出：13解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 &lt;= nums.length &lt;= 104 -100 &lt;= nums[i] &lt;= 100 1 &lt;= k &lt;= 104 题解：暴力法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123; // 从小到大排序 sort(nums.begin(), nums.end()); int index = 0; int sum = 0; // 每遇到一个负数取反一次。注意：index&lt;nums.size()判断条件必须放到前面 while (index &lt; nums.size() &amp;&amp; nums[index] &lt; 0 &amp;&amp; k &gt; 0) &#123; nums[index] = -nums[index]; sum += nums[index]; ++index; --k; &#125; // 所有负数都变正了，k还大于0，取绝对值最小的数进行取反 if (k != 0) &#123; // 还需要取反 齐次数 if (k % 2 == 1) &#123; // 数组未遍历完并且不是第一个元素 if (index &gt; 0 &amp;&amp; index &lt; nums.size()) &#123; sum -= nums[index - 1]; // sum先减掉index前一个元素 // 取绝对值小的取反 if (nums[index - 1] &lt; nums[index]) &#123; sum += -nums[index - 1] + nums[index]; &#125; else &#123; sum += -nums[index] + nums[index - 1]; &#125; &#125; else if (index == 0)&#123; //index为0说明原数组全部非负 sum -= nums[index]; &#125; else if (index == nums.size()) &#123; // index为原数组大小说明全部非正，之前已经 取正累加和，因此减掉2倍 sum -= nums[index - 1] * 2; &#125; &#125; else if(index &lt; nums.size()) &#123; // 还需要取反 偶次数。若index未越界直接累加，否则不做处理 sum += nums[index]; &#125; ++index; // index指向元素已经考虑 &#125; // 累加剩下非负数（若存在） while (index &lt; nums.size()) &#123; sum += nums[index]; ++index; &#125; return sum; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1) 贪心算法两次贪心： 1）局部最优：让绝对值大的负数变为正数，当前数值达到最大； ​ 整体最优：整个数组和达到最大 若所有负数都转变为正数了，k依然大于0，如何转变k次正负让数组和达到最大？ 2）局部最优：找到数值最小的正整数进行反转 ​ 整体最优：整个数组和达到最大 123456789101112131415161718192021222324252627class Solution &#123;public: class cmp &#123; public: bool operator()(int a, int b) &#123; return abs(a) &gt; abs(b); &#125; &#125;; int largestSumAfterKNegations(vector&lt;int&gt;&amp; nums, int k) &#123; // 按 绝对值大小 从大到小排序 sort(nums.begin(), nums.end(), cmp()); // 从前向后遍历，每遇到一个负数取反一次，同时k-- for (int i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] &lt; 0 &amp;&amp; k &gt; 0) &#123; nums[i] *= -1; --k; &#125; &#125; // 若k还大于0，反复取反数值最小的数，将k用完 if (k % 2 == 1) nums[nums.size() - 1] *= -1; // 求和 int result = 0; for (int i = 0; i &lt; nums.size(); ++i) result += nums[i]; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day59","date":"2024-05-30T16:00:00.000Z","updated":"2024-06-03T07:28:17.989Z","comments":true,"path":"p/leetcode/day59/","permalink":"https://krystencollins.github.io/p/leetcode/day59/","excerpt":"","text":"55. 跳跃游戏题目描述：给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例：示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 105 题解：暴力法判断是否可以跳过数组中出现的0 123456789101112131415161718192021222324class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); // 统计数组中出现的0的下标，数组最后一个元素不论大小都不需要统计 vector&lt;int&gt; zeroIdx; for (int i = 0; i &lt; size - 1; ++i) &#123; if (nums[i] == 0) zeroIdx.push_back(i); &#125; // 对于每一个0，判断是否可以跳过： // 每一个0之前的元素大小nums[j]大于 与当前0的距离，并且nums[j]不为0，则可以跳过， // 只要找到一个元素可以跳过即退出循环 // 否则，当前0之前没有一个元素大小 使其 可以跳过，则一定不可到达最后一个下标 for (int i = 0; i &lt; zeroIdx.size(); ++i) &#123; int j = zeroIdx[i] - 1; while (j &gt;= 0) &#123; if (zeroIdx[i] - j &lt; nums[j] &amp;&amp; nums[j] != 0) break; --j; &#125; if (j &lt; 0) return false; &#125; return true; &#125;&#125;; 时间复杂度：O(n^2) 空间复杂度：O(1) 贪心算法每次移动取最大跳跃步数（得到最大的覆盖范围），每次移动一个单位，更新最大覆盖范围 局部最优：每次取最大跳跃步数 全局最优：最后得到的整体最大覆盖范围，判断是否能到终点 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int cover = 0; for (int i = 0; i &lt;= cover; ++i) &#123; // 注意这里i小于等于cover cover = max(i + nums[i], cover); // 每次更新当前可以覆盖的最大覆盖范围 if (i == nums.size() - 1) return true; // 可到达终点，返回true &#125; return false; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 小优化： 123456789101112class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int cover = 0; for (int i = 0; i &lt;= cover; ++i) &#123; cover = max(i + nums[i], cover); // 当cover大于等于终点时，即说明可以到达终点！！ if (cover &gt;= nums.size() - 1) return true; &#125; return false; &#125;&#125;; 45. 跳跃游戏 II题目描述：给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处: 0 &lt;= j &lt;= nums[i] i + j &lt; n 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 示例：示例 1: 1234输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 12输入: nums = [2,3,0,1,4]输出: 2 提示: 1 &lt;= nums.length &lt;= 104 0 &lt;= nums[i] &lt;= 1000 题目保证可以到达 nums[n-1] 题解：贪心算法关键点：什么时候步数才一定要加1 从覆盖范围出发，不管怎么跳，覆盖范围一定可以跳到，以最小步数增加覆盖范围，覆盖范围一旦覆盖了终点即得到最小步数 维护两个变量：当前这一步最大覆盖范围和下一步最大覆盖范围 每一步尽可能多走，若移动下标到达当前这一步最大覆盖最远距离，还没有到达终点，必须再走下一步来增加覆盖范围。那么，下一步覆盖范围是多少？在遍历过程中，同时更新下一步最远覆盖距离！！ 1234567891011121314151617181920class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int curDistance = 0; // 当前覆盖最远距离下标 int ans = 0; // 记录走的最大步数 int nextDistance = 0; // 下一步覆盖最远距离下标 for (int i = 0; i &lt; nums.size() - 1; i++) &#123; // 更新下一步覆盖最远距离下标 nextDistance = max(nums[i] + i, nextDistance); // 遇到当前覆盖最远距离下标 if (i == curDistance) &#123; ans++; // 需要走下一步 curDistance = nextDistance; // 更新当前覆盖最远距离下标 // 当前覆盖最远距到达集合终点，直接结束 if (nextDistance &gt;= nums.size() - 1) break; &#125; &#125; return ans; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day58","date":"2024-05-29T16:00:00.000Z","updated":"2024-06-03T06:30:52.623Z","comments":true,"path":"p/leetcode/day58/","permalink":"https://krystencollins.github.io/p/leetcode/day58/","excerpt":"","text":"697. 数组的度题目描述：给定一个非空且只包含非负数的整数数组 nums，数组的 度 的定义是指数组里任一元素出现频数的最大值。 你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。 示例：示例 1： 1234567输入：nums = [1,2,2,3,1]输出：2解释：输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。连续子数组里面拥有相同度的有如下所示：[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。 示例 2： 12345输入：nums = [1,2,2,3,1,4,2]输出：6解释：数组的度是 3 ，因为元素 2 重复出现 3 次。所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。 提示： nums.length 在 1 到 50,000 范围内。 nums[i] 是一个在 0 到 49,999 范围内的整数。 题解哈希表12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; // 哈希表：统计nums元素的频数，key数组元素，value出现频数 unordered_map&lt;int, int&gt; umap; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (!umap.count(nums[i])) umap[nums[i]] = 1; else ++umap[nums[i]]; &#125; // 求nums的众数：可能众数不止一个 vector&lt;int&gt; ans; int count = umap.begin()-&gt;second; // 记录可能最大频数 ans.push_back(umap.begin()-&gt;first); for (unordered_map&lt;int, int&gt;::iterator it = umap.begin(); it != umap.end(); ++it) &#123; if (it-&gt;second == count) &#123; // 频数相同，加入ans ans.push_back(it-&gt;first); &#125; else if (it-&gt;second &gt; count) &#123; // 频数更大，说明ans中的不是众数，清空，重置 ans.clear(); ans.push_back(it-&gt;first); count = it-&gt;second; &#125; &#125; // 对于每个众数，在原数组中找到第一个元素和最后一个元素，并比较最短连续子数组的长度 int result = nums.size(); for (int i = 0; i &lt; ans.size(); ++i) &#123; int pre = 0, last = nums.size() - 1; for (int j = 0; j &lt; nums.size(); ++j) &#123; if (nums[j] == ans[i]) &#123; pre = j; break; &#125; &#125; for (int j = last; j &gt;= 0; --j) &#123; if (nums[j] == ans[i]) &#123; last = j; break; &#125; &#125; result = min(last - pre + 1, result); // 取连续子数组长度的最小值 &#125; return result; &#125;&#125;; 时间复杂度：O(n)，？？ 空间复杂度：O(n) 代码优化： 哈希表每个数映射一个长度为3的数组：这个数出现的次数、在原数组中第一次出现的位置、在原数组最后一次出现的位置 1234567891011121314151617181920212223242526class Solution &#123;public: int findShortestSubArray(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, vector&lt;int&gt;&gt; mp; int n = nums.size(); for (int i = 0; i &lt; nums.size(); ++i) &#123; // 哈希表中已有nums[i]，频数+1，更新最后一次出现的位置 if (mp.count(nums[i])) &#123; mp[nums[i]][0]++; mp[nums[i]][2] = i; &#125; else &#123; mp[nums[i]] = &#123;1, i, i&#125;; &#125; &#125; int maxNum = 0, minLen = 0; for (auto&amp; [_, vec] :mp) &#123; if (maxNum &lt; vec[0]) &#123; maxNum = vec[0]; minLen = vec[2] - vec[1] + 1; &#125; else if (maxNum == vec[0]) &#123; // 遇到具有相同频数的元素，取最短连续子数组 minLen = min(vec[2] - vec[1] + 1, minLen); &#125; &#125; return minLen; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(n)","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day57","date":"2024-05-28T16:00:00.000Z","updated":"2024-06-03T06:05:57.907Z","comments":true,"path":"p/leetcode/day57/","permalink":"https://krystencollins.github.io/p/leetcode/day57/","excerpt":"","text":"121. 买卖股票的最佳时机题目描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例：示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104**** 题解：用一个变量记录历史最低价格minprice，假设自己的股票是在那天买的，在第i天卖出股票得到的利润为prices[i]-minprice。同时更新最大利润！！ 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int inf = 1e9; // 模拟无穷大 int minprice = inf; // 初始化历史最低价格为无穷大 int maxprofit = 0; // 初始化最大利润为0 for (int i = 0; i &lt; prices.size(); ++i) &#123; // 更新最大利润：假设在历史最低价格买入，在当前价格卖出 maxprofit = max(maxprofit, prices[i] - minprice); // 更新历史最低价 minprice = min(minprice, prices[i]); &#125; return maxprofit; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 122. 买卖股票的最佳时机 II题目描述：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例：示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 1234输入：prices = [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 提示： 1 &lt;= prices.length &lt;= 3 * 104 0 &lt;= prices[i] &lt;= 104 题解：贪心算法把利润分解为以每天为单位的维度，而不是整体去考虑 局部最优：收集每天的正利润 全局最优：求得最大利润 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int result = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; if (prices[i] &gt; prices[i - 1]) &#123; result += prices[i] - prices[i - 1]; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 小优化： 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int result = 0; for (int i = 1; i &lt; prices.size(); ++i) &#123; result += max(prices[i] - prices[i - 1], 0); &#125; &#125; return result;&#125;; 动态规划1","categories":[],"tags":[]},{"title":"最大子数组和","slug":"p/leetcode/day56","date":"2024-05-27T16:00:00.000Z","updated":"2024-07-02T14:54:58.580Z","comments":true,"path":"p/leetcode/day56/","permalink":"https://krystencollins.github.io/p/leetcode/day56/","excerpt":"","text":"53. 最大子数组和题目描述：给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 示例：示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 105 -104 &lt;= nums[i] &lt;= 104 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 题解：贪心算法123456789101112131415class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int result = INT_MIN; int sum = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; sum += nums[i]; // 取区间累计的最大值，相当于不断确定最大子序列终止位置 result = sum &gt; result ? sum : result; // 重置最大子序列起始位置，因为遇到总和为负数了 后续一定拉低总和 if (sum &lt;= 0) sum = 0; &#125; return result; &#125;&#125;; 动态规划1// 待定 分治法1// 待定","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]},{"title":"","slug":"p/leetcode/day55","date":"2024-05-26T16:00:00.000Z","updated":"2024-05-28T06:47:10.466Z","comments":true,"path":"p/leetcode/day55/","permalink":"https://krystencollins.github.io/p/leetcode/day55/","excerpt":"","text":"贪心算法解题步骤： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解推叠成全局最优解 想清楚 局部最优是什么？如何推出全局最优？ 455. 分发饼干题目描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例：示例 1: 123456输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 123456输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示： 1 &lt;= g.length &lt;= 3 * 104 0 &lt;= s.length &lt;= 3 * 104 1 &lt;= g[i], s[j] &lt;= 231 - 1 题解：方法一局部最优：大饼干喂给大胃口的， 全局最优：喂饱尽可能多的小孩 12345678910111213141516class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int result = 0; // 遍历胃口 for (int i = g.size() - 1, index = s.size() - 1; i &gt;= 0 &amp;&amp; index &gt;= 0; --i) &#123; if (s[index] &gt;= g[i]) &#123; // 相当于遍历饼干 ++result; --index; &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(nlog n) 空间复杂度：O(1) 方法二小饼干先喂饱小胃口 123456789101112131415class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int index = 0; // 遍历饼干 for (int i = 0; i &lt; s.size() &amp;&amp; index &lt; g.size(); ++i) &#123; if (g[index] &lt;= s[i]) &#123; // 相当于遍历胃口 ++index; &#125; &#125; return index; &#125;&#125;; 376. 摆动序列题目描述：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例：示例 1： 123输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 1234输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 12输入：nums = [1,2,3,4,5,6,7,8,9]输出：2 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 1000 进阶：你能否用 O(n) 时间复杂度完成此题? 题解：贪心算法12345678910111213141516171819class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); int curDiff = 0; // 当前一对差值 int preDiff = 0; // 前一对差值 int result = 1; // 初始化为1 for (int i = 0; i &lt; nums.size() - 1; ++i) &#123; curDiff = nums[i + 1] - nums[i]; // 先 非递增 再严格递增； 先 非递减 再严格递减 // 即 只要出现平坡都只计算最后一个相等数值 if ((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)) &#123; ++result; preDiff = curDiff; // 只要摆动变化了就更新preDiff &#125; &#125; return result; &#125;&#125;; 时间复杂度：O(n) 空间复杂度：O(1) 动态规划1","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day54","date":"2024-05-25T16:00:00.000Z","updated":"2024-05-27T12:00:09.974Z","comments":true,"path":"p/leetcode/day54/","permalink":"https://krystencollins.github.io/p/leetcode/day54/","excerpt":"","text":"332. 重新安排行程题目描述：给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。 例如，行程 [&quot;JFK&quot;, &quot;LGA&quot;] 与 [&quot;JFK&quot;, &quot;LGB&quot;] 相比就更小，排序更靠前。 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。 示例：示例 1： 12输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;] 示例 2： 123输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。 提示： 1 &lt;= tickets.length &lt;= 300 tickets[i].length == 2 fromi.length == 3 toi.length == 3 fromi 和 toi 由大写英文字母组成 fromi != toi 题解：详细思路 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // unordered_map&lt;出发机场，map&lt;到达机场，航班次数&gt;&gt; target unordered_map&lt;string, map&lt;string, int&gt;&gt; targets; bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) &#123; if (result.size() == ticketNum + 1) &#123; return true; &#125; for (pair&lt;const string, int&gt;&amp; target :targets[result.back()]) &#123; if (target.second &gt; 0) &#123; // 记录到达机场是否飞过了 result.push_back(target.first); --target.second; if (backtracking(ticketNum, result)) return true; ++target.second; result.pop_back(); &#125; &#125; return false; &#125; vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123; targets.clear(); vector&lt;string&gt; result; for (const vector&lt;string&gt;&amp; vec : tickets) &#123; targets[vec[0]][vec[1]]++; // 记录映射关系 &#125; result.push_back(&quot;JFK&quot;); // 起始机场 backtracking(tickets.size(), result); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day53","date":"2024-05-17T16:00:00.000Z","updated":"2024-05-19T08:54:28.537Z","comments":true,"path":"p/leetcode/day53/","permalink":"https://krystencollins.github.io/p/leetcode/day53/","excerpt":"","text":"46. 全排列题目描述：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例：示例 1： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 12输入：nums = [0,1]输出：[[0,1],[1,0]] 示例 3： 12输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 nums 中的所有整数 互不相同 题解：回溯 排列：每个节点都从0开始遍历 去重，横向纵向同时进行，”哈希表“为“全局变量”，需要做回溯 结果，在叶子节点收集 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int used[21] = &#123;0&#125;; // 数组作哈希表（题目给出数组范围[-10, 10]） void backtracking(vector&lt;int&gt; nums) &#123; // 当path长度等于nums长度，已遍历完一遍nums if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; // 每个节点都从0开始遍历 for (int i = 0; i &lt; nums.size(); ++i) &#123; // 去重（包含横向纵向），若当前层已使用 或 根节点到该节点路径上已使用，跳过（而不是退出） if (used[nums[i] + 10] == 1) continue; used[nums[i] + 10] = 1; // 记录已使用 path.push_back(nums[i]); backtracking(nums); // 递归 used[nums[i] + 10] = 0; // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums); return result; &#125;&#125;; 时间复杂度：O(n!) 空间复杂度：O(n) 优化，”哈希表“只开辟 当前数组长度 的大小，但需要使用引用 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (used[i] == 1) continue; used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;; 47. 全排列 II题目描述：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 示例：示例 1： 12345输入：nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]] 示例 2： 12输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示： 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 题解：回溯 横向去重和纵向去重分别进行 数组used纵向去重，需要回溯 数组uset横向去重，不需要回溯，非排序，相同值元素出现位置可能不连续 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; int uset[21] = &#123;0&#125;; // 题目给定数组范围[-10, 10], for (int i = 0; i &lt; nums.size(); ++i) &#123; if (uset[nums[i] + 10] == 1 || used[i] == 1) continue; uset[nums[i] + 10] = 1; // 不需要回溯 used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;; 时间复杂度：O(n * n!) 空间复杂度：O(n) 排序+回溯 横向去重：先排序，使用数组下标和used数组配合 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, vector&lt;int&gt;&amp; used) &#123; if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; // 前半部分：横向去重，必须有used[i - 1] == 0，说明同一层used[i-1]使用过（已回溯为0） // used[i - 1] == 1说明同一树枝used[i-1]使用过，另一种思路，“树更茂盛” // 后半部分：纵向去重 if ((i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == 0) || used[i] == 1) continue; used[i] = 1; path.push_back(nums[i]); backtracking(nums, used); used[i] = 0; // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); // 排序 vector&lt;int&gt; used(nums.size(), 0); backtracking(nums, used); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"非递减子序列","slug":"p/leetcode/day52","date":"2024-05-16T16:00:00.000Z","updated":"2024-05-19T07:23:02.196Z","comments":true,"path":"p/leetcode/day52/","permalink":"https://krystencollins.github.io/p/leetcode/day52/","excerpt":"","text":"491. 非递减子序列题目描述：给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 示例：示例 1： 12输入：nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] 示例 2： 12输入：nums = [4,4,3,2,1]输出：[[4,4]] 提示： 1 &lt;= nums.length &lt;= 15 -100 &lt;= nums[i] &lt;= 100 题解：回溯，哈希表横向去重 不能先排序，因为排序后整个数组即非递减 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; // 可省略 unordered_set&lt;int&gt; uset; // 横向去重：哈希表记录当前层已遍历相同值元素 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; // 哈希表若已存在相同值元素，直接跳过，而不是break退出循环 if (uset.count(nums[i])) continue; uset.insert(nums[i]); // 错误去重，未排序数组，同一层 相同值元素位置可能不连续！！ // if (i &gt; startIdx &amp;&amp; nums[i] == nums[i - 1]) continue; int size = path.size(); // 判断是否非递减 if (size != 0 &amp;&amp; nums[i] &lt; path[size - 1]) continue; path.push_back(nums[i]); // 至少两个元素构成一个结果。在搜索树中的每一个节点收集结果，而不是叶子节点收集 if (size != 0) result.push_back(path); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n) 代码优化，使用数组作为哈希表 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (path.size() &gt; 1) result.push_back(path); int used[201] = &#123;0&#125;; // 题目给出数组范围[-] for (int i = startIdx; i &lt; nums.size(); ++i) &#123; if (used[nums[i] + 100] == 1 || (!path.empty() &amp;&amp; nums[i] &lt; path.back())) continue; used[nums[i] + 100] = 1; path.push_back(nums[i]); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; backtracking(nums, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day51","date":"2024-05-15T16:00:00.000Z","updated":"2024-05-19T09:10:28.289Z","comments":true,"path":"p/leetcode/day51/","permalink":"https://krystencollins.github.io/p/leetcode/day51/","excerpt":"","text":"78. 子集题目描述：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例：示例 1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 题解：定义法将新元素 分别插入原幂集每一个子集中 循环+递归： 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; int size = result.size(); // 提取记录当前result大小，因为循环过程中不断变化 for (int i = 0; i &lt; size; ++i) &#123; vector&lt;int&gt; path = result[i]; // 取出上一层result所有子集 path.push_back(nums[startIdx]); // 在末尾追加当前遍历元素nums[startidx] result.push_back(path); // 插入到result中 &#125; backtracking(nums, startIdx + 1); // 下一层，递归遍历nums[startIdx+1] &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 优化，双重循环 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result = &#123;&#123;&#125;&#125;; for (int i = 0; i &lt; nums.size(); ++i) &#123; int size = result.size(); for (int j = 0; j &lt; size; ++j) &#123; vector&lt;int&gt; path = result[j]; path.push_back(nums[i]); result.push_back(path); &#125; &#125; return result; &#125;&#125;; 回溯1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; // startIdx遍历位置为nums长度时，已遍历完 if (startIdx == nums.size()) return; // 可省略 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; path.push_back(nums[i]); result.push_back(path); // 搜索树每个节点都收集中间结果，而不是叶子节点再收集 backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 90. 子集 II题目描述：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 示例：示例 1： 12输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]] 示例 2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 题解：回溯排序，横向去重 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; // 可省略 for (int i = startIdx; i &lt; nums.size(); ++i) &#123; // 横向去重：若遇到已经遍历的相同值元素，跳过，而不是直接退出，因为后续可能还有其他值元素 if (i &gt; startIdx &amp;&amp; nums[i] == nums[i - 1]) continue; path.push_back(nums[i]); result.push_back(path); // 在搜素中的每个节点收集中间结果，而不是叶子节点 backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); // 去重，先排序 result.push_back(&#123;&#125;); backtracking(nums, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n) 哈希表去重使用哈希表横向去重，也必须优先排序，因为递归的时候下一个startIdx是i+1而不是0（即相同值位置不连续，每个节点从startIdx开始遍历，未排序的话就无法真正去重） 因此本题哈希表作用不明显，可直接使用下标去重 若为全排列，每次从0开始遍历，使用哈希表去重作用明显 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; nums, int startIdx) &#123; if (startIdx == nums.size()) return; unordered_set&lt;int&gt; uset; for (int i = startIdx; i &lt; nums.size(); ++i) &#123; if (uset.count(nums[i])) continue; uset.insert(nums[i]); path.push_back(nums[i]); result.push_back(path); backtracking(nums, i + 1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; result.push_back(&#123;&#125;); sort(nums.begin(), nums.end()); backtracking(nums, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day50","date":"2024-05-14T16:00:00.000Z","updated":"2024-05-19T05:43:17.145Z","comments":true,"path":"p/leetcode/day50/","permalink":"https://krystencollins.github.io/p/leetcode/day50/","excerpt":"","text":"131. 分割回文串题目描述：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 示例：示例 1： 12输入：s = &quot;aab&quot;输出：[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]] 示例 2： 12输入：s = &quot;a&quot;输出：[[&quot;a&quot;]] 提示： 1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成 题解：回溯12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 判断是否为回文串 bool isPalindrome(string subStr) &#123; int size = subStr.size(); for (int i = 0, j = size - 1; i &lt; size / 2; ++i, --j) &#123; if (subStr[i] != subStr[j]) return false; &#125; return true; &#125; void backtracking(string s, int startIdx) &#123; if (startIdx == s.size()) &#123;// 当分割开始下标为s长度时，已分割完 result.push_back(path); return; &#125; // startIdx记录每个节点集合开始遍历的下标，n记录子串长度， for (int i = startIdx, n = 1; i &lt; s.size(); ++i, ++n) &#123; string subStr = s.substr(startIdx, n); // 横向：每次从startIdx开始取n个字符 if (!isPalindrome(subStr)) continue; // 遇到子串为 非回文串，必须continue，后续子串可能构成回文 path.push_back(subStr); // 处理 backtracking(s, i + 1); // 递归，i+1不可重复使用字符 path.pop_back(); // 回溯 &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; backtracking(s, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2*n) 空间复杂度：O(n) 动态规划+回溯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;private: vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; path; // 放已经回文的子串 vector&lt;vector&lt;bool&gt;&gt; isPalindrome; // 放事先计算好的是否回文子串的结果 void backtracking (const string&amp; s, int startIndex) &#123; // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了 if (startIndex &gt;= s.size()) &#123; result.push_back(path); return; &#125; for (int i = startIndex; i &lt; s.size(); i++) &#123; if (isPalindrome[startIndex][i]) &#123; // 是回文子串 // 获取[startIndex,i]在s中的子串 string str = s.substr(startIndex, i - startIndex + 1); path.push_back(str); &#125; else &#123; // 不是回文，跳过 continue; &#125; backtracking(s, i + 1); // 寻找i+1为起始位置的子串 path.pop_back(); // 回溯过程，弹出本次已经添加的子串 &#125; &#125; // 动态规划：计算子串是否为回文串 void computePalindrome(const string&amp; s) &#123; // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 isPalindrome.resize(s.size(), vector&lt;bool&gt;(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小 for (int i = s.size() - 1; i &gt;= 0; i--) &#123; // 需要倒序计算, 保证在i行时, i+1行已经计算好了 for (int j = i; j &lt; s.size(); j++) &#123; if (j == i) &#123;isPalindrome[i][j] = true;&#125; else if (j - i == 1) &#123;isPalindrome[i][j] = (s[i] == s[j]);&#125; else &#123;isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125; &#125; &#125; &#125; public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; result.clear(); path.clear(); computePalindrome(s); backtracking(s, 0); return result; &#125;&#125;; 时间复杂度：O(n * 2^n) 空间复杂度：O(n^2) 93. 复原 IP 地址题目描述：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和 &quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#39;.&#39; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 示例：示例 1： 12输入：s = &quot;25525511135&quot;输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;] 示例 2： 12输入：s = &quot;0000&quot;输出：[&quot;0.0.0.0&quot;] 示例 3： 12输入：s = &quot;101023&quot;输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;] 提示： 1 &lt;= s.length &lt;= 20 s 仅由数字组成 题解：回溯123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;string&gt; result; string path; // 判断子串ip是否有效 bool isValid(string subStr) &#123; // 含有前导0，无效 if (subStr.size() &gt; 1 &amp;&amp; subStr[0] == &#x27;0&#x27;) return false; int num = atoi(subStr.c_str()); // string转int型 if (num &lt; 0 || num &gt; 255) return false; return true; &#125; // startIdx记录遍历起始位置，depth记录树深度（即分割次数，子串数量） void backtracking(string s, int startIdx, int depth) &#123; // 起始位置为s大小且刚好分割4次，找到一组有效ip分割方案 if (startIdx == s.size() &amp;&amp; depth == 4) &#123; string ip = path.substr(0, path.size() - 1); // 去掉末尾的&quot;.&quot;，不能改变path，因为在上一层回溯 result.push_back(ip); return; &#125; for (int i = startIdx, n = 1; i &lt; s.size() &amp;&amp; n &lt;= 3; ++i, ++n) &#123; if (depth == 4) return; // 分割4次还未分割完，无效，直接返回 string subStr = s.substr(startIdx, n); // 横向：每次从startIdx开始取n个字符，且最多取三个 if (!isValid(subStr)) return; // 无效子串直接返回，而不是continue，因为该循环内后续一定无效 int size = path.size(); path += subStr + &quot;.&quot;; // 处理：追加子串和ip分隔符&quot;.&quot; backtracking(s, i + 1, depth + 1); // 递归：depth隐藏回溯 path.erase(size, subStr.size() + 1); // 回溯：移除末尾子串和分割符 &#125; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; backtracking(s, 0, 0); return result; &#125;&#125;; 时间复杂度：O(3^4)，ip地址最多包含4个数字，每个数字最多3种可能的分割方式，即搜索树最大深度为4，每个几点最多3个节点 空间复杂度：O(n) 优化，”剪枝“ 根据字符串长度剪枝 不使用path变量，直接在原字符串插入分隔符 单个字符判断是否有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;string&gt; result; // startIdx记录搜索的起始位置，pointNum记录添加分隔符数量 void backtracking(string&amp; s, int startIdx, int pointNum) &#123; if (pointNum == 3) &#123; // 判断第四段子串是否合法，若合法就放进result if (isValid(s, startIdx, s.size() - 1)) result.push_back(s); return; &#125; for (int i = startIdx; i &lt; s.size(); ++i) &#123; // 判断[startIdx, i]这个区间的子串是否合法， if (isValid(s, startIdx, i)) &#123; s.insert(s.begin() + i + 1, &#x27;.&#x27;); // 在i的后面插入一个分隔符 ++pointNum; backtracking(s, i + 2, pointNum); // 递归：插入分隔符后下一个子串的起始位置为i+2 --pointNum; // 回溯 s.erase(s.begin() + i + 1); // 回溯删掉分隔符 &#125; else break; //不合符，直接退出本层循环 &#125; &#125; // 判断字符串s在左闭右闭[start, end]区间内，所组成的数字是否合法 bool isValid(string&amp; s, int start, int end) &#123; if (start &gt; end) return false; // 含有前导0 if (s[start] == &#x27;0&#x27; &amp;&amp; start != end) return false; int num = 0; for (int i = start; i &lt;= end; ++i) &#123; // 遇到非数字字符 if (s[i] &gt; &#x27;9&#x27; || s[i] &lt; &#x27;0&#x27;) return false; num = num * 10 + (s[i] - &#x27;0&#x27;); // num大于255非法数字串 if (num &gt; 255) return false; &#125; return true; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; // “剪枝” if (s.size() &lt; 4 || s.size() &gt; 12) return result; backtracking(s, 0, 0); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"","slug":"p/leetcode/day49","date":"2024-05-13T16:00:00.000Z","updated":"2024-05-16T13:42:48.083Z","comments":true,"path":"p/leetcode/day49/","permalink":"https://krystencollins.github.io/p/leetcode/day49/","excerpt":"","text":"39. 组合总和题目描述：给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例：示例 1： 123456输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 示例 2： 12输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 12输入: candidates = [2], target = 1输出: [] 提示： 1 &lt;= candidates.length &lt;= 30 2 &lt;= candidates[i] &lt;= 40 candidates 的所有元素 互不相同 1 &lt;= target &lt;= 40 题解：递归，回溯123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; // 存储中间和 void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (sum &gt; target) return; // 当sum&gt;target，不必再递归 if (sum == target) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt; candidates.size(); ++i) &#123; sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); // 不使用i+1，可重复使用元素 sum -= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(candidates, target, 0); return result; &#125;&#125;; 优化 取消中间和1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int&amp; target, int startIdx) &#123; if (target &lt; 0) return; if (target == 0) &#123; result.push_back(path); return; &#125; // target每次减掉遍历元素， 当target减为0时找到符合条件组合 for (int i = startIdx; i &lt; candidates.size(); ++i) &#123; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; backtracking(candidates, target, 0); return result; &#125;&#125;; 剪枝优化1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (target == 0) &#123; result.push_back(path); return; &#125; // 剪枝：排序后，当target减为0时不再递归 for (int i = startIdx; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0; ++i) &#123; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i); // 不用i+1,可以重复使用元素 target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 剪枝先排序 backtracking(candidates, target, 0); return result; &#125;&#125;; 40. 组合总和 II题目描述：给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 示例：示例 1: 12345678输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]] 示例 2: 123456输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]] 提示: 1 &lt;= candidates.length &lt;= 100 1 &lt;= candidates[i] &lt;= 50 1 &lt;= target &lt;= 30 题解：横向剪枝优化123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (sum &gt; target) return; if (sum == target) &#123; result.push_back(path); return; &#125; // 剪枝：已排序，当sum+下一个元素&gt;target不再递归 for (int i = startIdx; i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123; // 横向剪枝，在同一个节点的分支不重复取相同 值 的元素 if(i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - 1]) continue; sum += candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i + 1); // 纵向可以取相同值的元素 sum -= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); // 先排序，利于剪枝 backtracking(candidates, target, 0); return result; &#125;&#125;; 优化，取消中间和123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking(vector&lt;int&gt; candidates, int target, int startIdx) &#123; if (target == 0) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;= 0; ++i) &#123; if(i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - 1]) continue; target -= candidates[i]; path.push_back(candidates[i]); backtracking(candidates, target, i + 1); target += candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0); return result; &#125;&#125;; 216. 组合总和 III题目描述：找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例：示例 1: 12345输入: k = 3, n = 7输出: [[1,2,4]]解释:1 + 2 + 4 = 7没有其他符合的组合了。 示例 2: 1234567输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]解释:1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。 示例 3: 1234输入: k = 4, n = 1输出: []解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。 提示: 2 &lt;= k &lt;= 9 1 &lt;= n &lt;= 60 题解：递归，回溯12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(int k, int n, int startIdx) &#123; // 当选择元素已满或sum&gt;n直接返回 if (path.size() &gt; k || sum &gt; n) return; if (path.size() == k &amp;&amp; sum == n) &#123; result.push_back(path); return; &#125; for (int i = startIdx; i &lt;= 9 ; ++i) &#123; sum += i; path.push_back(i); backtracking(k, n, i + 1); sum -= i; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return result; &#125;&#125;; 剪枝优化123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int sum = 0; void backtracking(int k, int n, int startIdx) &#123; if (sum &gt; n) return; // 若sum &gt; n 直接返回 if (path.size() == k) &#123; if (sum == n) result.push_back(path); return; // 若path.size() == k，但 sum != n直接返回 &#125; // 剪枝遍历范围 for (int i = startIdx; i &lt;= 9 - (k - path.size()) + 1; ++i) &#123; sum += i; path.push_back(i); backtracking(k, n, i + 1); sum -= i; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; backtracking(k, n, 1); return result; &#125;&#125;;","categories":[],"tags":[]},{"title":"Hello World","slug":"p/hello-world","date":"2024-05-02T14:06:09.325Z","updated":"2024-05-02T14:06:09.326Z","comments":true,"path":"p/hello-world/","permalink":"https://krystencollins.github.io/p/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://krystencollins.github.io/categories/leetcode/"}],"tags":[]}